<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>(アプリ開発者のための) TCP/IP ネットワーク入門</title>
<style><!--
body { line-height: 1.5; }
h1 { border-bottom: solid 4px #000088; }
h2 { border-bottom: solid 2px #000088; }
h3 { border-bottom: solid 1px #000088; }
table { border-collapse: collapse; margin: 1em; }
td { padding: 4px; }
kbd { outline: 1px solid black; padding: 2px; }
blockquote { outline: 1px solid black; padding: 4px; }
pre { overflow: auto; margin: 0; }
mark { font-weight: bold; }
pre, code { background: #ddd; font-size: 150%; font-family: courier; }
img { max-width: 80vw; height: auto; }
dt { text-decoration: underline; font-weight: bold; }
u { color: #880000; font-weight: bold; }
.author { text-align: right; }
.figure { outline: 1px solid black; padding: 0.5em; margin: 1em; text-align: center; }
.notice { font-size: 100%; font-weight: bold; background: #ffff88; outline: 2px solid black; padding: 0.5em; margin: 0.5em; }
.formula { background: #88ff88; outline: 2px solid black; padding: 1em; margin: 1em; }
.note { background: #ffff88; outline: 2px solid black; padding: 1em; margin: 1em; }
pre em { color: #008800; }
code em { color: #000088; }
.exercise { outline: 2px solid black; padding: 1em; margin: 1em; }
.exercise > .header { font-size: 120%; font-weight: bold; border-bottom: solid 1px red; border-left: 4px solid red; padding-left: 8px; }
.bl { outline: 1px solid black; padding: 2px; font-size: 120%; color: transparent; }
.file { outline: 2px solid black; padding: 1em; margin: 1em; }
.file > .header { font-weight: bold; color: white; background: #000088; margin-bottom: 4px; padding-left: 1em; }
.file pre { margin: 0; }

.g { background: #eeeeee; }
.bgr { background: #ffbbff; }
.bgg { background: #88ff88; }
.bgb { background: #88ffff; }
.bgy { background: #ffff88; }
--></style>
</head>
<body>
<div class=nav>
<a href="../index.html">&lt; もどる</a>
</div>
<h1>(アプリ開発者のための)<br>
TCP/IP ネットワーク入門</h1>

<div class=author>
Yusuke Shinyama, Jan. 2023
</div>

<p>
<strong>概要:</strong>
この記事では、アプリ開発者の役に立ちそうな
TCP/IPネットワークに関する最低限の知識をまとめた。
あくまで視点は「アプリ開発者」なので、
現在の家庭・企業における一般的なネットワーク環境しか想定していないし、
セキュリティに関しても基本的なことしかカバーしていない。
ネットワーク機器の具体的な設定方法や診断については、より専門的な資料を参照のこと。
</p>

<ol>
<li> <a href="#internet">インターネットの作り方・概要</a>
<ul>
  <li> <a href="#internet-basic">ネットワーク通信の原理</a>
  <li> <a href="#internet-layers">ネットワークの「階層」</a>
  <li> <a href="#internet-datalink">データリンク層</a>
  <li> <a href="#internet-ip">IP層 (ネットワーク層)</a>
  <li> <a href="#internet-tcp">TCP層 (トランスポート層)</a>
  <li> <a href="#internet-application">アプリケーション層</a>
</ul>
<li> <a href="#datalink">データリンク層のしくみ</a>
<ul>
  <li> <a href="#datalink-macaddr">物理アドレス (MACアドレス)</a>
  <li> <a href="#datalink-duplex">通信方式</a>
  <li> <a href="#datalink-frame">Ethernetフレーム</a>
</ul>
<li> <a href="#ip">IP層 (ネットワーク層) のしくみ</a>
<ul>
  <li> <a href="#ip-addr">IPアドレス</a>
  <li> <a href="#ip-packet">IPパケット</a>
  <li> <a href="#ip-routing">ルーティング</a>
  <li> <a href="#ip-cidr">CIDR 方式</a>
  <li> <a href="#ip-wan">広域レベルでのルーティング</a>
</ul>
<li> <a href="#tcp">TCP層 (トランスポート層) のしくみ</a>
<ul>
  <li> <a href="#tcp-details">TCPの詳細</a>
  <li> <a href="#tcp-client-server">「クライアント」と「サーバ」</a>
  <li> <a href="#tcp-udp">UDP層</a>
</ul>
<li> <a href="#application">アプリケーション層</a>
<ul>
  <li> <a href="#app-dns">ドメイン名検索 (DNS)</a>
  <li> <a href="#app-web">ウェブ (HTTP)</a>
  <li> <a href="#app-email">電子メール (SMTP)</a>
</ul>
<li> <a href="#encryption">暗号化</a>
<ul>
  <li> <a href="#encryption-tls">TLS/SSL層</a>
  <li> <a href="#encryption-ssh">SSH層</a>
</ul>
<li> <a href="#security">セキュリティ</a>
<ul>
  <li> <a href="#security-privateip">プライベートIPアドレス</a>
  <li> <a href="#security-nat">NAT</a>
  <li> <a href="#security-firewall">ファイヤウォール</a>
  <li> <a href="#security-proxy">プロキシサーバ</a>
  <li> <a href="#security-vpn">VPN</a>
</ul>
</ol>

<h4>使用するツール</h4>
<div class=formula>
<a target="_blank" href="https://www.wireshark.org/">Wireshark</a> :
パケットキャプチャ・解析ツール。
</div>


<h2 id="internet">1. インターネットの作り方・概要</h2>

<h3 id="internet-basic">1.1. ネットワーク通信の原理</h3>
<p>
インターネットに接続されている各コンピュータのことを
<u>ホスト</u> (host) と呼ぶ。
インターネットでは、信号線は基本的に 1本しかなくても、
複数のホストどうしが同時に双方向で通信できる。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="400" height="220">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <symbol id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </symbol>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" transform="translate(10,100)" />
      <use xlink:href="#computer" transform="translate(100,40)" />
      <use xlink:href="#computer" transform="translate(120,120)" />
      <use xlink:href="#computer" transform="translate(200,160)" />
      <use xlink:href="#computer" transform="translate(210,50)" />
      <use xlink:href="#computer" transform="translate(280,100)" />
      <use xlink:href="#computer" transform="translate(290,10)" />
      <line x1="50" y1="120" x2="130" y2="140" />
      <line x1="140" y1="130" x2="120" y2="80" />
      <line x1="140" y1="60" x2="220" y2="70" />
      <line x1="150" y1="160" x2="210" y2="180" />
      <line x1="230" y1="170" x2="240" y2="90" />
      <line x1="240" y1="180" x2="300" y2="140" />
      <line x1="305" y1="110" x2="310" y2="50" />
      <path d="M 70,150 C 80,150 120,150 140,170 C 160,200 200,210 230,210 C 270,210 290,170 300,150" marker-end="url(#arrow)" stroke="blue" />
      <path d="M 290,60 C 290,70 290,110 280,130 C 270,150 240,160 230,160 C 210,160 170,140 150,120 C 140,110 140,90 140,90" marker-end="url(#arrow)" stroke="blue" />
    </g>
  </svg>
</div>

<p>
これを実現するには、2通りの方法がある:
<a target="_blank" href="https://www.youtube.com/embed/-uuNf3_FZH0">回線交換</a> と
<u>パケット通信</u>。
インターネットを含む現在のコンピュータネットワークでは、
パケット通信を使っている。
ケーブルの中には、多様なデータのパケットが流れており、
各パケットには、行き先をあらわす「<u>アドレス</u>」がついている。
データの種類は、各パケットにつけられた「<u>ポート番号</u>」および
「通信手順 (<u>プロトコル</u>)」で区別する。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="600" height="200">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g stroke="black" stroke-width="3" fill="none">
      <rect x="60" y="10" width="500" height="180" />
      <ellipse cx="60" cy="100" rx="50" ry="90" fill="white" />
      <rect x="180" y="25" width="80" height="40" />
      <rect x="405" y="65" width="80" height="40" />
      <rect x="330" y="130" width="100" height="40" />
      <rect x="160" y="100" width="80" height="40" />
      <line x1="180" y1="40" x2="140" y2="40" marker-end="url(#arrow)" />
      <line x1="240" y1="120" x2="290" y2="120" marker-end="url(#arrow)" />
      <line x1="485" y1="80" x2="510" y2="80" marker-end="url(#arrow)" />
      <line x1="330" y1="150" x2="290" y2="150" marker-end="url(#arrow)" />
    </g>
    <g text-anchor="middle">
      <text x="220" y="40" dy="0.5em">ウェブ</text>
      <text x="445" y="80" dy="0.5em">LINE</text>
      <text x="200" y="120" dy="0.5em">メール</text>
      <text x="380" y="145" dy="0.5em">動画配信</text>
    </g>
    <g>
      <text x="170" y="60" dy="0.5em" text-anchor="end">11.22.33.44</text>
      <text x="490" y="100" dy="0.5em" text-anchor="begin">55.66.77.88</text>
      <text x="245" y="130" dy="0.5em" text-anchor="begin">123.45.200.10</text>
      <text x="320" y="165" dy="0.5em" text-anchor="end">20.10.8.5</text>
    </g>
  </svg>
</div>

<h4>インターネット以外に使われている (いた) ネットワーク規格</h4>
<ul>
<li> ATM (国内のみ)
<li> AppleTalk (LAN のみ)
<li> <u>OSI</u> (Open Systems Interconnection)
<li> …
</ul>

<h3 id="internet-layers">1.2. ネットワークの「階層」</h3>
<p>
ネットワークは構築するのが大変だ。(道路と同じ)
</p>
<ul>
<li> いろいろな端末・機器を変えたい。 =  送信機・受信機 (クライアント/端末) の自由
<li> いろいろな用途に使いたい。 = 伝えたい「内容」 (アプリケーション) の自由
<li> いろいろな伝送経路を使いたい。 = 伝送媒体 (メディア、“土管”) の自由
</ul>

<p>
いくつかの取り替え可能な「部品」から作る。(ソフトウェアと同じ)
あるレイヤーを使っている人は、その下の階層をよく知らない。
そのため揶揄的に“土管”などと呼ばれる。
</p>

<h4>OSIの7階層モデル</h4>
<p>
OSI はネットワーク規格としては普及しなかったが、
その階層モデルはいまだ説明用によく言及されている。
</p>
<ul>
<li> ハードウェアおよびソフトウェアが 7つの層 (レイヤー) に分けて設計されている。
<li> 各層 (レイヤー) の機能は、その下の層の機能に依存している。
</ul>

<ol>
<li> 物理層
<li> データリンク層
<li> ネットワーク層 (= IP層に相当)
<li> トランスポート層 (= TCP層に相当)
<li> セッション層
<li> プレゼンテーション層
<li> アプリケーション層 (= アプリケーション層に相当)
</ol>

<h4>TCP/IPの4階層モデル</h4>
<ul>
<li> データリンク層 (レイヤー2)
<li> IP層 (レイヤー3)
<li> TCP層 (レイヤー4)
<li> アプリケーション層 (レイヤー7)
</ul>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<p>
インターネットではデータリンク層と物理層を区別していない。
また、アプリケーション層から上は「使う人が勝手に決める」。
</p>
<p>
注意: インターネットの階層でハードウェアが関連しているのは
おもにデータリンク層だけである。それ以上の階層は、
すべてソフトウェア的な「部品」であり、
現在は OS の機能の一部として提供されている。
</p>

<p>
テレビなどと比較すると、インターネットでは上の要素はどれも可変である。
唯一の規格は送受信の方式だけ。そのため、
インターネットは「自由なネットワークだ」といわれる。
</p>

<h3 id="internet-datalink">1.3. データリンク層</h3>
<p>
すべての通信では、まずデータ (0/1 の列) をどうにかして
別のコンピュータに送らねばならない。
これがデータリンク層の役割である。
</p>
<ul>
<li> 長所: 伝送エラーがあった場合は自動的に再送される。
<li> 短所: すぐ隣のホスト間でしか情報を送れない。
</ul>

いくつかの方法がある。

<h4>イーサネット (Ethernet)</h4>
<p>
よく使われている方式のひとつ。
電線あるいは光ファイバーを使って、
接続されているすべてのホストに
同じ情報を一斉に送る (ブロードキャスト)。
</p>

<h4>無線LAN</h4>
<p>
電波を使って、すべてのホストに
同じ情報を一斉に送る (ブロードキャスト)。
そのためこれは電線を使わないイーサネットの一種とみなされている。
</p>

<h4>海底ケーブル</h4>
<p>
ひとつ隣のホストは別の国である。
</p>
<ul>
<li> <a target="_blank" href="https://www.telegeography.com/telecom-resources/map-gallery/index.html">海底ケーブル地図</a>
<li> <a target="_blank" href="https://en.wikipedia.org/wiki/SEA-ME-WE_3_%28cable_system%29">SEA-ME-WE</a>
(全長39,000キロ、世界最長, 960Gbps)
<li> <a target="_blank" href="https://web.archive.org/web/20210307133640/https://jpn.nec.com/info-square/mitatv/discover/01_sequel/index.html">海底ケーブルの秘密に迫る</a> (NEC)
</ul>

<h4>伝書鳩</h4>
<p>
どうにかして 0と1 さえ送れれば、電気を使わなくてもかまわない:
<a target="_blank" href="https://web.archive.org/web/20160305114607/http://www.blug.linux.no/rfc1149/">http://www.blug.linux.no/rfc1149/</a>
</p>

<h3 id="internet-ip">1.4. IP層 (ネットワーク層)</h3>
<P>
IP (Internet Protocol) 層の役割は、
データリンク層の機能を使って、
複数のホストを経由して離れたホストに<u>パケット</u>を送ることである。
</P>

<ul>
<li> 長所: 遠隔地のホストに情報を送れる。
<li> 短所1: 1度に送れる情報は短いパケットだけ。
<li> 短所2: パケットが正しく届けられる保証はない。
</ul>

<p>
インターネット上のある「地点」とは、
<u>IPアドレス</u> によって表現される。
これは物理的な場所とは何の関係もない。
IPアドレスは、4つの 8ビットの数で表す = 全世界で 8×4 = 32ビット。
</p>

<h4>IPアドレスの例</h4>
<ul>
<li> <code>127.0.0.1</code>
<li> <code>58.158.55.222</code>
<li> <code>255.255.255.255</code>
</ul>

<h4>ルータ</h4>
<p>
IPパケットは、複数台のコンピュータを経由して転送される。
このようなIPパケットを中継するコンピュータを
<u>ルータ</u> (router) とよぶ。
ルータは受けとったパケットをいったんメモリに保管し、
適切な送り先に向けて送信する。
</p>

<h3 id="internet-tcp">1.5. TCP層 (トランスポート層)</h3>
<p>
TCP (Transmission Control Protocol) 層は、
IP層の機能を使って、
送られてきたパケットをうまくつなぎ合わせて、長い 0/1 の列を送る。
この機能を<u>仮想回線</u> (virtual circuit) という。
</p>
<ul>
<li> 長所1: 長い情報を遠隔地のホストに送れる。
<li> 長所2: 途中で紛失したパケットは自動的に再送される。
<li> 短所: 0/1 の列は送れるが、それ自体には意味がない。
</ul>

<p>
パケットは途中で失われたり、二度届いたりする。
TCP 層は途中で失われたパケットを再度、送ってもらうよう要求する。
ここまでくると、インターネット上のあるコンピュータから別のコンピュータに
「任意の長さの 0 と 1 の列」を送れるようになる。
しかし、それをどう使うかはまだ決まっていない。
</p>

<h3 id="internet-application">1.6. アプリケーション層</h3>
<p>
最後にアプリケーション層が、
TCP層の機能を使って、
0/1 の列を実際に意味がある方法で使う。
例: ブラウザ、LINE、ゲームなど。
</p>
<ul>
<li> 長所: 最終的にユーザにとって意味のある「インターネット」になる。
<li> 短所: 悪意あるルータがパケットを盗聴・なりすましをしてもわからない。
</ul>


<h2 id="datalink">2. データリンク層のしくみ</h2>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" fill="#88ff88" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>
<p>
過去には、FDDI や Token Ring など、いろいろな方式があった。
現在ではおもに <u>イーサネット</u> (Ethernet) が使われている。
これは各機器を (概念的には) 単一の共通線でつなぎ、各機器が
<u>ブロードキャスト</u>によって通信するものである。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="400" height="80">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="10" y="10" />
      <use xlink:href="#computer" x="100" y="10" />
      <use xlink:href="#computer" x="190" y="10" />
      <use xlink:href="#computer" x="280" y="10" />
      <line x1="0" y1="5" x2="350" y2="5" />
      <line x1="35" y1="5" x2="35" y2="15" />
      <line x1="125" y1="5" x2="125" y2="15" />
      <line x1="215" y1="5" x2="215" y2="15" />
      <line x1="305" y1="5" x2="305" y2="15" />
    </g>
    <text x="350" y="40">ノード</text>
    <g style="font-size: 50%;">
      <g text-anchor="middle">
	<text x="35" y="70">aa-bb-cc-dd-ee-ff</text>
	<text x="125" y="70">11-22-33-44-55-66</text>
	<text x="215" y="70">a1-b2-c3-d4-e5-f6</text>
	<text x="305" y="70">6f-5e-4d-3c-b2-1a</text>
      </g>
    </g>
  </svg>
</div>

<h3 id="datalink-macaddr">2.1. 物理アドレス (MACアドレス)</h3>
<p>
Ethernet では、接続されている各機器はホストではなく
「<u>ノード</u>」
と呼ぶ。各機器には固有の物理アドレス
(あるいは <u>MACアドレス</u>) がついており、
これは製造時に決まっている。
MACアドレスは 48ビット (8ビット×6) で、これは
<code>08-00-27-16-f3-c3</code> のように 6組の 16進数で表される。
</p>

<div class=exercise id="ex-mac-addr">
<div class=header>演習. MACアドレスを調べる</div>
<p>
自分のパソコンについている Ethernet の MAC アドレスを調べよ。
(複数のインターフェイスが接続されている場合、MAC アドレスは複数存在することがある。)
</div>

<h3 id="datalink-duplex">2.2. 通信方式</h3>
<p>
Ethernet ではおもに 2つの通信方式がある:
</p>
<ul>
<li> 半二重 (Half-duplex) … 共有のケーブルを使った通信。
<li> 全二重 (Full-duplex) … 1対1の通信 (現在の主流)。
</ul>
<p>
1本のケーブルを複数のノードで共有している場合は、
ブロードキャストが基本である。
</p>

<h4>Ethernetのルール (半二重)</h4>
<ol>
<li> 喋りたいときに「あの〜」と言う。
<li> 他の誰か喋ってたら、喋るのをやめてしばらく待つ。
</ol>

<h4>Ethernetのルール (全二重)</h4>
<ol>
<li> 喋りたいときに喋り、そのまま喋り続けてよい。
<li> 通信は <u>スイッチング・ハブ</u> (switching hub)
または単に <u>スイッチ</u> あるいは <u>ハブ</u>
と呼ばれる機器で中継される。
</ol>

<div class=notice>
注意:
中継器はホストではない。
これ自体はMACアドレスを持っていないし、通信もできない。
</div>

<h3 id="datalink-frame">2.3. Ethernetフレーム</h3>
<p>
Ethernet を使って別のノードにデータを送るときは、
以下のような順序で 0 と 1 を送ることになっている。
このような決まりを<u>プロトコル</u> (Protocol, 規約) という。
なぜか Ethernet では「パケット」ではなく
<u>フレーム</u> (frame) と呼ばれている。
通常、Ethernet で一度に送れるフレームは最高 1500バイトまてである。
</p>

<h4>Ethernet フレームの構造</h4>
<table border>
<tr>
<td class=bits>10101010</td>
<td>…</td>
<td class=bits>10101011</td>
<td class=bgb>送信先アドレス<br>(6バイト)</td>
<td class=bgy>送信元アドレス<br>(6バイト)</td>
<td>データ長<br>(2バイト)</td>
<td class=bgr>実際のデータ<br>(46〜1500バイト)</td>
<td class=bgg>CRC<br>(4バイト)</td>
<td class=bits>00000000</td>
</tr>
</table>

<ol>
<li> 最初の 010101... (56回) が以後のクロックの代わりになる。
<li> <span class=bgb>送信先アドレス</span> は MAC アドレスである
(例. <code>aa-bb-cc-dd-ee-ff</code> など)。
<li> <span class=bgy>送信元アドレス</span> は MAC アドレスである
(例. <code>01-02-03-04-05-06</code> など)。
<li> その後、データの長さを 2バイト (=16 ビット) で送る。
(実際にはデータの長さが直接指定される場合と、
「パケットの種類」を指定する場合がある。)
<li> その後、<span class=bgr>実際のデータ</span> を送る。
<li> 最後に、エラー検査のための <span class=bgg>CRC</span> を送る。
</ol>
</div>

<div class=exercise id="ex-ethernet-frame">
<div class=header>演習. Ethernetフレームの中身</div>
<p>以下の Ethernet フレームについて問いに答えよ:</p>
<blockquote><pre>
06 e6 76 53 06 c8 04 e6 76 53 06 c8 00 05 11 22 33 44 55 aa bb cc dd
</pre></blockquote>
  <ol type=a>
    <li> 送信元MACアドレスは何か?
    <li> 送信先MACアドレスは何か?
    <li> 実際のデータは何バイトか?
    <li> そのデータは何か?
    <li> CRCの値は何か?
  </ol>
</div>

<div class=exercise id="ex-eithernet-wireshark">
<div class=header>演習. Wireshark を使って Ethernet フレームの詳細を確認する</div>
<p>
<a target="_blank" href="https://www.wireshark.org/">Wireshark</a> を起動後にパケットキャプチャーを開始し、
各パケットの詳細パネルをクリックして Ethernet の送信元・送信先MACアドレスを確認せよ。
</p>
<div class=figure>
<img src="wireshark.png" width="700" height="464">
</div>
</div>

<h2 id="ip">3. IP層 (ネットワーク層) のしくみ</h2>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" fill="#88ff88" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>
<p>
データリンク層 (Ethernet) の機能を使うと、
データを (1500 バイト以下ならば) 信頼できる方法で
隣のホストに送信できることがわかった。
Ethernet では基本的にどんなデータを送ってもよいが、
たいていは以下で説明する
<u>IPパケット</u> の内容が送られている。
</p>

<table border>
<tr>
<td class=bits>10101010</td>
<td>…</td>
<td class=bits>10101011</td>
<td>送信元アドレス</td>
<td>送信先アドレス</td>
<td>データ
長</td>
<td class=bgr>IPパケット</td>
<td>CRC</td>
<td class=bits>00000000</td>
</tr>
</table>

<p>
データリンク層の機能を使って IP パケットの 0/1 を受けとったら、
つぎにこれを次々に隣のホストに転送していくのが IP層 (ネットワーク層) の
役割である。
</p>

<h3 id="ip-addr">3.1. IPアドレス</h3>
<p>
IP アドレスは 32ビットで表現する。
これはふつう 4つの8ビット数 (0〜255) の組として表記する。
</p>
<ul>
<li> <code>127.0.0.1</code>
<li> <code>58.158.55.222</code>
<li> <code>255.255.255.255</code>
<li> <code>343.45.687.90</code> (間違い)
</ul>

<div class=notice>
注意:
MACアドレスが通常ホストごとに固有なのに対して、
IPアドレスは変化する。
</div>

<div class=exercise id="ex-ip-addr">
<div class=header>演習. 自分のIPアドレスを調べる</div>
<p>
自分のパソコンについている IP アドレスを調べよ。
(複数のデータリンク層が存在する場合、
ひとつのホストに複数の IP アドレスが存在することがある。)
</p>
</div>

<div class=exercise id="ex-ping">
<div class=header>演習. ping コマンドを使う</div>
<p>
<code>ping</code> コマンドは、与えられた IP アドレスの
ホストが起動しているか (IP パケットに応答できるか) 否かを調べるものである。
以下のホストに <code>ping</code> コマンドを実行して、
応答があるかどうかを確認せよ:
</p>
<blockquote><pre>
C:\&gt; <strong>ping <em>自分のIPアドレス</em></strong>
C:\&gt; <strong>ping 127.0.0.1</strong>
C:\&gt; <strong>ping 192.0.2.1</strong>
C:\&gt; <strong>ping 1.1.1.1</strong>
</pre></blockquote>
</div>

<h3 id="ip-packet">3.2. IPパケット</h3>

<h4>IP パケットの構造:</h4>
<table border>
<tr>
<th></th>
<th style="width:8em;">0</th>
<th style="width:8em;">1</th>
<th style="width:8em;">2</th>
<th style="width:8em;">3</th>
</tr>
<tr>
<th>0</th>
<td align=center>バージョン/ヘッダ長</td>
<td align=center>タイプ</td>
<td align=center colspan="2">パケット長</td>
</tr>
<tr>
<th>4</th>
<td align=center colspan="2">識別子</td>
<td align=center colspan="2">フラグ</td>
</tr>
<tr>
<th>8</th>
<td align=center>TTL</td>
<td align=center>プロトコル番号</td>
<td align=center colspan="2">チェックサム</td>
</tr>
<tr>
<th>12</th>
<td align=center colspan="4">送信元アドレス</td>
</tr>
<tr>
<th>16</th>
<td align=center colspan="4">送信先アドレス</td>
</tr>
<tr>
<th>20</th>
<td align=center colspan="3">オプション</td>
<td align=center>パディング</td>
</tr>
<tr>
<th>24</th>
<td align=center colspan="4">実際のデータ<br>…</td>
</tr>
</table>
</div>

<p>
各IPパケットにはデータ以外の余分な情報 (宛先など) がついている。
これを <u>IPヘッダ</u> という。
ヘッダは毎回かならず一定の大きさであり、すべてのパケットに含まれる。
</p>

<div class=exercise id="ex-ip-packet">
<div class=header>演習. IPパケットの中身</div>
<p>
以下は Ethernet 上で送られるフレームに含まれる
IPパケットの実際のデータを表したものである (<span class=bgy>黄色部分</span>)。
<a href="#ip-packet">上の図</a>を参考にして、以下の情報を求めよ:
</p>
<blockquote><pre>
0000 94 09 37 28 5b d5 00 23 81 1a f2 8d 08 00 <span class=bgy>45 00
0010 00 34 6b 7f 40 00 80 06 00 00 c0 a8 00 0c c0 a8
0020 01 01 c9 34 00 17 25 d0 1e c0 00 00 00 00 80 02
0030 20 00 82 84 00 00 02 04 05 b4 01 03 03 08 01 01
0040 04 02</span>
</pre></blockquote>
<ol type=a>
<li> 送信元の IPアドレス
<li> 送信先の IPアドレス
<li> IP パケットの大きさ (バイト数)
</ol>
</div>

<div class=exercise id="ex-ip-wireshark">
<div class=header>演習. Wireshark を使って IPパケットの中身を観察する</div>
<p>
Wireshark を起動後、パケットキャプチャーを開始し、
フィルタバーに <code>ip</code> と入力せよ。
各パケットをクリックして送信元・送信先のIPアドレスを確認せよ。
</p>
</div>

<h3 id="ip-routing">3.3. ルーティング</h3>
<p>
IPパケットは、複数台のコンピュータを経由して転送される。
このようなIPパケットを転送するコンピュータを「ルータ (router)」とよぶ。
(注意: 米国英語では "route" / "router" はどちらかというと
「ラウト」「ラウター」に近い発音だが、ここでは日本語の慣例にならって
「ルート」「ルーティング」と表記する。)
</p>
<p>
ルータは受けとったパケットをいったんメモリに保管し、
適切な送り先に向けて送信する。
</p>
<ul>
<li> 家庭用のルータ (1つの回線からくるパケットを複数台のPCに転送する)
<li> 業務用ルータ (複数の回線とつなぐ、ISPなどで使われる)<br>
たとえば
<a target="_blank" href="https://www.cisco.com/c/en/us/products/routers/8000-series-routers/index.html">Cisco 8000</a>
など。(10Tbps〜200Tbps)
</ul>
<p>
MACアドレスは各機器に固有なのに対して、
IPアドレスはそのホストが「勝手に名乗っているだけ」である。
つまり、世界中のどこにいるかわからないホストに対して、
ルータはIPパケットを正確に転送しなければならない。
しかも、コンピュータから見ると、インターネットの
世界の正確な全体像はわからない。
</p>
<div class=nop>
<ul>
<li> <a target="_blank" href="https://personalpages.manchester.ac.uk/staff/m.dodge/cybergeography/atlas/topology.html">Atlas of Cyberspaces</a>
<li> <a target="_blank" href="https://www.opte.org/the-internet">The Internet 1997 - 2021</a>
</ul>
</div>

<h3 id="ip-cidr">3.4. CIDR 方式</h3>
<p>
小さな組織 (自宅・会社・学校) で、ネットワークが
階層構造 (ツリー構造) になっているときに使える方法。
</p>
<p>
各ホストは、<u>ルーティングテーブル</u>と呼ばれる情報を持っている。
ここには以下のことがあらかじめ記載 (設定) されている:
</p>
<ul>
<li> 「送り先がこの範囲の IPアドレスなら、この Ethernet に送るべし」
<li> 「送り先がそれ以外なら、この特定のホストに送るべし」
</ul>
<p>
ある範囲の IPアドレスのことを、
サブネットワークまたは <u>サブネット</u> (subnet) という。
</p>

<h4>末端の (ルータでない) ホストの場合:</h4>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="350" height="120">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="60" y="0" />
      <use xlink:href="#computer" x="10" y="60" />
      <use xlink:href="#computer" x="100" y="60" />
      <use xlink:href="#computer" x="190" y="60" />
      <line x1="0" y1="55" x2="260" y2="55" />
      <line x1="35" y1="65" x2="35" y2="55" />
      <line x1="125" y1="65" x2="125" y2="55" />
      <line x1="215" y1="65" x2="215" y2="55" />
      <line x1="85" y1="45" x2="85" y2="55" />
    </g>
    <g style="font-size: 80%;">
      <text x="110" y="20">ルータ</text>
      <text x="110" y="40">192.168.1.1</text>
      <text x="270" y="60">192.168.1.0</text>
      <text x="250" y="90">ホスト</text>
      <g text-anchor="middle">
	<text x="35" y="120">192.168.1.2</text>
	<text x="125" y="120">192.168.1.3</text>
	<text x="215" y="120">192.168.1.4</text>
      </g>
    </g>
  </svg>
</div>

<p>
末端のホストは、ひとつのサブネットに接続している。
これは次のような方法でIPパケットを転送する:
</p>
<ul>
<li> もし、送り先のIPアドレスが自分と同じサブネット上にある場合は、
そのまま Ethernet に送る。
<li> 送り先のIPアドレスがそれ以外の場合は、
<u>デフォルト ゲートウェイ</u> に送る。
</ul>

<div class=figure>
<img src="netcpl.png" width="482" height="279">
</div>

<h4>ルータの場合:</h4>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="350" height="120">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="40" y="-5" />
      <use xlink:href="#computer" x="120" y="60" />
      <line x1="0" y1="115" x2="260" y2="115" />
      <line x1="0" y1="50" x2="260" y2="50" />
      <line x1="145" y1="105" x2="145" y2="115" />
      <line x1="145" y1="65" x2="145" y2="50" />
      <line x1="65" y1="40" x2="65" y2="50" />
    </g>
    <g style="font-size: 80%;">
      <text x="125" y="90" text-anchor="end">ルータ</text>
      <text x="170" y="100">192.168.1.1</text>
      <text x="170" y="80">192.168.2.2</text>
      <text x="270" y="120">192.168.1.0</text>
      <text x="270" y="50">192.168.2.0</text>
      <text x="45" y="20" text-anchor="end">ルータ</text>
      <text x="90" y="15">10.0.1.2</text>
      <text x="90" y="35">192.168.2.1</text>
    </g>
  </svg>
</div>

<p>
ルータは、少なくとも<strong>2つのIPアドレス</strong>を持っており、
2つ以上のサブネットに接続している。
これは次のような方法でIPパケットを転送する:
</p>
<ul>
<li> もし、送り先のIPアドレスが自分に接続されているサブネットの
どれかにある場合は、その Ethernet に送る。
<li> それ以外の場合は、<u>デフォルト ゲートウェイ</u> に送る。
</ul>

<!--
<h4>Ethernet のブロードキャストと ARP</h4>
<p>
Ethernet の送信先アドレスとして、
<code>ff-ff-ff-ff-ff-ff</code> という MAC アドレスを使うと、
ハブにつながっているすべてのノードに対して送信したことになる
(ブロードキャスト)。
Ethernet 上の各ノードは、
一定時間ごとに、ARP (Address Resolution Protocol) と呼ばれるパケットを
Ethernet の全ノード対して送る。ここには、そのノードの MAC アドレスと、
そのコンピュータの IP アドレスが含まれており、各ホストは
その情報を覚えておいて IP パケット送信時に使う。
</p>
-->

<h4>サブネット・マスクとネットワーク・アドレス</h4>
<p>
あるIPアドレスが特定の「サブネット」に所属しているかどうかは、
以下のようにして決定する:
</p>
<ol>
<li> そのIPアドレスを 32ビットの 2進数表記にする。
<li> <u>サブネット・マスク</u>
 (subnet mask あるいは netmask) の 32ビット値と AND をとる。<br>
  (つまり、マスクが 0 になっている部分のビットを無視する)
<li> 残ったアドレスがその IPアドレスの
  <u>ネットワーク・アドレス</u> (network address) である。
  これがそのサブネットのアドレスに等しければ、
  その IP アドレスはサブネットに属する。
</ol>

<table border><tr>
<th>IP アドレス</th>
<td><code>11110000 10101000 00000001 00000010</code></td>
<td>(192.168.1.2)</td>
</tr><tr>
<th>サブネット・マスク</th>
<td><code>11111111 11111111 11111111 00000000</code></td>
<td>(255.255.255.0)</td>
</tr><tr>
<th>ネットワーク・アドレス</th>
<td><code>11110000 10101100 00000001 00000000</code></td>
<td>(192.168.1.0)</td>
</tr></table>

<p>
サブネット・マスクは基本的には IP アドレスと同様に4組の 10進数で表す。
しかし、基本的には「1の部分」と「0の部分」だけなので、
ただ単に 1の個数を「<code>/24</code>」のように表すことも多い。
</p>
<ul>
<li> 表記1 … <code>255.255.255.0</code>
<li> 表記2 … <code>/24</code>
</ul>

<div class=formula>
基本的には、IPアドレスの先頭部分がネットワーク・アドレスである。
</div>

<div class=exercise id="ex-network-addr">
<div class=header>演習. ネットワークアドレスを求める</div>
<p>
以下の IP アドレスに対するネットワークアドレスを求めよ:
</p>
<ol type=a>
<li> <code>10.0.1.3/8</code>
<li> <code>128.122.100.181/16 (255.255.0.0)</code>
<li> <code>192.168.1.9/24 (255.255.255.0)</code>
<li> <code>166.84.7.55/30 (255.255.255.252)</code>
</ol>
</div>

<div class=exercise id="ex-routing">
<div class=header>演習. ルーティングテーブルの実装</div>
<p>
あるルータが以下のIPアドレスをもっている。
これらは2つのサブネットに接続しており、
そのうちのひとつはデフォルト・ゲートウェイである。
</p>
<ul>
<li> IPアドレス1 : <code>10.0.2.2/16</code> (サブネットA)
<li> IPアドレス2 : <code>192.168.3.1/24</code> (サブネットB)
<li> デフォルト・ゲートウェイ : <code>10.0.2.1</code>
</ul>
<p>
以下のIPパケットが来た場合、ルータはパケットを
どのように転送すればよいか?
</p>
<ol type=a>
<li> 送信元: <code>10.0.3.4</code> → 送信先: <code>192.168.3.2</code>
<li> 送信元: <code>192.168.3.3</code> → 送信先: <code>10.0.3.1</code>
<li> 送信元: <code>192.168.3.3</code> → 送信先: <code>10.1.3.1</code>
</ol>
</div>

<h3 id="ip-wan">3.5. 広域レベルでのルーティング</h3>
<p>
ネットワークがさらに複雑な場合は、
各ルータが「このネットワークはこっち」という<u>経路情報</u>
(ルーティング情報) をたえず交換している。
ちなみに、この情報もまた TCP/IP を使って送られる。
おもに 2つの方式がある:
</p>
<ul>
<li> リンク・ステート方式 (Link state routing)
<li> 経路ベクトル方式 (Path vector routing)
</ul>

<h4>リンク・ステート方式</h4>
<p>
中規模の組織で利用される。各ルータは、ネットワーク上のホストが
どのように接続されているか定期的に調査し、ネットワークの「地図」を作成する。
ここから各ホスト間の最短経路を計算する。
</p>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="220" height="220">
<g transform="translate(10,10)">
<g fill="none" stroke="black" stroke-width="2">
 <line x1="153" y1="144" x2="149" y2="37" />
 <line x1="153" y1="144" x2="76" y2="171" />
 <line x1="85" y1="71" x2="76" y2="171" />
 <line x1="153" y1="144" x2="85" y2="71" />
 <line x1="190" y1="190" x2="149" y2="37" />
 <line x1="10" y1="10" x2="34" y2="50" />
 <line x1="76" y1="171" x2="34" y2="50" />
 <line x1="190" y1="190" x2="153" y2="144" />
 <line x1="190" y1="190" x2="76" y2="171" />
 <line x1="10" y1="10" x2="22" y2="105" />
 <line x1="149" y1="37" x2="34" y2="50" />
 <line x1="10" y1="10" x2="149" y2="37" />
 <line x1="85" y1="71" x2="34" y2="50" />
</g>
<g fill="white" stroke="black">
 <circle cx="10" cy="10" r="4" />
 <circle cx="22" cy="105" r="4" />
 <circle cx="34" cy="50" r="4" />
 <circle cx="76" cy="171" r="4" />
 <circle cx="85" cy="71" r="4" />
 <circle cx="149" cy="37" r="4" />
 <circle cx="153" cy="144" r="4" />
 <circle cx="190" cy="190" r="4" />
</g>
<g text-anchor="middle">
<g fill="blue" style="font-weight:bold;">
<text x="0" y="10">A</text>
<text x="20" y="125">B</text>
<text x="30" y="70">C</text>
<text x="70" y="190">D</text>
<text x="85" y="65">E</text>
<text x="160" y="30">F</text>
<text x="135" y="145">G</text>
<text x="200" y="200">Z</text>
</g>
<text x="10" y="67">4</text>
<text x="25" y="30">2</text>
<text x="45" y="105">8</text>
<text x="59" y="65">2</text>
<text x="75" y="121">5</text>
<text x="79" y="23">7</text>
<text x="91" y="43">4</text>
<text x="119" y="100">4</text>
<text x="114" y="157">4</text>
<text x="133" y="178">3</text>
<text x="145" y="90">5</text>
<text x="173" y="165">5</text>
<text x="175" y="113">7</text>
</g>
</g>
</svg>
</div>

<h4>経路ベクトル方式</h4>
<p>
さらに大規模なルーティングに使われる方式。
インターネットを各自律システム (<u>Autonomous System</u>, AS) に分け、
AS 間での経路情報を交換する。世界には約5万のASがあり、相互に協力している。
</p>

<ul class=nop>
<li> <a target="_blank" href="https://en.wikipedia.org/wiki/File:SRI_First_Internetworked_Connection_diagram.jpg">初期のインターネットの構造</a>
<li> <a target="_blank" href="http://www.topology-zoo.org/explore.html">各ASの物理的な配線</a>
<li> <a target="_blank" href="https://www.cidr-report.org/as2.0/">全世界におけるAS情報</a>
<li> <a target="_blank" href="https://atlas.ripe.net/results/maps/">RIPE Atlas</a>
</ul>

<p>
各ASは <u>BGP</u> (Border Gateway Protocol) という手順で
「このネットワークはこっち」という経路情報を交換している。
全世界の細かい地図を把握できるわけではなく、
「だいたいこっちの方に送れば正しいだろう」という程度の情報しかわからない。
</p>

<h4>大規模なルータに要求される性能</h4>
<ul>
 <li> 1Tbps = 毎秒100Gバイト消費。
 <li> 最高30秒間保持する = 3Tバイトのメモリが必要。
 <li> 1パケット 1000バイトとすると、毎秒 1Gパケット。
 <li> 毎秒1G回: 32ビットアドレスを照合 (32Gバイトのメモリ比較)。
 <li> 絶対に止まってはいけない。
</ul>
<p>
業務用ルータ1台は、通常のパソコン数百台分の性能をもっている。
アドレスの照合のために、TCAMという特別なメモリが使われている。
</p>

<div class=exercise id="ex-traceroute">
<div class=header>演習. 広域ルーティングの実際</div>
<p>
ニューヨークに存在する、とあるサーバの IP アドレスは 166.84.7.55 である。
<code>traceroute</code> コマンド (Windows の場合は、<code>tracert</code> コマンド) を使って、
ここに行くまでの経路を調べよ。
</p>
<p>macOS/Linuxの場合:</p>
<pre>
$ <strong>traceroute 166.84.7.55</strong>
</pre>
<p>Windowsの場合:</p>
<pre>
C:\&gt; <strong>tracert 166.84.7.55</strong>
</pre>
</div>


<h2 id="tcp">4. TCP層 (トランポート層) のしくみ</h2>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" fill="#88ff88" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>
<p>
IP層の機能を使うと、世界の離れた場所にパケットを送ることができる。
しかしこれはまだ信頼性がなく、長いデータも送れない。
そこで IPパケットをうまくつなぎ合わせて、長い 0/1 の列を送る仕組みを考える。
これが TCP 層の機能である。IPパケットの中には、そのための
TCPパケット (<u>TCPセグメント</u>) がさらに入っている。
</p>

<h4>TCP セグメントの構造:</h4>
<table border>
<tr>
<th></th>
<th style="width:8em;">0</th>
<th style="width:8em;">1</th>
<th style="width:8em;">2</th>
<th style="width:8em;">3</th>
</tr>
<tr>
<th>0</th>
<td align=center colspan="2">送り元ポート</td>
<td align=center colspan="2">送り先ポート</td>
</tr>
<tr>
<th>4</th>
<td align=center colspan="4">シーケンス番号</td>
</tr>
<tr>
<th>8</th>
<td align=center colspan="4">確認応答(ACK)番号</td>
</tr>
<tr>
<th>12</th>
<td align=center colspan="2">フラグ</td>
<td align=center colspan="2">ウィンドウサイズ</td>
</tr>
<tr>
<th>16</th>
<td align=center colspan="2">チェックサム</td>
<td align=center colspan="2">緊急ポインタ</td>
</tr>
<tr>
<th>20</th>
<td align=center colspan="4">オプション</td>
</tr>
<tr>
<th>24</th>
<td align=center colspan="4">実際のデータ<br>…</td>
</tr>
</table>
</div>

<p>
TCP 層では、<u>シーケンス番号</u>
(sequence number) により長いデータのセグメントを区別する。
さらに各通信は <u>送り元ポート番号</u> と
<u>送り先ポート番号</u> によって区別されており、
これらが違うセグメントは別々の通信とみなされる。
(ちなみに、IP層には「ポート番号」という概念はない。)
</p>

<div class=exercise id="ex-tcp-segment">
<div class=header>演習. TCP セグメントの中身</div>
<p>
上の IPパケットから TCP セグメントの部分
(<span class=bgy>緑色部分</span>) を抜き出し、
以下の情報を求めよ:
</p>
<blockquote><pre>
0000 94 09 37 28 5b d5 00 23 81 1a f2 8d 08 00 45 00
0010 00 34 6b 7f 40 00 80 06 00 00 c0 a8 00 0c c0 a8
0020 01 01 <span class=bgg>c9 34 00 17 25 d0 1e c0 00 00 00 00 80 02
0030 20 00 82 84 00 00 02 04 05 b4 01 03 03 08 01 01
0040 04 02</span>
</pre></blockquote>
<ol type=a>
<li> 送信元ポート
<li> 送信先ポート
<li> シーケンス番号
</ol>
</div>

<h3 id="tcp-details">4.1. TCPの詳細</h3>

<h4>TCP ACKパケット</h4>
<p>
TCP で通信をしていると、
実際には一方的にデータを受けとっているときでも
帰りのパケットが送られている。これが
TCP <u>ACK</u> パケット
(あるいは <u>確認応答</u> パケット) である。
</p>

<ul>
<li> 送り側のホストは、「ここまで送った」という
<u>シーケンス番号</u> (<u>seq</u>uence number)
をつけてパケットを送る。
<li> 受け側のホストは、「ここまで受けとった」という
<u>確認応答番号</u> (<u>ack</u>nowledge number)
をつけたパケットを返す。
<table border>
<tr>
<th></th>
<th style="width:4em;">0</th>
<th style="width:4em;">1</th>
<th style="width:4em;">2</th>
<th style="width:4em;">3</th>
</tr>
<tr>
<th>4</th>
<td class=bgg align=center colspan="4">シーケンス番号</td>
</tr>
<tr>
<th>8</th>
<td class=bgg align=center colspan="4">確認応答(ACK)番号</td>
</tr>
</table>
<li> しばらくの間、確認応答パケットが来なかったら、
  送り側は届かなかったパケットをまた送り直す。
</ul>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="350" height="88">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="0" />
      <use xlink:href="#computer" x="300" y="0" />
      <line x1="60" y1="32" x2="290" y2="32" />
      <rect x="100" y="2" width="30" height="20" />
      <rect x="150" y="2" width="30" height="20" />
      <rect x="200" y="2" width="30" height="20" stroke-dasharray="2,2" />
      <rect x="250" y="2" width="30" height="20" />
      <rect x="180" y="42" width="30" height="20" />
      <rect x="130" y="62" width="30" height="20" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="90" x2="70" y1="12" y2="12" />
        <line x1="220" x2="240" y1="52" y2="52" />
        <line x1="170" x2="190" y1="72" y2="72" />
      </g>
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="115" y="12" dy="0.5em">1</text>
      <text x="165" y="12" dy="0.5em">8</text>
      <text x="215" y="12" dy="0.5em">13</text>
      <text x="265" y="12" dy="0.5em">29</text>
      <text x="195" y="52" dy="0.5em">1</text>
      <text x="145" y="72" dy="0.5em">8</text>
    </g>
  </svg>
</div>

<p>
実際には、TCPの通信では双方向にパケットが送られる。
</p>
<table border>
<tr><td>seq=<u>1</u>, ack=1, (10バイト) →</td><td></td></tr>
<tr><td></td><td>← seq=1, ack=<u>11</u>, (5バイト)</td></tr>
<tr><td>seq=<u>11</u>, ack=<u>6</u>, (0バイト) →</td><td></td></tr>
<tr><td></td><td>← seq=<u>6</u>, ack=<u>11</u>, (3バイト)</td></tr>
<tr><td>seq=<u>11</u>, ack=<u>9</u>, (1バイト) →</td><td></td></tr>
<tr><td></td><td>← seq=<u>9</u>, ack=<u>12</u>, (0バイト)</td></tr>
</table>

<h4>TCP SYN パケットとハンドシェイク</h4>
<p>
実際の長いデータには、始まりと終わりがある。
TCP セグメントには、データの「始まり」を示す
特別なパケット (SYNパケット) がある。
これは TCP セグメントの「フラグ」部分にある
「SYN」ビットを 1 にしたパケットを使う。
</p>
<table border>
<tr>
<th></th>
<th style="width:4em;">0</th>
<th style="width:4em;">1</th>
<th style="width:4em;">2</th>
<th style="width:4em;">3</th>
</tr>
<tr>
<th>12</th>
<td align=center class=bgg colspan="2">フラグ</td>
<td align=center colspan="2">ウィンドウサイズ</td>
</tr>
</table>

<p>
実際のTCP通信は、以下のようにして開始する。
この処理を <a target="_blank" href="https://ja.wikipedia.org/wiki/3%E3%82%A6%E3%82%A7%E3%82%A4%E3%83%BB%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF">3ウェイ・ハンドシェイク</a> という。
</p>
<ol>
<li> 送り側が TCP SYN パケットを送る。
<li> 受け側が TCP SYN+ACK パケットを送る。
<li> 送り側が TCP ACK パケットを送る。
<li> 送り側、受け側ともに seq=1, ack=1 で通信を始める。
</ol>

<div class=notice>
注意: ここでいう「ACKフラグ」は、
各セグメントに含まれる確認応答(ACK)番号とは別である。
</div>

<h3 id="tcp-client-server">4.2. 「クライアント」と「サーバ」</h3>
<p>
IP層においては、すべてのホストはパケットを送受信するという役割は同じであった。
しかし TCP層の通信では、2種類の役割が必ず存在する。
<u>クライアント</u> (電話をかける側) と<u>サーバ</u> (電話をかけられる側) である。
TCP ハンドシェイクが行われるときには、必ず最初に
TCPクライアント のTCPポートから
TCPサーバ のTCPポートに対して
TCP SYN パケットが送られる。
</p>
<ul>
<li> TCPクライアント …
  客。いつサーバを呼び出してもよいし、呼び出さなくてもよい。
<li> TCPサーバ …
  店。いつクライアントに呼ばれてもいいように 24時間待機していなければならない。
</ul>

<p>
TCPクライアントとTCPサーバはどう違うのか?
TCPサーバとは特定のTCPポートを
<u>Listen</u> (待ち受け) 状態にしている
ホスト (プロセス) のことである。
</p>

<h4>TCPサーバ側の手順:</h4>
<ol>
<li> そのホスト上の特定のTCPポート (たとえば80番) を Listen状態にする。
  (同一ホスト上の別のプログラムがすでに同じポートを使っているときは、
  そのポートはListenできない)
<li> TCPクライアントがそのポートに対して TCP SYN パケットを送ってくるのを待つ。
<li> TCP SYN パケットが送られてきたら TCP SYN+ACKパケットを返し、
  TCPハンドシェイクを開始する。
  ハンドシェイクが成功すると、そのポートは
  <u>Established</u> (確立) 状態になる。
<li> 以後、TCP RST パケットが送られてくるまでそのクライアントと双方向で通信する。
</ol>

<h4>TCPクライアント側の手順</h4>
<ol>
<li> 通信したいサーバの IPアドレス と TCPポート番号 を選ぶ。
  (クライアント側のTCPポート番号は適当に選ばれる)
<li> そのサーバの特定の TCPポートに向けて TCP SYN パケットを送り、
  TCPハンドシェイクをおこなう。
  ハンドシェイクが成功すると、そのポートは Established (確立) 状態になる。
<li> 以後、サーバと双方向で通信する。
  通信を終了したい場合は TCP RST パケットを送る。
<li> もし間違った IPアドレスや TCPポート番号が指定された場合、
  その通信は<u>タイムアウト</u>するか、あるいは接続拒否 (<u>Rejected</u>)
  エラーが返される。
</ol>

<div class=exercise id="ex-tcp-connection">
<div class=header>演習. TCP で通信する</div>
<ol>
<li> まず、サーバ側の PC とクライアント側の PC を用意する
(どちらも仮想マシンでよい)。
<li> サーバ側PCで、以下のコマンドを実行する:
<blockquote><pre>
$ <strong>nc -l -p 10000</strong>
</pre></blockquote>
<li> クライアント側PCで、以下のコマンドを実行する:
<blockquote><pre>
$ <strong>nc <em>サーバIPアドレス</em> 10000</strong>
</pre></blockquote>
<li> サーバ・クライアント側ともに何らかのテキストを入力し、
相手の端末にそれが送信されていることを確認せよ。
</ol>
</div>

<p>
TCPクライアントとサーバが双方向で通信可能な状態になっている状態を
<u>TCP接続</u> (connection) という。
ひとつのTCP接続では、次のものが決まっている:
</p>
<ul>
<li> クライアント側のIPアドレス
<li> サーバ側のIPアドレス
<li> クライアント側のTCPポート
<li> サーバ側のTCPポート
</ul>

<p>
1台のサーバは、複数のTCPポートを Listen状態にすることができる。
また、1台のクライアントは、複数のTCPサーバに同時に接続することができる。
<code>netstat</code>コマンドを実行すると、現在その PC上で
Listen/Established状態になっている TCPポート一覧を見ることができる。
</p>

<div class=exercise id="ex-netstat">
<div class=header>演習. TCP 接続の状態を確認する</div>
<p>
<a href="#ex-tcp-connection">上の演習</a> を実行中に、
サーバ・クライアントの両方で別のウィンドウを開き、
以下のコマンドを実行せよ。
</p>
<blockquote><pre>
$ <strong>netstat -n -t</strong>
</pre></blockquote>
現在通信中のポートが表示されていることを確認せよ。
</div>

<div class=exercise id="ex-tcp-wireshark">
<div class=header>演習. Wireshark を使って TCPハンドシェイクを観察する</div>
<p>
Wireshark を起動後、パケットキャプチャーを開始し、
フィルタバーに <code>ip.addr == 93.184.216.34</code> と入力せよ。
ブラウザで <a target="_blank" href="https://www.example.com/">https://www.example.com/</a> を開き、
TCP の 3ウェイハンドシェイクが行われていることを確認せよ。
</p>
</div>

<h4>TCP/IP プログラミング</h4>
<p>
一般的に、インターネットを使った通信をプログラムによって実装するとき、
もっともよく使うのは TCP層の機能である。
現在の UNIXでは「ソケット (socket)」という機構を使った API が整備されており、
たとえば Python なら、以下の簡単なスクリプトを使って
すぐにサーバ-クライアント間でバイト列が送受信できる:
</p>

<div class=file>
server.py (サーバ側):
<pre>
from socket import *
<em># TCP用ソケットを準備。</em>
sock = socket(AF_INET, SOCK_STREAM)
<em># TCPポート 10000番で listen状態にする。</em>
sock.bind(('0.0.0.0', 10000))
sock.listen(1)
<em># 接続してきたクライアント用のソケットを取得する。</em>
(client, addr) = sock.accept()
<em># データを受信する。</em>
data = client.recv(10)
print(data)
</pre></div>

<div class=file>
client.py (クライアント側):
<pre>
from socket import *
<em># TCP用ソケットを準備。</em>
sock = socket(AF_INET, SOCK_STREAM)
<em># ホスト 127.0.0.1 の TCPポート 10000番に接続する。</em>
sock.connect(('127.0.0.1', 10000))
<em># データを送信する。</em>
sock.send(b'hello')
</pre></div>

<div class=exercise id="ex-tcp-pytho">
<div class=header>演習. Python を使った TCPプログラミング</div>
<p>
上の 2つの Pythonスクリプト
<code>server.py</code>、<code>client.py</code> を
同一のホスト上で同時に動かし、通信ができていることを確認せよ。
</p>
</div>

<h3 id="tcp-udp">4.3. UDP層</h3>
<p>
TCP層は便利だが、いくつか欠点がある:
</p>
<ul>
<li> 最初のハンドエシェイクに時間がかかる。
<li> あるセグメントが届かなかったら、絶対に送り直さねばならない。
</ul>

<p>
これに対して、TCP層のかわりに
<u>UDP</u> (User Datagram Protocol)
層というものを使うこともできる。
これはIP層を使っているが、
TCPとは別の方法で通信をおこなう。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="60" height="30" fill="#ffaaff" />
      <rect x="60" y="30" width="60" height="30" fill="#aaffff" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="30" y="45" dy="0.5em">TCP層</text>
      <text x="90" y="45" dy="0.5em">UDP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<h4>UDPの用途</h4>
<ul>
<li> 動画の実況中継など、パケットを落とすよりもリアルタイム性が重要なもの。
<li> ゲームなど、速い反応が要求されるもの。
</ul>

<h4>UDPの欠点</h4>
<ul>
<li> 信頼性がない。(ロスしたらそれで終わり)
<li> 大きなデータは送れない。
</ul>

<h4>TCPパケットの場合</h4>
<table border>
<tr>
<th></th>
<th style="width:8em;">0</th>
<th style="width:8em;">1</th>
<th style="width:8em;">2</th>
<th style="width:8em;">3</th>
</tr>
<tr>
<th>8</th>
<td align=center>TTL</td>
<td class=bgg align=center>プロトコル番号 (6)</td>
<td align=center colspan="2">チェックサム</td>
</tr>
</table>
</div>

<h4>UDPパケットの場合</h4>
<table border>
<tr>
<th></th>
<th style="width:8em;">0</th>
<th style="width:8em;">1</th>
<th style="width:8em;">2</th>
<th style="width:8em;">3</th>
</tr>
<tr>
<th>8</th>
<td align=center>TTL</td>
<td class=bgg align=center>プロトコル番号 (17)</td>
<td align=center colspan="2">チェックサム</td>
</tr>
</table>
</div>


<h2 id="application">5. アプリケーション層</h2>
<p>
普通、TCP/IPのデータリンク層・IP層・TCP層はすべて OS が提供している。
アプリケーション層は、TCP層の機能を使って実際に人間に意味のある
情報を送受信するソフトウェアの部分である。一般の人が書く
プログラムのほとんどは、このアプリケーション層に位置している。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" fill="#88ff88" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<h3 id="app-dns">5.1. ドメイン名検索 (DNS)</h3>
<p>
IP アドレスはそのままでは人間にとって覚えにくいので、
実際には各ホストに名前 (文字列) をつけて、IPアドレスの代わりに
その文字列を使うことができる。この仕組みを
<nobr><span class=bl>ドメイン・ネーム・システム</span></nobr> (あるいは
<nobr><span class=bl>DNS</span></nobr>) といい、
各ホストにつけられた名前を<nobr><span class=bl>ホスト名</span></nobr> という。
たとえば、以下の2つは同じ意味である:
<blockquote><pre>
C:\&gt; <strong>ping 93.184.216.34</strong>
C:\&gt; <strong>ping www.example.com</strong>
</pre></blockquote>
</p>
<p>
DNS は TCP/IP の機能を使って、<code>www.example.com</code> などの
文字列から <code>93.184.216.34</code> などの IPアドレスを検索する
一種の分散データベースである。DNS を使ってホスト名から IPアドレスを得ることを
「ホスト名の解決 (resolution)」という。
</p>
<p>
なお DNSサーバは
「ホスト名 → IPアドレス」の解決 (<u>正引き</u>) だけでなく、
「IPアドレス → ホスト名」の解決 (<u>逆引き</u>) もサポートしている。
<code>ping</code> などで IPアドレスを指定したのに
名前が表示されるのはこのためである。
なお、ひとつの IPアドレスに複数の名前がついていることもある。
</p>

<h4>DNSのしくみ</h4>
<p>
DNS は以下のような機構になっている:
</p>
<ul>
<li> まず、インターネット上のすべてのホストを<u>ドメイン</u> (domain) という区切りに分ける。
  たとえば <code>www.example.com</code> というホスト名は
  <code>.com</code>ドメインと、
  <code>.example.com</code>ドメイン
  分割される。
<li> 各ドメインについて、そのドメイン内のホスト名について責任を負う
  <u>ネームサーバ</u> (name server) のIPアドレスを定める。
  たとえば <code>.com</code> ドメインのネームサーバは
  <code>192.5.6.30</code>
  である。
<li> 世界 13箇所に<a target="_blank" href="https://ja.wikipedia.org/wiki/%E3%83%AB%E3%83%BC%E3%83%88%E3%82%B5%E3%83%BC%E3%83%90">ルートネームサーバ</a> (root name server) をおく。
  このサーバは各トップレベルドメイン (<code>.com</code>など) の
  ネームサーバのIPアドレスを記憶している。
</ul>
<p>
このようなサーバを用意したあとで、各ホストは次のようにして
ホスト名の解決をおこなう:
</p>

<ol type=a>
<li> まず、すべてのホストは、13個のルートネームサーバの IPアドレスを知っている
  (たとえばルートサーバ A の IPアドレスは <code>198.41.0.4</code> など)。
  ホストは最初にルートサーバに対して、解決したいホスト名の
  最初のドメイン (トップレベルドメイン、TLD) の
  ネームサーバの IP アドレスを問い合わせる。
<li> つぎに、そのネームサーバに対して、それ以下のドメイン (サブドメイン) の
  ネームサーバの IP アドレスを問い合わせる。以下、繰り返し。
<li> 最後のネームサーバの IPアドレスが判明したら、それに対して
  目的のホスト名の IP アドレスを問い合わせる。完了。
</ol>

<h4>DNSの欠点</h4>
<p>
ネームサーバとの通信が正しくできないと、
IPアドレスがわからないので、そもそも通信ができなくなる。
また、ネームサーバが間違ったアドレスを返すと関係ないホストに対して
通信してしまう。そのためネームサーバはふつう複数個用意されていることが多く、
世界のルートサーバはどれも厳重に管理されている。
</p>

<h4>localhost</h4>
<p>
<nobr><span class=bl><code>127.0.0.1</code></span></nobr> は
特別な IPアドレスであり、これはつねに「自分自身のホスト」をあらわす。
これをループバックアドレスという。
なお、ホスト名 <nobr><span class=bl><code>localhost</code></span></nobr> は
つねにループバックアドレスに解決される。
</p>

<h4>DNS の動作例</h4>
<p>
ホスト <code>www.example.com</code> の IPアドレスを求める…
</p>
<ol>
<li> ルートサーバ (<code>198.41.0.4</code>) に
  <code>.com</code> ネームサーバのIPアドレスを問い合わせる →
  <code>192.5.6.30</code>
<li> <code>.com</code> ネームサーバに
  <code>.example.com</code> ネームサーバのIPアドレスを問い合わせる →
  <code>199.43.133.54</code>
<li> <code>.example.com</code> ネームサーバに
  <code>www.example.com</code> のIPアドレスを問い合わせる →
  <code>93.184.216.34</code>
<li> 完了。
</ol>

<p>
TCP/IPに対応している多くの API やプログラム
(<code>ping</code>, <code>traceroute</code>, <code>nc</code> など) では、
DNS はデフォルトで対応しており、これらの IPアドレスの指定欄には
代わりにホスト名を直接指定してもよい。
実際、DNS はインターネットの基幹をなすサービスであり、
ほとんどの API やアプリ、サービスなどが DNS に依存している。
そのため <strong>DNS がうまく動かない場合、
多くのサービスやサイトで大規模な障害が発生する</strong>。
</p>

<div class=exercise id="ex-nslookup">
<div class=header>演習. ホスト名から IP アドレスを求める</div>
<p>
<code>ping</code> コマンドを使って、
自分がよく知っているホスト名の IPアドレスを求めよ。
</p>
<blockquote><pre>
C:\&gt; <strong>ping <em>ホスト名</em></strong>
</pre></blockquote>
</div>

<h3 id="app-web">5.2. ウェブ (HTTP)</h3>

<h4>HTTP のしくみ</h4>
<p>
HTTP は、TCP 80番ポート (HTTPS の場合は TCP 443番ポート) を使った
もっとも有名なアプリケーション層である。
これは HTML (<u>H</u>yper <u>T</u>ext <u>M</u>arkup <u>L</u>anguage) 型式で
書かれたデータ (ようするに、Webページ) をブラウザに転送するという意味で
HTTP (<u>H</u>yper <u>T</u>ext <u>T</u>ransfer <u>P</u>rotocol)
と呼ばれる。
</p>

<ol>
<li> クライアントがコンテンツを要求する。(要求、<u>リクエスト</u>)
<li> サーバがコンテンツを提供する。(応答、<u>レスポンス</u>)
<li> 読み込むページ・画像ファイルの数だけ 1., 2. を繰り返す。
</ol>
<p>
通常、HTTP を使うクライアントを
<u>ウェブブラウザ</u> (HTTPクライアント) と呼び、
それに答えるサーバを
<u>ウェブサーバ</u> (HTTPサーバ) という。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="400" height="70">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="white" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use x="20" y="0" xlink:href="#computer" />
      <use x="320" y="0" xlink:href="#computer" />
      <path d="M70,20 l240,0" marker-end="url(#arrow)" />
      <path d="M310,30 l-240,0" marker-end="url(#arrow)" />
    </g>
    <g text-anchor="middle" style="font-size:80%;">
      <text x="45" y="60">クライアント</text>
      <text x="345" y="60">サーバ</text>
      <text x="110" y="12">リクエスト</text>
      <text x="270" y="48">レスポンス</text>
    </g>
  </svg>
</div>

<p>
たとえばブラウザで
<div class=figure>
<code>http://<span class=bgy>www.example.com</span>:<span class=bgr>80</span><span class=bgg>/news/</span></code>
</div>
というURL を開くと、
TCPポート <span class=bgr>80</span>番に対して接続がおこなわれ、
以下のような<u>リクエスト</u>文字列が送信される:
<blockquote><pre>
GET <span class=bgg>/news/</span> HTTP/1.1
Host: <span class=bgy>www.example.com</span>
User-Agent: Mozilla/5.0 (Windows NT 6.1;) Gecko/20100101
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,&#48;/&#48;;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
<em>(空行)</em>
</pre></blockquote>
<p>
これに対してサーバは以下のような<u>レスポンス</u>文字列を返す:
<blockquote><pre>
HTTP/1.1 200 OK
Connection: close
Date: Fri, 20 Feb 2023 08:27:28 GMT
Content-Type: text/html
Content-Length: 9022
<em>(空行)</em>
&lt;html&gt;
...
</pre></blockquote>

<h4>HTTPリクエスト</h4>
<p>
HTTP リクエストには GET, POST などいくつかの種類があり、
リクエストはさらに <u>ヘッダ</u> (header) と
<u>ボディ (ペイロード)</u> (body, payload) に分かれている。
これらは<em>空行</em>で分けられている。

<blockquote>
リクエストヘッダ:<br>
<pre>
GET /news/ HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:35.0) Gecko/20100101 Firefox/35.0
…
<em>(空行)</em>
</pre>
リクエストボディ (ペイロード):<br>
</blockquote>

<p>
ヘッダは <u>項目名</u>: <u>値</u> の形をとる。
</p>
<ul>
<li> <code><u>Host:</u></code> 相手のサーバの名前
<li> <code><u>User-Agent:</u></code> ブラウザの種類
<li> その他 (<A target="_blank" href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 参照)
</ul>
<p>
通常、GETリクエストはヘッダのみで構成され、ボディは空である。
つまり何も含まれていない。
</p>

<h4>HTTPレスポンス</h4>
<p>
HTTP レスポンスもまた、
<u>ヘッダ</u> (header) と
<u>ボディ (ペイロード)</u> (body, payload) に分かれている。
これらは<em>空行</em>で分けられている。

<blockquote>
レスポンスヘッダ:<br>
<pre>
HTTP/1.1 200 OK
Connection: close
Date: Fri, 20 Feb 2015 08:27:28 GMT
Content-Type: text/html
Content-Length: 9022
…
<em>(空行)</em>
</pre>
レスポンスボディ (ペイロード):<Br>
<pre>
&lt;html&gt;&lt;body&gt;
…
</pre></blockquote>

<p>
ヘッダは <u>項目名</u>: <u>値</u> の形をとる。
</p>
<ul>
<li> <code><u>Date:</u></code> サーバの応答時刻。
<li> <code><u>Content-Type:</u></code> そのコンテンツの種類 (HTMLファイルか画像か)。
<li> <code><u>Content-Length:</u></code> そのコンテンツの大きさ (バイト数)。
</ul>
<p>
レスポンス内のペイロードには、通常 HTML ファイル
(または画像ファイルなど) の内容がそのまま含まれている。
ブラウザはこの内容を解析して表示すると、ページが表示されたことになる。
</p>

<h4>いろいろな HTTP レスポンス</h4>
<p>
正常なレスポンスの場合、最初の一行は必ず
<blockquote><pre>
HTTP/1.1 <u>200</u> OK
</pre></blockquote>
となっているが、これ以外のレスポンスが返ってくる場合もある。
<ul>
<li> 指定されたファイルが存在しない。いわゆる「ページが見つかりません」エラー。
    この場合、サーバはペイロードとして HTML を返すこともある。
  <blockquote><pre>HTTP/1.1 <u>404</u> Not Found</pre></blockquote>
  <p> 例: <a target="_blank" href="https://www.yahoo.co.jp/nonexistent">https://www.yahoo.co.jp/nonexistent</a>
<li> 別の場所を参照せよ。これが返されると、ブラウザのアドレスバーが変化する。
  <blockquote><pre>HTTP/1.1 <u>302</u> Moved</pre></blockquote>
  <p> 例: <a target="_blank" href="https://ja.wikipedia.org/">https://ja.wikipedia.org/</a>
</ul>

<div class=exercise id="ex-human-http-client">
<div class=header>演習. 人間HTTPクライアント</div>
<p>
<code>nc</code> コマンドを使って、
<a target="_blank" href="https://www.example.com/">www.example.com</a> サーバに
「人間HTTPクライアント」としてリクエストを送り、
サーバ側のレスポンスを確認せよ。
</p>
<blockquote><pre>
$ <strong>nc www.example.com 80</strong>
<strong>GET / HTTP/1.0</strong>
<strong>Host: www.example.com</strong>

<em>(サーバからのレスポンス)</em>
HTTP/1.0 200 OK
Content-Type: text/html; charset=UTF-8
Date: Mon, 23 Jan 2023 13:39:22 GMT
…

&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
…
</pre></blockquote>
</div>

<div class=exercise id="ex-human-http-server">
<div class=header>演習. 人間HTTPサーバ</div>
<p>
<code>nc</code> コマンドを使って、
「人間HTTPサーバ」としてブラウザからの
リクエストに返答せよ。
まず <code>nc</code> をサーバとして起動し、
ブラウザから <a href="http://localhost:8080/"><code>http://localhost:8080/</code></a>
という URLに接続してリクエストが送られるのを確認してから、
応答を入力せよ。
</p>
<blockquote><pre>
$ <strong>nc -l -p 8080</strong>
<em>(クライアントからのリクエスト)</em>
GET / HTTP/1.1
User-Agent: Mozilla/5.0
…

<strong>HTTP/1.0 200 OK</strong>
<strong>Content-Type: text/plain</strong>

<strong>Hello.</strong>

^C
</pre></blockquote>
</div>

<div class=exercise id="ex-http-troubleshooting">
<div class=header>演習. トラブルシューティング</div>
<p>
あるユーザが「インターネットが動かない」といっている。
聞けばブラウザに <code>http://www.example.com/</code> というアドレスを入力したが、
ページが表示されないのだという。この場合、考えられる原因をすべてあげよ。
<ol type=a>
<li> <nobr><span class=bl>どこかのケーブルが断線している</span></nobr>
<li> <nobr><span class=bl>DNS から IPアドレスが解決できていない</span></nobr>
<li> <nobr><span class=bl>ルータが正しく動いていない</span></nobr>
<li> <nobr><span class=bl>パケットが捨てられている</span></nobr>
<li> <nobr><span class=bl>ブラウザにバグがある</span></nobr>
<li> <nobr><span class=bl>相手のサーバの電源が入っていない</span></nobr>
<li> <nobr><span class=bl>相手のサーバがListen状態になっていない</span></nobr>
<li> <nobr><span class=bl>相手のサーバプログラムにバグがある</span></nobr>
<li> ...
</ol>
</p>
</div>

<h3 id="app-email">5.3. 電子メール (SMTP)</h3>
<p>
TCP 層の機能を使って、特定のサーバの TCP 25番ポートに
特定の規約でデータを送ると、電子メールを送ることができる。
この「規約」は <u>S</u>imple <u>M</u>ail <u>T</u>ransfer <u>P</u>rotocol
(SMTP) と呼ばれている。
</p>
<blockquote><pre>
$ <strong>nc gmail-smtp-in.l.google.com 25</strong>
220 mx.google.com ESMTP
<strong>HELO mail.example.com</strong>
250 mx.google.com at your service
<strong>MAIL FROM:&lt;<u>送り元メールアドレス</u>&gt;</strong>
250 2.1.0 OK
<strong>RCPT TO:&lt;<u>xxx@gmail.com</u>&gt;</strong>
250 2.1.5 OK
<strong>DATA</strong>
354  Go ahead zz-1234 - gsmtp
<strong>From: &lt;<u>送り元メールアドレス</u>&gt;</strong>
<strong>To: &lt;<u>xxx@gmail.com</u>&gt;</strong>
<strong>Message-Id: &lt;zz12345678@mail.example.com&gt;</strong>
<strong>Subject: test</strong>

<strong>Hello, this is test!</strong>
<strong>.</strong>
250 2.0.0 OK
<strong>QUIT</strong>
221 2.0.0 closing connection
</pre></blockquote>


<h2 id="encryption">6. 暗号化</h2>
<p>
本来、TCP/IP の公式な範疇はTCP層までで、それより上は
アプリケーションの責任となっている。しかし TCP 層まででは
真に安全な通信は実現できない。とくに、TCP 層には以下のような欠点がある:
</p>
<ul>
<li> 短所: 通信内容が中継ホストにまる見えであること。
<li> 短所: 通信相手が本物かどうか確認できないこと。
  (中継するホストが最終目的のIPアドレスのふりをすることが可能である)
<li> 短所: 通信内容が途中で改竄される可能性があること。
</ul>

<p>
そこで最近では、これらの欠点を補うため TCP層の上にさらにもう一段、
暗号化をおこなう層を追加して使うことが多い。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="180">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" fill="#ff88ff" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <rect x="0" y="120" width="120" height="30" />
      <line x1="60" y1="150" x2="60" y2="170" />
      <line x1="-50" y1="170" x2="170" y2="170" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">暗号化層</text>
      <text x="60" y="75" dy="0.5em">TCP層</text>
      <text x="60" y="105" dy="0.5em">IP層</text>
      <text x="60" y="135" dy="0.5em">データリンク層</text>
      <text x="170" y="158" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<p>
暗号化通信において特に重要なのは、
「<strong>暗号化は、必ず通信相手の確認とセットで使わなければ意味がない</strong>」
ということである。
悪者も暗号は使えるので、たとえば中継ホストが正当な相手のフリをして
自分と暗号を使って通信すれば、結局のところ情報は悪者の手に渡ってしまう。
(中間者攻撃)
</p>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="500" height="120"
       transform="scale(1,1)">
    <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g id="user" fill="none" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    <g id="baddie" fill="black" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    </defs>
    <use xlink:href="#user" x="10" y="20" />
    <use xlink:href="#baddie" x="260" y="20" />
    <use xlink:href="#user" x="410" y="20" />
    <g stroke="black" fill="none" stroke-width="4" marker-end="url(#arrow)">
      <line x1="80" x2="240" y1="40" y2="40" />
      <line x1="240" x2="80" y1="60" y2="60" />
    </g>
    <g style="font-size: 75%;" text-anchor="middle">
      <text x="160" y="30">暗号</text>
      <text x="35" y="90">自分</text>
      <text x="285" y="90">悪者</text>
      <text x="285" y="90" dy="1.1em">(中間者)</text>
      <text x="435" y="90">本当に通信したい相手</text>
    </g>
  </svg>
</div>

<p>
現在、普及している暗号化層は 2種類存在する。
<u>TLS/SSL</u>層または<u>SSH</u>層である。
TLS/SSL は <u>認証局 (CA)</u> という中央集権的な
枠組みを導入することにより、相手のホストを識別する枠組みである。
いっぽう SSH は個人の信頼にもとづいたホスト間の
簡単な認証システムを提供している。
</p>
<p>
TLS/SSL も SSH も (本来は TCP/IP 層の一部ではなくアプリケーション層なので)、
アプリケーションまたはライブラリの形で提供されており、
利用者に対して end-to-end の安全な通信を提供する。
どちらもベースになっているのは<u>公開鍵暗号</u>技術である。
</p>

<h3 id="encryption-tls">6.1. TLS/SSL層</h3>

<p>
TLS/SSL はもともと HTTP を暗号化するための方式 (HTTPS) として
提案されたものである。これは、ブラウザ上にいわゆる
「鍵マーク」を表示する仕組みで、<u>デジタル証明書</u> を使って
接続先のサーバ名が正しいかどうかを
<u>認証局 (CA)</u> と呼ばれる第三者機関に確認してもらい、
「安全」というお墨付きを得ている。
</p>
<p>
デジタル証明書は認証局が発行し、
ここで使われる公開鍵が本当にその個人・組織に
所属するという証明として使われる。詳細は
<a href="../certs202301/index.html">「デジタル証明書とは何か?」</a>を参照。
</p>

<div class=figure style="align-items: flex-end;">
  <img src="key.png" width="389" height="131">

  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="200"
       transform="scale(1,1)">
    <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g id="user" fill="none" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    <g id="ca" fill="none" stroke="black" stroke-width="2">
      <rect x="5" y="0" width="40" height="50" />
      <path d="M10,10 l0,40 M15,10 l0,40 M20,10 l0,40 M25,10 l0,40 M30,10 l0,40 M35,10 l0,40 M40,10 l0,40" />
    </g>
    <g id="site" fill="none" stroke="black" stroke-width="2">
      <rect x="15" y="0" width="20" height="50" />
      <rect x="0" y="20" width="50" height="30" />
    </g>
    <g id="keyg" fill="none" stroke="green" stroke-width="3">
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    </defs>
    <use xlink:href="#user" x="10" y="120" />
    <use xlink:href="#ca" x="160" y="20" />
    <use xlink:href="#site" x="310" y="120" />
    <use xlink:href="#keyg" x="75" y="80" />
    <use xlink:href="#keyg" x="370" y="150" />
    <g stroke="black" fill="none" stroke-width="1">
      <rect x="20" y="50" width="85" height="40" />
      <rect x="18" y="48" width="89" height="44" />
    </g>
    <g stroke="black" fill="none" stroke-width="4" marker-end="url(#arrow)">
      <line x1="280" x2="80" y1="150" y2="150" />
      <line x1="150" y1="60" x2="80" y2="120" />
    </g>
    <g style="font-size: 75%;" text-anchor="middle">
      <text x="185" y="85">認証局 (CA)</text>
      <text x="35" y="185">ブラウザ</text>
      <text x="335" y="185" fill="green">www.google.com</text>
    </g>
    <g style="font-size: 75%;">
      <text x="40" y="65">証明書</text>
      <text x="25" y="85">Google:</text>
      <text x="140" y="170">署名:</text>
      <text x="170" y="170" fill="green" style="font-size: 125%; font-weight: bold; font-style: italic;">Google</text>
    </g>
  </svg>
</div>

<p>
実際の TLS/SSL による通信は <code>openssl</code> コマンドを使って
おこなうことができる:
</p>
<blockquote><pre>
$ <strong>openssl s_client -connect www.example.com:443</strong>
CONNECTED(00000003)
depth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA
verify return:1
depth=1 C = US, O = DigiCert Inc, CN = DigiCert TLS RSA SHA256 2020 CA1
verify return:1
depth=0 C = US, ST = California, L = Los Angeles, O = Internet\C2\A0Corporation\C2\A0for\C2\A0Assigned\C2\A0Names\C2\A0and\C2\A0Numbers, CN = www.example.org
verify return:1
...
</pre></blockquote>

<p>
TLS/SSL層を使った通信では、
まず相手のサーバに TCP接続した後、
デジタル証明書を送る処理 (TLS/SSLハンドシェイク) が追加されている。
上の例では <code>www.example.com</code> サーバが証明書を送っているところが見える。
この処理が完了すると、TLS/SSL層はその上のアプリケーション層に対して
通常の TCP層と同じようにふるまうため、
アプリ側は何も考えずに普通の HTTP の処理を行えばよい。
つまり、<code>https://…</code> という URL に対する処理は、
TLS/SSL層を使った部分以外は通常の <code>http://…</code> と同じである。
なお、HTTPS には通常 TCP 443番ポートが使われる。
</p>

<div class=exercise id="ex-openssl-http-client">
<div class=header>演習. openssl コマンドを使って HTTPリクエストを送る</div>
<p>
上で示した openssl コマンドを使って、
<a href="#">先の演習</a>にならい
サーバに HTTPリクエストを送り、応答を確認せよ。
</p>
<blockquote><pre>
$ <strong>openssl s_client -connect www.example.com:443</strong>
<em>(サーバ証明書の表示)</em>
...
<strong>GET / HTTP/1.0</strong>
<strong>Host: www.example.com</strong>

<em>(サーバからのレスポンス)</em>
HTTP/1.0 200 OK
Content-Type: text/html; charset=UTF-8
…
</pre></blockquote>
</div>

<h3 id="encryption-ssh">6.2. SSH層</h3>
<p>
TLS/SSL 層の大きな欠点は、認証局を頂点とする、中央集権化された、
全世界規模の <u>公開鍵基盤</u> (PKI) を構築する必要があることである。
これには大きなコストがかかるうえに、認証局が信頼できない場合がある
というリスクも抱えている (参考:
<a href="https://ja.wikipedia.org/wiki/2011%E5%B9%B4%E3%83%87%E3%82%B8%E3%83%8E%E3%82%BF%E3%83%BC%E4%BA%8B%E4%BB%B6">2011年デジノター事件</a>)。
</p>
<p>
SSH はこれに対して「サーバが公開鍵を提示し、ユーザにそれを信頼するか否かを
判断させる」という簡単な仕組みで暗号化された通信を実現している。
</p>

<ol>
<li> ユーザは、まず接続しようとするサーバの公開鍵の
<u>指紋</u> (fingerprint) を、なんらかの方法によってあらかじめ知っておく。
<li> サーバの初回接続時に、サーバがその公開鍵の指紋を提示する。
これは以下のように表示される:
<blockquote><pre>
$ <strong>ssh server.example.com</strong>
The authenticity of host '[server.example.com]:22 ([192.168.1.10]:22)' can't be established.
ED25519 key fingerprint is <mark>SHA256:HLfnjG5dDqVPIfWtG6sNGG5JyY5AYtkxaupGsJffyYs</mark>.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</pre></blockquote>
<li> ユーザがこれを信頼すれば (<code>yes</code>)、暗号化された通信が確立する。
</ol>

<p>
SSH では、通常 TCP 22番ポートが使われる。
SSH のよくある使い方はサーバ上のシェルをリモートから実行するためのものだが
(ログイン)、SSH 層自体がいくつかのレイヤーから構成されており、
シェル以外の用途にも利用可能である:
</p>

<ul>
<li> ファイル転送機能 (SFTP)
<li> ポート転送機能
</ul>


<h2 id="security">7. セキュリティ</h2>
<p>
一般的に、ネットワークにおける「セキュリティ」とは、以下の性質をさす:
</p>
<ol type=a>
  <li> 機密性 (情報が不正に閲覧されない)
  <li> 完全性 (情報が不正に改竄されない)
  <li> 可用性 (情報へのアクセスが妨害されない)
</ol>
<p>
先に述べた暗号化は上の性質 a., b. に対してある程度は有効だが、
完全ではない (そもそも「完全な」セキュリティなど現実にありえない)。
インターネットは本質的に信頼できないネットワークであり、
暗号化以外にもネットワークからの攻撃を防ぐ仕組みがいくつも存在する。
</p>

<h3 id="security-privateip">7.1. プライベートIPアドレス</h3>
<p>
インターネットを使う<strong>すべての</strong>機器には
IPアドレスが必要であり、しかも同じアドレスを 2つの場所で使ってはならない。
しかし、IP アドレスは 32ビットで表現されているため、
たかだか 2<sup>32</sup> ≒ 42億個しか表現できない。
→ IPアドレスが足りない。
</p>
<p>
そこで、以下のアドレスは組織内で勝手に使ってよいという
決まりになっている。これを <u>プライベート IPアドレス</u> といい、
このような IPアドレスで構成したネットワークを
<u>プライベート ネットワーク</u> (private network) という。
</p>
<ul>
<li> <code>10.0.0.0/8</code>
<li> <code>172.16.0.0/12</code>
<li> <code>192.168.0.0/16</code>
<li> ...
</ul>

<div class=notice>
注意:
プライベートIPアドレスのホストは、
インターネット (その組織の外) からは到達できない。
</div>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="410" height="230">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="white" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <ellipse cx="75" cy="160" rx="70" ry="40" />
      <ellipse cx="340" cy="70" rx="58" ry="65" />
      <use xlink:href="#computer" x="0" y="100" />
      <use xlink:href="#computer" x="100" y="120" />
      <use xlink:href="#computer" x="30" y="170" />
      <use xlink:href="#computer" x="150" y="0" />
      <use xlink:href="#computer" x="280" y="30" />
      <use xlink:href="#computer" x="350" y="0" />
      <use xlink:href="#computer" x="300" y="80" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="175" y="50" dy="0.5em">166.84.7.55</text>
      <text x="125" y="170" dy="0.5em">192.168.1.1</text>
      <text x="55" y="220" dy="0.5em">192.168.1.2</text>
      <text x="35" y="150" dy="0.5em">192.168.1.3</text>
      <text x="305" y="80" dy="0.5em">192.168.1.1</text>
      <text x="375" y="50" dy="0.5em">192.168.1.2</text>
      <text x="325" y="130" dy="0.5em">192.168.1.4</text>
      <text x="175" y="70" dy="0.5em">グローバルIP</text>
      <text x="75" y="85" dy="0.5em">プライベート</text>
      <text x="75" y="100" dy="0.5em">ネットワーク</text>
      <text x="340" y="155" dy="0.5em">プライベート</text>
      <text x="340" y="170" dy="0.5em">ネットワーク</text>
    </g>
  </svg>
</div>

<p>
これに対して、世界中から実際に到達可能な「普通の」IPアドレスのことを
<u>グローバル IPアドレス</u>という。
現在の日本のオフィス・家庭では、ルータ以外の
機器はほとんどプライベート IP アドレスを使っている。
プライベートネットワークに接続された機器は外部のインターネットから
アクセスできないため、そのネットワーク内で「信頼された」機器として
扱われ、パスワード等による認証も省略されることが多い。
そのため、多くの組織でプライベートネットワークは
「安全なネットワーク (イントラネット)」として使われる。
</p>

<h4>IPv6</h4>
<p>
アドレスの不足を解決するため、現在の IP 層を変更して
128ビットのアドレスを使えるようにしたものが <u>IPv6</u> である。
これに対して、従来の IP層は <u>IPv4</u> という。
IPv6 を使えばすべての機器がグローバル IP アドレスを持つことができる。
しかし IPv6 は従来の IPv4 とは互換性がないため、
世界じゅうのルータを入れ換えなければならない。
このため、まだあまり普及していない。
</p>

<h3 id="security-nat">7.2. NAT</h3>
<p>
<u>NAT</u> (Network Address Translation) とは、
プライベートネットワーク内のホストがインターネットに
アクセスするための仕組みである。
具体的には、ルータが「どのプライベートIPアドレスがどのグローバルIPアドレスと
通信しているか」をすべて覚えておき、それに該当する (双方向の)
IPパケットが来るたびにそのアドレスを書き換えることによって実現する:
</p>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="550" height="122" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="20" />
      <use xlink:href="#computer" x="200" y="20" />
      <use xlink:href="#computer" x="400" y="20" />
      <line x1="60" y1="52" x2="190" y2="52" />
      <line x1="260" y1="52" x2="390" y2="52" />
      <rect x="60" y="2" width="120" height="40" />
      <rect x="260" y="2" width="120" height="40" />
      <rect x="280" y="80" width="120" height="40" />
      <rect x="60" y="80" width="120" height="40" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="184" y1="22" x2="200" y2="22" />
        <line x1="384" y1="22" x2="400" y2="22" />
        <line x1="276" y1="105" x2="260" y2="105" />
        <line x1="56" y1="105" x2="40" y2="105" />
      </g>
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="25" y="70" dy="0.5em">192.168.1.2</text>
      <text x="225" y="70" dy="0.5em">192.168.1.1</text>
      <text x="225" y="85" dy="0.5em">11.22.33.44</text>
      <text x="425" y="70" dy="0.5em">166.84.7.55</text>
      <text x="120" y="12" dy="0.5em">Src: 192.168.1.2</text>
      <text x="120" y="27" dy="0.5em">Dst: 166.84.7.55</text>
      <text x="320" y="12" dy="0.5em">Src: 11.22.33.44</text>
      <text x="320" y="27" dy="0.5em">Dst: 166.84.7.55</text>
      <text x="340" y="92" dy="0.5em">Src: 166.84.7.55</text>
      <text x="340" y="107" dy="0.5em">Dst: 11.22.33.44</text>
      <text x="120" y="92" dy="0.5em">Src: 166.84.7.55</text>
      <text x="120" y="107" dy="0.5em">Dst: 192.168.1.2</text>
    </g>
  </svg>
</div>

<div class=exercise id="ex-nat">
<div class=header>演習. NATの動きを理解する</div>
<p>
プライベートネットワーク内のホスト <code>10.10.1.2</code> が
ゲートウェイ <code>10.10.1.1</code> を経由して、
インターネット上のホスト <code>55.66.77.88</code> と通信するとする。
このとき送信されるIPパケットの送信元・送信先アドレスを書け。
</p>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="550" height="122" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="20" />
      <use xlink:href="#computer" x="200" y="20" />
      <use xlink:href="#computer" x="400" y="20" />
      <line x1="60" y1="52" x2="190" y2="52" />
      <line x1="260" y1="52" x2="390" y2="52" />
      <rect x="60" y="2" width="120" height="40" />
      <rect x="260" y="2" width="120" height="40" />
      <rect x="280" y="80" width="120" height="40" />
      <rect x="60" y="80" width="120" height="40" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="184" y1="22" x2="200" y2="22" />
        <line x1="384" y1="22" x2="400" y2="22" />
        <line x1="276" y1="105" x2="260" y2="105" />
        <line x1="56" y1="105" x2="40" y2="105" />
      </g>
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="25" y="70" dy="0.5em">10.10.1.2</text>
      <text x="225" y="70" dy="0.5em">10.10.1.1</text>
      <text x="225" y="85" dy="0.5em">11.22.33.44</text>
      <text x="425" y="70" dy="0.5em">55.66.77.88</text>
    </g>
    <g style="font-size: 80%;">
      <text x="70" y="12" dy="0.5em">Src: </text>
      <text x="70" y="27" dy="0.5em">Dst: </text>
      <text x="270" y="12" dy="0.5em">Src: </text>
      <text x="270" y="27" dy="0.5em">Dst: </text>
      <text x="290" y="92" dy="0.5em">Src: </text>
      <text x="290" y="107" dy="0.5em">Dst: </text>
      <text x="70" y="92" dy="0.5em">Src: </text>
      <text x="70" y="107" dy="0.5em">Dst: </text>
    </g>
  </svg>
</div>
</div>

<h3 id="security-firewall">7.3. ファイヤウォール</h3>
<p>
<u>ファイヤウォール</u> (Firewall) とは、ホストにとって
害のありそうなパケットを無視する (フィルタする) 機器またはソフトウェアのことである。
現在の一般的な環境では:
<ol>
<li> ルータの機能の一部として
<li> OSの機能の一部として (Windows ファイヤウォール)
</ol>
提供されている。

<p>
通常はファイヤウォールは 外 → 内 のパケットをフィルタするが、
たまに 内 → 外 のパケットをフィルタすることもある。
</p>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="550" height="122" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    <g id="cross" fill="none" stroke="black" stroke-width="2">
      <line x1="0" y1="0" x2="20" y2="20" />
      <line x1="20" y1="0" x2="0" y2="20" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="40" />
      <use xlink:href="#computer" x="200" y="40" />
      <use xlink:href="#computer" x="400" y="40" />
      <line x1="60" y1="72" x2="190" y2="72" />
      <line x1="260" y1="72" x2="390" y2="72" />
      <rect x="270" y="10" width="50" height="30" />
      <rect x="130" y="90" width="50" height="30" />
      <use xlink:href="#cross" x="215" y="15" />
      <use xlink:href="#cross" x="215" y="95" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="266" y1="25" x2="250" y2="25" />
        <line x1="184" y1="105" x2="200" y2="105" />
      </g>
    </g>
  </svg>
</div>

<p>
ファイヤウォールには、一般的に以下のようなルールが設定できる:
</p>
<ul>
<li> 特定の宛先IPアドレスはダメ
<li> 特定の宛先IPポートはダメ
<li> ...
</ul>

<h4>WAF と IDS/IPS</h4>
<p>
最近のネットワークでは、ファイヤウォールに加えて
以下のような機器も使われることが多い:
</p>

<ul>
<li> <u>WAF</u> (Web Application Firewall、Webアプリケーションファイヤウォール)
<li> <u>IDS</u> (Intrusion Detection System、侵入検知システム)
<li> <u>IPS</u> (Intrusion Protection System、侵入防御システム)
</ul>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="560" height="220" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="150" />
      <use xlink:href="#computer" x="150" y="150" />
      <use xlink:href="#computer" x="300" y="150" />
      <use xlink:href="#computer" x="350" y="80" />
      <use xlink:href="#computer" x="350" y="10" />
      <path d="M60,180 l80,0 M210,180 l80,0 M360,180 l80,0" />
      <path d="M375,180 l0,-50 M375,80 l0,-20" />
      <ellipse cx="500" cy="180" rx="50" ry="25" />
    </g>
    <g text-anchor="middle" style="font-size:75%;">
      <text x="400" y="30" dy="0.5em" text-anchor="start">ウェブサーバ</text>
      <text x="400" y="100" dy="0.5em" text-anchor="start">WAF</text>
      <text x="175" y="200" dy="0.5em">IDS/IPS</text>
      <text x="325" y="200" dy="0.5em">ファイヤウォール</text>
      <text x="500" y="180" dy="0.5em">インターネット</text>
    </g>
  </svg>
</div>

<h3 id="security-proxy">7.4. プロキシサーバ</h3>
<p>
<u>プロキシサーバ</u> (proxy server) は、
プライベートネットワーク内にある PC が外部と通信するための方法のひとつである。
NAT とは異なり、IP層 (レイヤー3) ではなく TCP層 (レイヤー4) の接続を制御する。
</p>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="550" height="80" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="20" />
      <use xlink:href="#computer" x="200" y="20" />
      <use xlink:href="#computer" x="400" y="20" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="60" y1="52" x2="190" y2="52" />
        <line x1="260" y1="52" x2="390" y2="52" />
      </g>
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="125" y="20" dy="0.5em">192.168.1.1:8080</text>
      <text x="325" y="20" dy="0.5em">166.84.7.55:80</text>

      <text x="25" y="70" dy="0.5em">192.168.1.2</text>
      <text x="225" y="70" dy="0.5em">192.168.1.1</text>
      <text x="425" y="70" dy="0.5em">166.84.7.55</text>
    </g>
  </svg>
</div>

<ol>
<li> あらかじめ、プライベートネットワーク内のブラウザが
特定のプロキシサーバに接続するよう設定しておく。
<li> ブラウザがインターネット上のホストにじかに接続するかわりに、
プロキシサーバの指定されたTCPポートに接続する。
<li> プロキシサーバは、あらためて宛先のWebサーバに向けてTCP接続し、
その内容を転送する。
</ol>

<h4>利点</h4>
<ul>
<li> NAT が必要ない。
<li> より細かい通信制御ができる (例. 特定サイトの閲覧を禁止する)
</ul>

<h3 id="security-vpn">7.5. VPN</h3>
<p>
プライベートネットワークは、本来は外部からアクセスできない
(ファイヤウォールで守られた) 安全な環境に有線で構築するのが普通である。
しかし暗号化を使うことにより、安全でない環境を通って
プライベートネットワークを構築することが可能になった。
これを <u>VPN</u> (Virtual Private Network、仮想プライベートネットワーク) という。
</p>

<hr>
<address>Yusuke Shinyama</address>
