<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Yusuke Shinyama">
<meta name="keywords" content="ネットワーク, データリンク層, IP, TCP, UDP, ルーティング, クライアント, サーバ, HTTP, DNS, TLS/SSL, SSH, NAT, VPN, ファイヤウォール, 暗号, セキュリティ">
<meta name="description" content="アプリ開発者の役に立ちそうなTCP/IPネットワークに関する知識まとめ。">
<meta name="twitter:card" content="summary" />
<meta property="og:type" content="website" />
<meta property="og:title" content="アプリ開発者のための TCP/IP ネットワーク入門" />
<meta property="og:url" content="https://euske.github.io/slides/tcpip202301/index.html" />
<meta property="og:description" content="アプリ開発者の役に立ちそうなTCP/IPネットワークに関する知識まとめ。" />
<title>アプリ開発者のための TCP/IP ネットワーク入門
/ 新山 祐介</title>
<style><!--
body { line-height: 1.5; }
h1 { border-bottom: solid 4px #000088; }
h2 { border-bottom: solid 2px #000088; }
h3 { border-bottom: solid 1px #000088; }
table { border-collapse: collapse; margin: 1em; }
td { padding: 4px; }
kbd { outline: 1px solid black; padding: 2px; }
blockquote { outline: 1px solid black; padding: 4px; }
pre { overflow: auto; margin: 0; }
mark { font-weight: bold; }
pre, code { background: #ddd; font-size: 150%; font-family: courier; }
img { max-width: 80vw; height: auto; }
dt { text-decoration: underline; font-weight: bold; }
u { color: #880000; font-weight: bold; }
.author { text-align: right; }
.figure { outline: 1px solid black; padding: 0.5em; margin: 1em; display: flex; justify-content: center; align-items: flex-end; text-align: center; gap: 2em; }
.figure .caption { font-size: 80%; font-weight: bold; }
.notice { font-size: 100%; font-weight: bold; background: #ffff88; outline: 2px solid black; padding: 0.5em; margin: 0.5em; }
.formula { background: #88ff88; outline: 2px solid black; padding: 1em; margin: 1em; }
.note { background: #ffff88; outline: 2px solid black; padding: 1em; margin: 1em; }
pre em { color: #008800; }
code em { color: #000088; }
.exercise { outline: 2px solid black; padding: 1em; margin: 1em; }
.exercise > .header { font-size: 120%; font-weight: bold; border-bottom: solid 1px red; border-left: 4px solid red; padding-left: 8px; }
.bl { outline: 1px solid black; padding: 2px; font-size: 120%; color: transparent; }
.file { outline: 2px solid black; padding: 1em; margin: 1em; }
.file > .header { font-weight: bold; color: white; background: #000088; margin-bottom: 4px; padding-left: 1em; }
.file pre { margin: 0; }

.g { background: #eeeeee; }
.bgr { background: #ffbbff; }
.bgg { background: #88ff88; }
.bgb { background: #88ffff; }
.bgy { background: #ffff88; }

.wip { color: gray; }
--></style>
</head>
<body>
<div class=nav>
<a href="../index.html">&lt; もどる</a>
</div>
<h1>アプリ開発者のための<br>
TCP/IP ネットワーク入門</h1>

<div class=author>
Yusuke Shinyama, Mar. 2023
</div>

<p>
<strong>概要:</strong>
この記事では、アプリ開発者の役に立ちそうな
TCP/IPネットワークに関する最低限の知識をまとめた。
あくまで視点は「アプリ開発者」なので、
現在の家庭・企業における一般的なネットワーク環境しか想定していないし、
セキュリティに関しても基本的なことしかカバーしていない。
ネットワーク機器の具体的な設定方法や診断については、より専門的な資料を参照のこと。
</p>

<ul>
<li> <a href="#internet">第1回 (3/15): インターネットの概要、データリンク層、IP層</a>
<li> <a href="#tcp">第2回 (3/31): TCP層、DNS、HTTP</a>
<li> <a href="#encryption">第3回 (4/11): 暗号化、NAT、ファイヤーウォール、VPN、SSH</a>
</ul>

<h4>目次</h4>
<ol>
<li> <a href="#internet">インターネットの作り方・概要</a>
<ul>
  <li> <a href="#internet-basic">ネットワーク通信の原理</a>
  <li> <a href="#internet-layers">ネットワークの「階層」</a>
  <li> <a href="#internet-datalink">データリンク層</a>
  <li> <a href="#internet-ip">IP層 (ネットワーク層)</a>
  <li> <a href="#internet-tcp">TCP層 (トランスポート層)</a>
  <li> <a href="#internet-application">アプリケーション層</a>
</ul>
<li> <a href="#datalink">データリンク層のしくみ</a>
<ul>
  <li> <a href="#datalink-macaddr">物理アドレス (MACアドレス)</a>
  <li> <a href="#datalink-frame">Ethernetフレーム</a>
  <li> <a href="#datalink-virtual">仮想インターフェイス</a>
</ul>
<li> <a href="#ip">IP層 (ネットワーク層) のしくみ</a>
<ul>
  <li> <a href="#ip-addr">IPアドレス</a>
  <li> <a href="#ip-routing">ルーティング</a>
  <li> <a href="#ip-cidr">CIDR 方式</a>
  <li> <a href="#ip-wan">広域レベルでのルーティング</a>
</ul>
<li> <a href="#tcp">TCP層 (トランスポート層) のしくみ</a>
<ul>
  <li> <a href="#ex-1">前回までおさらい</a>
  <li> <a href="#tcp-details">TCPの詳細</a>
  <li> <a href="#tcp-client-server">「クライアント」と「サーバ」</a>
  <li> <a href="#tcp-udp">UDP層</a>
</ul>
<li> <a href="#application">アプリケーション層</a>
<ul>
  <li> <a href="#app-dns">ドメイン名検索 (DNS)</a>
  <li> <a href="#app-web">ウェブ (HTTP)</a>
  <li> <a href="#app-email">電子メール (SMTP)</a>
</ul>
<li> <a href="#encryption">暗号化</a>
<ul>
  <li> <a href="#ex-2">前回までおさらい</a>
  <li> <a href="#encryption-tls">TLS/SSL層</a>
  <li> <a href="#encryption-ssh">SSH層</a>
</ul>
<li> <a href="#security">セキュリティ</a>
<ul>
  <li> <a href="#security-privateip">プライベートIPアドレス</a>
  <li> <a href="#security-nat">NAT</a>
  <li> <a href="#security-firewall">ファイヤウォール</a>
  <li> <a href="#security-proxy">プロキシサーバ</a>
  <li> <a href="#security-vpn">VPN</a>
  <li> <a href="#security-ssh-tunnel">SSHによるトンネリング</a>
</ul>
</ol>


<h4>使用するツール</h4>
<div class=formula>
<a target="_blank" href="https://www.wireshark.org/">Wireshark</a> :
パケットキャプチャ・解析ツール。
</div>

<h2 id="internet">1. インターネットの作り方・概要</h2>

<h3 id="internet-basic">1.1. ネットワーク通信の原理</h3>
<ul>
<li> インターネットに接続されている各コンピュータのことを
<u>ホスト</u> (host) と呼ぶ。
<li> インターネットでは、信号線は基本的に 1本しかなくても、
複数のホストどうしが同時に双方向で通信できる。
</ul>

<div class=figure>
<div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="400" height="220">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <symbol id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </symbol>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" transform="translate(10,100)" />
      <use xlink:href="#computer" transform="translate(100,40)" />
      <use xlink:href="#computer" transform="translate(120,120)" />
      <use xlink:href="#computer" transform="translate(200,160)" />
      <use xlink:href="#computer" transform="translate(210,50)" />
      <use xlink:href="#computer" transform="translate(280,100)" />
      <use xlink:href="#computer" transform="translate(290,10)" />
      <line x1="50" y1="120" x2="130" y2="140" />
      <line x1="140" y1="130" x2="120" y2="80" />
      <line x1="140" y1="60" x2="220" y2="70" />
      <line x1="150" y1="160" x2="210" y2="180" />
      <line x1="230" y1="170" x2="240" y2="90" />
      <line x1="240" y1="180" x2="300" y2="140" />
      <line x1="305" y1="110" x2="310" y2="50" />
      <path d="M 70,150 C 80,150 120,150 140,170 C 160,200 200,210 230,210 C 270,210 290,170 300,150" marker-end="url(#arrow)" stroke="blue" />
      <path d="M 290,60 C 290,70 290,110 280,130 C 270,150 240,160 230,160 C 210,160 170,140 150,120 C 140,110 140,90 140,90" marker-end="url(#arrow)" stroke="blue" />
    </g>
  </svg>
  <div class="caption">コンピュータのネットワーク</div>
</div>
</div>

<p>
これを実現するには、2通りの方法がある:
</p>
<ul>
<li> <a target="_blank" href="https://www.youtube.com/embed/-uuNf3_FZH0">回線交換</a>
  (使用中はずっと回線を占有する)
<li> <u>パケット通信</u>
  (データを小分けにして送信するため、回線を占有しない)
</ul>

<p>
インターネットではパケット通信を使っている。
</p>

<ul>
<li> ケーブルの中には、多様なデータのパケットが流れている。
<li> 各パケットには、行き先をあらわす「<u>アドレス</u>」がついている。
<li> データの種類は、各パケットにつけられた「<u>ポート番号</u>」および
「通信手順 (<u>プロトコル</u>)」で区別する。
</ul>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="600" height="200">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g stroke="black" stroke-width="3" fill="none">
      <rect x="60" y="10" width="500" height="180" />
      <ellipse cx="60" cy="100" rx="50" ry="90" fill="white" />
      <rect x="180" y="25" width="80" height="40" />
      <rect x="405" y="65" width="80" height="40" />
      <rect x="330" y="130" width="100" height="40" />
      <rect x="160" y="100" width="80" height="40" />
      <line x1="180" y1="40" x2="140" y2="40" marker-end="url(#arrow)" />
      <line x1="240" y1="120" x2="290" y2="120" marker-end="url(#arrow)" />
      <line x1="485" y1="80" x2="510" y2="80" marker-end="url(#arrow)" />
      <line x1="330" y1="150" x2="290" y2="150" marker-end="url(#arrow)" />
    </g>
    <g text-anchor="middle">
      <text x="220" y="40" dy="0.5em">ウェブ</text>
      <text x="445" y="80" dy="0.5em">LINE</text>
      <text x="200" y="120" dy="0.5em">メール</text>
      <text x="380" y="145" dy="0.5em">動画配信</text>
    </g>
    <g>
      <text x="170" y="60" dy="0.5em" text-anchor="end">11.22.33.44</text>
      <text x="490" y="100" dy="0.5em" text-anchor="begin">55.66.77.88</text>
      <text x="245" y="130" dy="0.5em" text-anchor="begin">123.45.200.10</text>
      <text x="320" y="165" dy="0.5em" text-anchor="end">20.10.8.5</text>
    </g>
  </svg>
<div class="caption">双方向に流れるパケット</div>
</div>
</div>

<h4>インターネット以外に使われている (いた) ネットワーク規格</h4>
<ul>
<li> ATM (国内のみ)
<li> AppleTalk (LAN のみ)
<li> <u>OSI</u> (Open Systems Interconnection)
<li> …
</ul>

<h3 id="internet-layers">1.2. ネットワークの「階層」</h3>
<p>
ネットワークは構築するのが大変だ。(道路と同じ)
</p>
<ul>
<li> いろいろな端末・機器を変えたい。 =  送信機・受信機 (クライアント/端末) の自由
<li> いろいろな用途に使いたい。 = 伝えたい「内容」 (アプリケーション) の自由
<li> いろいろな伝送経路を使いたい。 = 伝送媒体 (メディア、“土管”) の自由
</ul>

<p>
<strong>解決策:</strong>
いくつかの取り替え可能な「部品」から作る。(ソフトウェアと同じ)
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="130" height="170">
    <g transform="translate(5,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <rect x="0" y="120" width="120" height="30" />
      <rect x="0" y="150" width="120" height="30" />
    </g>
  </svg>
</div>

<p>
あるレイヤーを使っている人は、その下の階層を知らなくてもよい。
(そのため揶揄的に“土管”などと呼ばれる。)
</p>

<h4>OSIの7階層モデル</h4>
<p>
OSI はネットワーク規格としては普及しなかったが、
その階層モデルはいまだ説明用によく言及されている。
</p>
<ul>
<li> ハードウェアおよびソフトウェアが 7つの層 (レイヤー) に分けて設計されている。
<li> 各層 (レイヤー) の機能は、その下の層の機能に依存している。
</ul>

<ol>
<li> 物理層
<li> データリンク層
<li> ネットワーク層 (= IP層に相当)
<li> トランスポート層 (= TCP層に相当)
<li> セッション層
<li> プレゼンテーション層
<li> アプリケーション層 (= アプリケーション層に相当)
</ol>

<h4>TCP/IPの4階層モデル</h4>
<ul>
<li> データリンク層 (レイヤー2)
<li> IP層 (レイヤー3)
<li> TCP層 (レイヤー4)
<li> アプリケーション層 (レイヤー7)
</ul>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<p>
インターネットではデータリンク層と物理層を区別していない。
また、アプリケーション層から上は「使う人が勝手に決める」。
</p>
<p>
注意: インターネットの階層でハードウェアが関連しているのは
おもにデータリンク層だけである。それ以上の階層は、
すべてソフトウェア的な「部品」であり、
現在は OS の機能の一部として提供されている。
</p>

<p>
テレビなどと比較すると、インターネットでは上の要素はどれも可変である。
唯一の規格は送受信の方式だけ。そのため、
インターネットは「自由なネットワークだ」といわれる。
</p>

<h3 id="internet-datalink">1.3. データリンク層</h3>
<p>
すべての通信では、まずデータ (0/1 の列) をどうにかして
別のコンピュータに送らねばならない。
</p>

<ul>
<li> <strong>データリンク層の役割:</strong> すぐ隣のコンピュータに、0/1 の列を送る。
<li> <strong>長所:</strong> 伝送エラーがあった場合は自動的に再送できる。
<li> <strong>短所:</strong> 直接接続されたコンピュータ間でしか情報を送れない。
</ul>

<h4>イーサネット (Ethernet)</h4>
<ul>
<li> よく使われているデータリンクの方式のひとつ。
<li> 電線あるいは光ファイバーを使って、
  接続されているすべてのホストに
同じ情報を一斉に送る (ブロードキャスト)。
</ul>

<h4>無線LAN (WiFi)</h4>
<ul>
<li> 電波を使って、すべてのホストに
同じ情報を一斉に送る (ブロードキャスト)。
<li> 電線を使わないイーサネットの一種とみなされている。
</ul>

<h4>海底ケーブル</h4>
<p>
ひとつ隣のホストは別の国である。
</p>
<ul>
<li> <a target="_blank" href="https://www.submarinecablemap.com/">海底ケーブル地図</a>
<li> <a target="_blank" href="https://en.wikipedia.org/wiki/SEA-ME-WE_3_%28cable_system%29">SEA-ME-WE</a>
(全長39,000キロ、世界最長, 960Gbps)
<li> <a target="_blank" href="https://web.archive.org/web/20210307133640/https://jpn.nec.com/info-square/mitatv/discover/01_sequel/index.html">海底ケーブルの秘密に迫る</a> (NEC)
</ul>

<h4>伝書鳩</h4>
<p>
どうにかして 0と1 さえ送れれば、電気を使わなくてもかまわない:
<a target="_blank" href="https://web.archive.org/web/20160305114607/http://www.blug.linux.no/rfc1149/">http://www.blug.linux.no/rfc1149/</a>
</p>

<h3 id="internet-ip">1.4. IP層 (ネットワーク層)</h3>
<p>
IP = Internet Protocol
</p>

<ul>
<li> <strong>IP層の役割</strong>: 複数のホストを経由して、
離れたホストに<u>パケット</u>を送ること。
<li> <strong>長所:</strong> 遠隔地のホストに情報を送れる。
<li> <strong>短所1:</strong> 1度に送れる情報は短いパケットだけ。
<li> <strong>短所2:</strong> パケットが正しく届けられる保証はない。
(パケットは途中で失われたり、同じものが二度届いたりする。)
</ul>

<p>
インターネット上のある「地点」は <u>IPアドレス</u> によって表現される。
<strong>IPアドレスは物理的な場所とは何の関係もない。</strong>
</p>

<h4>IPアドレスの例</h4>
<ul>
<li> <code>127.0.0.1</code>
<li> <code>58.158.55.222</code>
<li> <code>255.255.255.255</code>
</ul>

<h4>ルータ</h4>
<p>
IPパケットは、複数台のコンピュータを経由して転送される。
このような中継用のコンピュータを <u>ルータ</u> (router) とよぶ。
</p>

<h3 id="internet-tcp">1.5. TCP層 (トランスポート層)</h3>
<p>
TCP = Transmission Control Protocol
</p>

<ul>
<li> <strong>TCP層の役割:</strong> IP パケットをうまくつなぎ合わせて、長い 0/1 の列を送る。
<li> <strong>長所1:</strong> 長い情報を遠隔地のホストに送れる。
<li> <strong>長所2:</strong> 途中で紛失したパケットを自動的に再送させる。
<li> <strong>短所:</strong> 0/1 の列は送れるが、それ自体には意味がない。
</ul>

<p>
TCP 層によって、インターネット上のあるホストから別のホストに
「任意の長さの 0 と 1 の列」を送れるようになる。
</p>

<h3 id="internet-application">1.6. アプリケーション層</h3>
<p>
最後にアプリケーション層が、送られてきたデータを
ユーザにとって意味のある方法で利用する。
</p>
<ul>
<li> <strong>アプリケーション層の役割:</strong> インターネットを使ったアプリケーションを実現する。
(例: ブラウザ、LINE、ゲームなど)
<li> <strong>長所:</strong> 最終的にユーザにとって意味のある「インターネット」になる。
<li> <strong>短所:</strong> 悪意のある中継器がデータを盗聴・改竄してもわからない。
</ul>

<p>
最近では、この短所を解決するため、さらにこの上に TLS/SSL層などを導入することもある
(HTTPSなど)。
</p>

<h2 id="datalink">2. データリンク層のしくみ</h2>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" fill="#88ff88" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<ul>
<li> データリンク層:
  コンピュータに接続されている<u>ネットワーク インターフェイス</u>間で、
  直接的な通信をおこなう。
<li> 過去には、FDDI や Token Ring など、いろいろな方式があった。
<li> 現在ではおもに <u>イーサネット</u> (Ethernet) が使われている。<br>
  cf.
<a href="https://ja.wikipedia.org/wiki/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%AB%E3%83%BC%E3%83%89">イーサネットのインターフェイス</a>
<li> イーサネット は、各機器を
  <u>スイッチング・ハブ</u> (switching hub)
  または単に <u>スイッチ</u> あるいは <u>ハブ</u>
  と呼ばれる機器で接続する。<br>
  cf. <a href="https://www.reddit.com/r/networkingmemes/comments/eawgjn/when_your_kid_asks_for_a_switch_for_christmas/">クリスマスプレゼントに「スイッチ」をもらった子供</a>
</ul>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="400" height="80">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="10" y="10" />
      <use xlink:href="#computer" x="100" y="10" />
      <use xlink:href="#computer" x="190" y="10" />
      <use xlink:href="#computer" x="280" y="10" />
      <line x1="0" y1="5" x2="350" y2="5" />
      <line x1="35" y1="5" x2="35" y2="15" />
      <line x1="125" y1="5" x2="125" y2="15" />
      <line x1="215" y1="5" x2="215" y2="15" />
      <line x1="305" y1="5" x2="305" y2="15" />
    </g>
    <text x="350" y="40">ノード</text>
    <g style="font-size: 50%;">
      <g text-anchor="middle">
	<text x="35" y="70">aa-bb-cc-dd-ee-ff</text>
	<text x="125" y="70">11-22-33-44-55-66</text>
	<text x="215" y="70">a1-b2-c3-d4-e5-f6</text>
	<text x="305" y="70">6f-5e-4d-3c-b2-1a</text>
      </g>
    </g>
  </svg>
<div class="caption">イーサネット</div>
</div>
</div>

<h3 id="datalink-macaddr">2.1. 物理アドレス (MACアドレス)</h3>
<ul>
<li> イーサネットでは、接続されている各機器は「ホスト」ではなく
  「<u>ノード</u>」と呼ばれる。
<li> 各機器には固有の物理アドレス (<u>MACアドレス</u>) がついており、
  これはそのハードウェアの製造時に決まっている。
<li> MACアドレスは 48ビット (8ビット×6) で、
  <code>08-00-27-16-f3-c3</code> のように 6組の 16進数で表される。
<li> ひとつのネットワークインターフェイスにつき、ひとつの MACアドレスが存在する。
</ul>

<div class=exercise id="ex-mac-addr">
<div class=header>演習. MACアドレスを調べる</div>
<p>
自分のパソコンについている イーサネット の MAC アドレスを調べよ。
(複数のインターフェイスが接続されている場合、MAC アドレスは複数存在することがある。)
</div>

<h3 id="datalink-frame">2.2. Ethernetフレーム</h3>
<p>
イーサネット を使って別のノードにデータを送るときは、
以下のような順序で 0 と 1 を送ることになっている。
なぜか イーサネット では「パケット」ではなく
<u>フレーム</u> (frame) と呼ばれている。
</p>

<h4>Ethernet フレームの構造</h4>

<table border>
<tr>
<td class=bits>10101010</td>
<td>…</td>
<td class=bits>10101011</td>
<td class=bgb>送信先MACアドレス<br>(6バイト)</td>
<td class=bgy>送信元MACアドレス<br>(6バイト)</td>
<td>データ長<br>(2バイト)</td>
<td class=bgr>実際のデータ<br>(46〜1500バイト)</td>
<td class=bgg>CRC<br>(4バイト)</td>
<td class=bits>00000000</td>
</tr>
</table>

<ul>
<li> 最初の 010101... (56回) が以後のクロックの代わりになる。
<li> データ長は、直接指定される場合と、「パケットの種類」を指定する場合がある。
<li> 通常、イーサネット で一度に送れるフレームは最高 1500バイトまてである。
<li> CRC はエラー検査のために使われる。
</ul>

<p>
一般的に、このような決まりを <u>プロトコル</u> (Protocol, 規約) とよぶ。
</p>

<div class=exercise id="ex-ethernet-frame">
<div class=header>演習. Ethernetフレームの中身</div>
<p>以下の Ethernet フレームについて問いに答えよ:</p>
<blockquote><pre>
<span class=bgb>06 e6 76 53 06 c8</span> <span class=bgy>04 e6 76 53 06 c8</span> 00 05 <span class=bgr>11 22 33 44 55</span> <span class=bgg>aa bb cc dd</span>
</pre></blockquote>
  <ol type=a>
    <li> 送信元MACアドレスは何か?
    <li> 送信先MACアドレスは何か?
    <li> 実際のデータは何バイトか?
    <li> そのデータは何か?
    <li> CRCの値は何か?
  </ol>
</div>

<div class=exercise id="ex-eithernet-wireshark">
<div class=header>演習. Wireshark を使って Ethernet フレームの詳細を確認する</div>
<p>
<a target="_blank" href="https://www.wireshark.org/">Wireshark</a> を起動後にパケットキャプチャーを開始し、
各パケットの詳細パネルをクリックして イーサネット の送信元・送信先MACアドレスを確認せよ。
</p>
<div class=figure>
  <div>
<img src="wireshark.png" width="700" height="464">
<div class="caption">Wireshark</div>
</div>
</div>
</div>

<h3 id="datalink-virtual">2.3. 仮想インターフェイス</h3>
<p>
ふつう「ネットワークインターフェイス」といえば、
イーサネット などの物理的な接続口をさすが、最近ではソフトウェアによる
「仮想的な」ネットワークインターフェイスも存在する。
</p>
<ul>
<li> 仮想インターフェイスは、仮想マシンや VPN などで用いられる。
<li> 仮想インターフェイスの通信先は、別のコンピュータではなく、
  同一 PC 内の別のプロセスである。
</ul>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="310" height="95">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="50" y="35" transform="scale(0.75)" />
      <rect x="15" y="5" width="90" height="60" />
      <polygon points="20,70 0,90 120,90 100,70" />
      <path d="M90,45 l-20,0" />
      <path d="M90,25 l+100,0" />
      <path d="M190,25 l50,0" stroke-dasharray="2,2" />
      <circle r="5" cx="90" cy="45" fill="white" />
      <circle r="5" cx="90" cy="25" fill="white" />
    </g>
    <g style="font-size: 75%;">
      <text x="110" y="15">(本物の)インターフェイス</text>
      <text x="110" y="50">仮想インターフェイス</text>
    </g>
  </svg>
<div class="caption">本物のインターフェイスと仮想インターフェイス</div>
</div>
</div>

<div class=exercise id="ex-virtual-interface">
<div class=header>演習. 仮想インターフェイスを確認する</div>
<p>自分の PC についている仮想インターフェイスはあるか?
<code>ifconfig</code> コマンドで確認せよ。</p>
<blockquote><pre>
$ <strong>ifconfig</strong>
</pre></blockquote>
</div>

<h2 id="ip">3. IP層 (ネットワーク層) のしくみ</h2>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" fill="#88ff88" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<p>
データリンク層の機能を使うと、小口のデータを信頼できる方法で
隣の (直接接続されている) ホストに送信できることがわかった。
データリンク層では基本的にどんなデータを送ってもよいが、
たいていは <u>IPパケット</u> の内容が送られている。
これをバケツリレー式に転送していくのが IP層 (ネットワーク層) の役割である。
</p>

<table border>
<tr>
<td class=bits>10101010</td>
<td>…</td>
<td class=bits>10101011</td>
<td>送信元MACアドレス</td>
<td>送信先MACアドレス</td>
<td>データ
長</td>
<td class=bgg>IPパケット</td>
<td>CRC</td>
<td class=bits>00000000</td>
</tr>
</table>

<h4>IP パケットの構造:</h4>
<table border>
<tr>
<th>バイト</th>
<th style="width:8em;">0</th>
<th style="width:8em;">1</th>
<th style="width:8em;">2</th>
<th style="width:8em;">3</th>
</tr>
<tr>
<th>0</th>
<td align=center>バージョン/ヘッダ長</td>
<td align=center>タイプ</td>
<td class=bgr align=center colspan="2">IPパケット長</td>
</tr>
<tr>
<th>4</th>
<td align=center colspan="2">識別子</td>
<td align=center colspan="2">フラグ</td>
</tr>
<tr>
<th>8</th>
<td align=center>TTL</td>
<td align=center>プロトコル番号</td>
<td align=center colspan="2">チェックサム</td>
</tr>
<tr>
<th>12</th>
<td class=bgb align=center colspan="4">送信元IPアドレス</td>
</tr>
<tr>
<th>16</th>
<td class=bgy align=center colspan="4">送信先IPアドレス</td>
</tr>
<tr>
<th>20</th>
<td align=center colspan="3">オプション</td>
<td align=center>パディング</td>
</tr>
<tr>
<th>24</th>
<td align=center colspan="4">実際のデータ<br>…</td>
</tr>
</table>

<div class=exercise id="ex-ip-packet">
<div class=header>演習. IPパケットの中身</div>
<p>
以下の<span class=bgg>緑色部分</span>はイーサネット フレームに含まれる
実際の IPパケットを表したものである。
上の図を参考にして、以下の情報を求めよ:
</p>
<blockquote><pre>
0000 94 09 37 28 5b d5 00 23 81 1a f2 8d 08 00 <span class=bgg>45 00
0010 <span class=bgr>00 34</span> 6b 7f 40 00 80 06 00 00 <span class=bgb>c0 a8 00 0c</span> <span class=bgy>c0 a8</span>
0020 <span class=bgy>01 01</span> c9 34 00 17 25 d0 1e c0 00 00 00 00 80 02
0030 20 00 82 84 00 00 02 04 05 b4 01 03 03 08 01 01
0040 04 02</span>
</pre></blockquote>
<ol type=a>
<li> 送信元 IPアドレス
<li> 送信先 IPアドレス
<li> IP パケットの大きさ
</ol>
</div>

<div class=exercise id="ex-ip-wireshark">
<div class=header>演習. Wireshark を使って IPパケットの中身を観察する</div>
<p>
Wireshark を起動後、パケットキャプチャーを開始し、
フィルタバーに <code>ip</code> と入力せよ。
各パケットをクリックして送信元・送信先のIPアドレスを確認せよ。
</p>
</div>

<h3 id="ip-addr">3.1. IPアドレス</h3>
<p>
すべての IPパケットには、送信元・送信先のIPアドレスがついている。
これはふつう 4つの 8ビット数 (0〜255) の組として表記する。
</p>
<ul>
<li> <code>127.0.0.1</code>
<li> <code>58.158.55.222</code>
<li> <code>255.255.255.255</code>
<li> <code>343.45.687.90</code> (間違い)
</ul>

<div class=notice>
注意:
MACアドレスが通常ハードウェアごとに固有なのに対して、
IPアドレスは変化することがある。
</div>

<div class=exercise id="ex-ip-addr">
<div class=header>演習. 自分のIPアドレスを調べる</div>
<p>
自分のパソコンについている IP アドレスを調べよ。
(複数のインターフェイスが存在する場合、
ひとつの PC が複数の IP アドレスを名乗っていることがある。)
</p>
</div>

<div class=exercise id="ex-ping">
<div class=header>演習. ping コマンドを使う</div>
<p>
<code>ping</code> コマンドは、与えられた IP アドレスの
ホストが起動しているか (IP パケットに応答できるか) 否かを調べるものである。
以下のホストに <code>ping</code> コマンドを実行して、
応答があるかどうかを確認せよ:
</p>
<blockquote><pre>
$ <strong>ping <em>自分のIPアドレス</em></strong>
$ <strong>ping 127.0.0.1</strong>
$ <strong>ping 192.0.2.1</strong>
$ <strong>ping 1.1.1.1</strong>
</pre></blockquote>
</div>

<h4>IPアドレスはどうやって決まるのか</h4>
<p>
MACアドレスは通常固定なのに対し、IPアドレスは可変である。
IPアドレスがなければ、そもそも IP層を使って通信できないため、
すべての PC は起動時に IPアドレスを決定する必要がある。
現在、IPアドレスを決める方法はおもに 3通り存在する:
</p>

<ol type=a>
<li> 手動で設定する … OSの設定画面等から。
<li> <u>PPPoE</u> を使ってサーバから取得する …
光ファイバーなどで ISP と 1:1 接続されているときに使う方法。
おもに接続用モデムが IPアドレスを取得するときに使う。
<li> <u>DHCP</u> を使って取得する …
複数の PC がイーサネットに接続されているときに使う方法。
ほとんどの家庭・企業ではこの方法を使っている。
</ol>

<h4>DHCPとは</h4>
<ul>
<li> ネットワーク上に「DHCPサーバ」と呼ばれる機器を用意しておき、
イーサネットのブロードキャスト機能を使って IPアドレスを取得する。
<li> サーバは決められた範囲
  (例. <code>192.168.1.100</code> 〜 <code>192.168.1.199</code> など)
  のアドレスの中から、一定時間使われていないものを選ぶ。
<li> たいていの家庭用ルータには DHCP サーバが内蔵されている。
</ul>

<div class=exercise id="ex-dhcp-addr">
<div class=header>演習. DHCP で供給された IPアドレスを調べる</div>
<p>
家庭用ルータの設定画面にログインし、DHCPアドレスの範囲を調べよ。
そのルータを使っているデバイスの IP アドレスを調べ、
指定する範囲内にあることを確認せよ。
</p>
</div>

<h3 id="ip-routing">3.2. ルーティング</h3>
<p>
IPパケットは、ふつう複数のコンピュータを中継して送信される。
</p>
<ul>
<li> このような中継処理を「<u>ルーティング</u> (routing)」と呼ぶ。
<li> そのためのコンピュータを「<u>ルータ</u> (router)」と呼ぶ。
</ul>

<p>
(注意: 米国英語の "route" / "router" はどちらかというと
「ラウト」「ラウター」に近い発音だが、ここでは日本語の慣例にならって
「ルート」「ルーティング」と表記する。)
</p>
<p>
ルータは受けとったパケットをいったんメモリに保管し、
適切な送り先に向けて送信する。
</p>

<h4>家庭用ルータ</h4>
<p>
1つの回線 (ISP) からくるパケットを複数台のPCに転送する。
たいていの家庭用ルータには、単なるルーティング機能に加えて、後述する
ファイヤウォール、NAT、DHCPサーバ およびウェブサーバなどの機能が搭載されている。
</p>

<h4>業務用ルータ</h4>
<p>
複数の基幹回線とつながっており、ISPなどで使われる。
<a target="_blank" href="https://www.cisco.com/c/en/us/products/routers/8000-series-routers/index.html">Cisco 8000</a>
など。
10Tbps〜200Tbps の処理能力があり、非常に高価。
</p>

<h4>ルーティングは難しい</h4>

<p>
MACアドレスは各機器に固有なのに対して、
IPアドレスは各ホストが「勝手に名乗っているだけ」であり、しかもつねに変化している。
つまりルータは世界のどこにいるかわからないホストに対して、
IPパケットを送らなければならない。
しかも、インターネットの正確な全体像はわからない。
</p>
<div class=nop>
<ul>
<li> <a target="_blank" href="https://personalpages.manchester.ac.uk/staff/m.dodge/cybergeography/atlas/topology.html">Atlas of Cyberspaces</a>
<li> <a target="_blank" href="https://www.opte.org/the-internet">The Internet 1997 - 2021</a>
</ul>
</div>

<h3 id="ip-cidr">3.3. CIDR 方式</h3>
<p>
小さな組織 (自宅・会社・学校) で、ネットワークが
階層構造 (ツリー構造) になっているときに使える方法。
</p>
<p>
各ホストは、<u>ルーティングテーブル</u>と呼ばれる情報を持っている。
ここには以下のようなルールが記載されている:
</p>

<blockquote><pre>
if 送り先 が ある範囲の IPアドレスならば
    インターフェイス1を使う
else if 送り先 が ある範囲の IPアドレスならば
    インターフェイス2を使う
...
else
    インターフェイスNを使う
</pre></blockquote>

<p>
ここでいう「ある範囲の IPアドレス」のことを、
サブネットワークまたは <u>サブネット</u> (subnet) という。
</p>

<h4>末端のホストの場合:</h4>
<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="350" height="120">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="60" y="0" />
      <use xlink:href="#computer" x="10" y="60" />
      <use xlink:href="#computer" x="100" y="60" />
      <use xlink:href="#computer" x="190" y="60" />
      <line x1="0" y1="55" x2="260" y2="55" />
      <line x1="35" y1="65" x2="35" y2="55" />
      <line x1="125" y1="65" x2="125" y2="55" />
      <line x1="215" y1="65" x2="215" y2="55" />
      <line x1="85" y1="45" x2="85" y2="55" />
    </g>
    <g style="font-size: 80%;">
      <text x="110" y="20">ルータ</text>
      <text x="110" y="40">192.168.1.1</text>
      <text x="270" y="60">192.168.1.0</text>
      <text x="250" y="90">末端のホスト</text>
      <g text-anchor="middle">
	<text x="35" y="120">192.168.1.2</text>
	<text x="125" y="120">192.168.1.3</text>
	<text x="215" y="120">192.168.1.4</text>
      </g>
    </g>
  </svg>
<div class="caption">サブネット 192.168.1.0 に接続されているホスト</div>
</div>
</div>

<p>
末端のホストは、ひとつのサブネットに接続している。
これは次のような方法でIPパケットを転送する:
</p>
<ul>
<li> もし、送り先IPアドレスが <strong>自分と同じサブネット上にある</strong> 場合は、
直接そのホストに送る。
<li> もし、送り先IPアドレスが <strong>それ以外</strong> の場合は、
デフォルトのルータ (ゲートウェイ) に送る。
</ul>

<div class=figure>
<div>
<img src="netcpl.png" width="482" height="279">
<div class="caption">macOSにおけるTCP/IPの設定</div>
</div>
</div>

<h4>ルータの場合:</h4>
<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="350" height="120">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="40" y="-5" />
      <use xlink:href="#computer" x="120" y="60" />
      <line x1="0" y1="115" x2="260" y2="115" />
      <line x1="0" y1="50" x2="260" y2="50" />
      <line x1="145" y1="105" x2="145" y2="115" />
      <line x1="145" y1="65" x2="145" y2="50" />
      <line x1="65" y1="40" x2="65" y2="50" />
    </g>
    <g style="font-size: 80%;">
      <text x="125" y="90" text-anchor="end">ルータ</text>
      <text x="170" y="100">192.168.1.1</text>
      <text x="170" y="80">192.168.2.2</text>
      <text x="270" y="120">192.168.1.0</text>
      <text x="270" y="50">192.168.2.0</text>
      <text x="45" y="20" text-anchor="end">ルータ</text>
      <text x="90" y="15">10.0.1.2</text>
      <text x="90" y="35">192.168.2.1</text>
    </g>
  </svg>
  <div class="caption">ルータが2つのサブネットを中継する</div>
  </div>
</div>

<p>
ルータは 2つ以上のサブネットに接続しており、
少なくとも<strong>2つのIPアドレス</strong>を持っている。
ルータは次のような方法でIPパケットを転送する:
</p>

<ul>
<li> 送り先IPアドレスが、
  <strong>自分に接続されているサブネットのいずれかに所属する</strong>場合は、
  そのサブネットに送る。
<li> <strong>それ以外</strong>の場合は、
デフォルトのルータ (ゲートウェイ) に送る。
</ul>

<!--
<h4>イーサネット のブロードキャストと ARP</h4>
<p>
イーサネット の送信先アドレスとして、
<code>ff-ff-ff-ff-ff-ff</code> という MAC アドレスを使うと、
ハブにつながっているすべてのノードに対して送信したことになる
(ブロードキャスト)。
イーサネット 上の各ノードは、
一定時間ごとに、ARP (Address Resolution Protocol) と呼ばれるパケットを
イーサネット の全ノード対して送る。ここには、そのノードの MAC アドレスと、
そのコンピュータの IP アドレスが含まれており、各ホストは
その情報を覚えておいて IP パケット送信時に使う。
</p>
-->

<h4>サブネット・マスクとネットワーク・アドレス</h4>
<p>
あるIPアドレスが特定の「サブネット」に所属しているかどうかは、
以下のようにして決定する:
</p>

<ol>
<li> そのIPアドレスを 32ビットの 2進数表記にする。
<li> <u>サブネット・マスク</u>
 (subnet mask あるいは netmask) の 32ビット値と AND をとる。<br>
  (つまり、マスクが 0 になっている部分のビットを無視する)<br>
  残ったアドレスを IPアドレスの <u>ネットワーク・アドレス</u> (network address) と呼ぶ。
<li> 2つの IP アドレスのネットワーク・アドレスが等しければ、
  それらは同一のサブネットに所属する。
</ol>

<table border><tr>
<th>IP アドレス</th>
<td><code>11110000 10101000 00000001 00000010</code></td>
<td>(192.168.1.2)</td>
</tr><tr>
<th>サブネット・マスク</th>
<td><code>11111111 11111111 11111111 00000000</code></td>
<td>(255.255.255.0)</td>
</tr><tr>
<th>ネットワーク・アドレス</th>
<td><code>11110000 10101100 00000001 00000000</code></td>
<td>(192.168.1.0)</td>
</tr></table>

<p>
通常、サブネット・マスクは IP アドレスと同様に表記する。
しかし、単に 1の個数を「<code>/24</code>」のように表すことも多い。
</p>

<ul>
<li> 表記1 … <code>255.255.255.0</code>
<li> 表記2 … <code>/24</code>
</ul>

<div class=formula>
基本的には、IPアドレスの先頭部分がネットワーク・アドレスである。
</div>

<div class=exercise id="ex-network-addr">
<div class=header>演習. ネットワークアドレスを求める</div>
<p>
以下の IP アドレスに対するネットワークアドレスを求めよ:
</p>
<ol type=a>
<li> <code>10.0.1.3/8</code>
<li> <code>128.122.100.181/16 (255.255.0.0)</code>
<li> <code>192.168.1.9/24 (255.255.255.0)</code>
<li> <code>166.84.7.55/30 (255.255.255.252)</code>
</ol>
</div>

<div class=exercise id="ex-routing">
<div class=header>演習. ルーティングテーブルの実装</div>
<p>
あるルータが以下のIPアドレスをもっている。
これらは2つのサブネットに接続しており、
そのうちのひとつはデフォルト・ゲートウェイである。
</p>
<ul>
<li> IPアドレス1 : <code>10.0.2.2/16</code> (サブネットA)
<li> IPアドレス2 : <code>192.168.3.1/24</code> (サブネットB)
<li> デフォルト・ゲートウェイ : <code>10.0.2.1</code>
</ul>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="350" height="120">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="40" y="-5" />
      <use xlink:href="#computer" x="120" y="60" />
      <line x1="0" y1="115" x2="260" y2="115" />
      <line x1="0" y1="50" x2="260" y2="50" />
      <line x1="145" y1="105" x2="145" y2="115" />
      <line x1="145" y1="65" x2="145" y2="50" />
      <line x1="65" y1="40" x2="65" y2="50" />
    </g>
    <g style="font-size: 80%;">
      <text x="90" y="15">デフォルト・ゲートウェイ</text>
      <text x="90" y="35">10.0.2.1</text>
      <text x="125" y="90" text-anchor="end">ルータ</text>
      <text x="170" y="80">10.0.2.2</text>
      <text x="170" y="100">192.168.3.1</text>
      <text x="270" y="50">サブネットA</text>
      <text x="270" y="120">サブネットB</text>
    </g>
  </svg>
</div>
<p>
以下のIPパケットが来た場合、ルータはパケットを
どのように転送すればよいか?
</p>
<ol type=a>
<li> 送信元: <code>10.0.3.4</code> → 送信先: <code>192.168.3.2</code>
<li> 送信元: <code>192.168.3.3</code> → 送信先: <code>10.0.3.1</code>
<li> 送信元: <code>192.168.3.3</code> → 送信先: <code>10.1.3.1</code>
</ol>
</div>

<h3 id="ip-wan">3.4. 広域レベルのルーティング</h3>
<p>
ネットワークがさらに複雑な場合、
もはや単純な規則では行き先を決定できない。
このような広域用のルータは、インターネットの「地図」のようなもの
(ルーティング情報) を持っている。
これはつねに変化するため、たえず更新されている。
(ちなみに、この情報も TCP/IP ネットワーク自身を使って送られる。)
</p>

<h4>リンク・ステート方式 (Link state routing)</h4>
<p>
中規模の組織で利用される。各ルータは、ネットワーク上のホストが
どのように接続されているか定期的に調査し、ネットワークの「地図」を作成する。
ここから各ホスト間の最短経路を計算する。
</p>

<div class=figure>
<div>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="220" height="220">
<g transform="translate(10,10)">
<g fill="none" stroke="black" stroke-width="2">
 <line x1="153" y1="144" x2="149" y2="37" />
 <line x1="153" y1="144" x2="76" y2="171" />
 <line x1="85" y1="71" x2="76" y2="171" />
 <line x1="153" y1="144" x2="85" y2="71" />
 <line x1="190" y1="190" x2="149" y2="37" />
 <line x1="10" y1="10" x2="34" y2="50" />
 <line x1="76" y1="171" x2="34" y2="50" />
 <line x1="190" y1="190" x2="153" y2="144" />
 <line x1="190" y1="190" x2="76" y2="171" />
 <line x1="10" y1="10" x2="22" y2="105" />
 <line x1="149" y1="37" x2="34" y2="50" />
 <line x1="10" y1="10" x2="149" y2="37" />
 <line x1="85" y1="71" x2="34" y2="50" />
</g>
<g fill="white" stroke="black">
 <circle cx="10" cy="10" r="4" />
 <circle cx="22" cy="105" r="4" />
 <circle cx="34" cy="50" r="4" />
 <circle cx="76" cy="171" r="4" />
 <circle cx="85" cy="71" r="4" />
 <circle cx="149" cy="37" r="4" />
 <circle cx="153" cy="144" r="4" />
 <circle cx="190" cy="190" r="4" />
</g>
<g text-anchor="middle">
<g fill="blue" style="font-weight:bold;">
<text x="0" y="10">A</text>
<text x="20" y="125">B</text>
<text x="30" y="70">C</text>
<text x="70" y="190">D</text>
<text x="85" y="65">E</text>
<text x="160" y="30">F</text>
<text x="135" y="145">G</text>
<text x="200" y="200">Z</text>
</g>
<text x="10" y="67">4</text>
<text x="25" y="30">2</text>
<text x="45" y="105">8</text>
<text x="59" y="65">2</text>
<text x="75" y="121">5</text>
<text x="79" y="23">7</text>
<text x="91" y="43">4</text>
<text x="119" y="100">4</text>
<text x="114" y="157">4</text>
<text x="133" y="178">3</text>
<text x="145" y="90">5</text>
<text x="173" y="165">5</text>
<text x="175" y="113">7</text>
</g>
</g>
</svg>
<div class="caption">リンク・ステート方式で作成される地図の一例</div>
</div>
</div>

<h4>経路ベクトル方式 (Path vector routing)</h4>
<p>
さらに大規模なルーティングに使われる方式。
インターネットを各自律システム (<u>Autonomous System</u>, AS) に分け、
AS 間での経路情報を交換する。世界には約5万のASがあり、相互に協力している。
</p>

<ul class=nop>
<li> <a target="_blank" href="http://www.topology-zoo.org/explore.html">各ASの物理的な配線</a>
<li> <a target="_blank" href="https://www.cidr-report.org/as2.0/">全世界におけるAS情報</a>
<li> <a target="_blank" href="https://atlas.ripe.net/results/maps/">RIPE Atlas</a>
</ul>

<p>
各ASは <u>BGP</u> (Border Gateway Protocol) という手順で
「このネットワークはこっち」という経路情報を交換している。
しかし全インターネットの正確な地図を把握できるわけではなく
「だいたいこっちの方に送れば正しいだろう」程度の情報しかわからない。
</p>

<h4>大規模なルータに要求される性能</h4>
<ul>
 <li> 1Tbps = 毎秒100Gバイト消費。
 <li> 最高30秒間保持する = 3Tバイトのメモリが必要。
 <li> 1パケット 1000バイトとすると、毎秒 1Gパケット。
 <li> 毎秒1G回: 32ビットアドレスを照合 (32Gバイトのメモリ比較)。
 <li> 絶対に止まってはいけない。
</ul>
<p>
業務用ルータ1台は、通常のパソコン数百台分の性能をもっている。
アドレスの照合のために、TCAMという特別なメモリが使われている。
</p>

<div class=exercise id="ex-traceroute">
<div class=header>演習. 広域ルーティングの実際</div>
<p>
ニューヨークに存在する、とあるサーバの IP アドレスは 166.84.7.55 である。
<code>traceroute</code> コマンド (Windows の場合は、<code>tracert</code> コマンド) を使って、
ここに行くまでの経路を調べよ。
</p>
<p>macOS/Linuxの場合:</p>
<pre>
$ <strong>traceroute 166.84.7.55</strong>
</pre>
<p>Windowsの場合:</p>
<pre>
C:\&gt; <strong>tracert 166.84.7.55</strong>
</pre>
</div>


<h2 style="margin-top:4em;" id="tcp">4. TCP層 (トランポート層) のしくみ</h2>

<div class=exercise id="ex-1">
<div class=header>演習. 前回までのおさらい</div>
<ul>
<li> インターネットでは、情報は小さな
  <nobr><span class=bl>パケット</span></nobr>に分けて送信される。
<li> インターネットに接続されているコンピュータはすべて
  <nobr><span class=bl>IPアドレス</span></nobr>という固有の識別符号がついている。
<li> パケットは、<nobr><span class=bl>ルータ</span></nobr>と呼ばれる機器によって中継され、
  目的のホストに到達する。
<li> イーサネット や WiFi は <nobr><span class=bl>データリンク</span></nobr>層の一種で、
  近距離 (オフィス内など) の通信に使われる規格である。
</ul>
</div>

<p>
IP層の機能を使うと、世界の離れた場所にパケットを送ることができる。
しかし…
</p>
<ul>
<li> <strong>衝撃の事実:</strong> パケットがつねに正しく送られる保証はない。
</ul>

<p>
各ルータはパケット正しく送るよう精一杯努力するが、これは
<strong>ベストエフォート方式</strong> (がんばったら、結果がダメでも許してもらえる)
にすぎない。
そこで、信頼性のない IPパケットをうまく使って、
<strong>信頼できる、長い 0/1 の列</strong> を送る仕組みを作る。
これが TCP 層である。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" fill="#88ff88" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<p>
TCP層までくると、2つのホストは連続した通信ができるので、
これはもはやパケット交換ではなく、仮想的な1本の線とみなせる。
</p>
<ul>
<li> 各ホストは最大 65,536本までの<u>仮想回線</u>を持つことができる。
<li> 各仮想回線は <u>ポート番号</u> によって区別される。
</ul>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="140">
    <defs>
    <symbol id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </symbol>
    </defs>
    <g transform="translate(5,15)">
      <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="40" />
      <use xlink:href="#computer" x="190" y="40" />
      <path d="M40,60 L60,10"/>
      <path d="M40,60 L60,30"/>
      <path d="M40,60 L60,50"/>
      <path d="M40,60 L60,70"/>
      <path d="M40,60 L60,90"/>
      <path d="M40,60 L60,110"/>
      <path d="M200,60 L180,10"/>
      <path d="M200,60 L180,30"/>
      <path d="M200,60 L180,50"/>
      <path d="M200,60 L180,70"/>
      <path d="M200,60 L180,90"/>
      <path d="M200,60 L180,110"/>
      <circle cx="60" cy="10" r="4" />
      <circle cx="60" cy="30" r="4" />
      <circle cx="60" cy="50" r="4" />
      <circle cx="60" cy="70" r="4" />
      <circle cx="60" cy="90" r="4" />
      <circle cx="60" cy="110" r="4" />
      <circle cx="180" cy="10" r="4" />
      <circle cx="180" cy="30" r="4" />
      <circle cx="180" cy="50" r="4" />
      <circle cx="180" cy="70" r="4" />
      <circle cx="180" cy="90" r="4" />
      <circle cx="180" cy="110" r="4" />
    </g>
    <g stroke-width="2" fill="none" stroke-dasharray="4,4">
      <path d="M60,30 L180,70" stroke="red" />
      <path d="M60,110 L180,30" stroke="blue" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="25" y="90" dy="0.5em">ホスト</text>
      <text x="60" y="-5" dy="0.5em">ポート</text>
      <text x="215" y="90" dy="0.5em">ホスト</text>
      <text x="180" y="-5" dy="0.5em">ポート</text>
    </g>
    <g fill="red" style="font-size: 75%;">
      <text x="65" y="20" dy="0.5em">134</text>
      <text x="175" y="75" dy="0.5em" text-anchor="end">8962</text>
    </g>
    <g fill="blue" style="font-size: 75%;">
      <text x="65" y="115" dy="0.5em">65535</text>
      <text x="175" y="20" dy="0.5em" text-anchor="end">134</text>
    </g>
    </g>
  </svg>
  <div class=caption>TCP層におけるポートと仮想回線</div>
  </div>
</div>

<h3 id="tcp-details">4.1. TCPの詳細</h3>

<p>
TCP層は IP層を利用している。
つまり IPパケットの中に、さらに
TCPパケット (<u>TCPセグメント</u>) を入れる。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="170">
    <g transform="translate(5,5)">
    <g stroke="black" stroke-width="2" fill="white">
      <rect x="0" y="0" width="240" height="160" />
      <rect x="30" y="30" width="200" height="120" />
      <rect x="60" y="60" width="160" height="80" fill="#88ff88" />
      <rect x="90" y="90" width="120" height="40" />
    </g>
    <g style="font-size: 80%;">
      <text x="5" y="10" dy="0.5em">Ethernetフレーム</text>
      <text x="35" y="40" dy="0.5em">IPパケット</text>
      <text x="65" y="70" dy="0.5em">TCPセグメント</text>
      <text x="95" y="100" dy="0.5em">アプリケーション</text>
      <text x="95" y="115" dy="0.5em">データ</text>
    </g></g>
  </svg>
</div>

<h4>TCP セグメントの構造</h4>
<table border>
<tr>
<th></th>
<th style="width:8em;">0</th>
<th style="width:8em;">1</th>
<th style="width:8em;">2</th>
<th style="width:8em;">3</th>
</tr>
<tr>
<th>0</th>
<td class=bgb align=center colspan="2">送り元ポート</td>
<td class=bgy align=center colspan="2">送り先ポート</td>
</tr>
<tr>
<th>4</th>
<td class=bgr align=center colspan="4">シーケンス番号</td>
</tr>
<tr>
<th>8</th>
<td class=bgg align=center colspan="4">確認応答(ACK)番号</td>
</tr>
<tr>
<th>12</th>
<td align=center colspan="2">フラグ</td>
<td align=center colspan="2">ウィンドウサイズ</td>
</tr>
<tr>
<th>16</th>
<td align=center colspan="2">チェックサム</td>
<td align=center colspan="2">緊急ポインタ</td>
</tr>
<tr>
<th>20</th>
<td align=center colspan="4">オプション</td>
</tr>
<tr>
<th>24</th>
<td align=center colspan="4">実際のデータ<br>…</td>
</tr>
</table>

<ul>
<li> 各回線は、セグメント中の <u>送り元ポート番号</u> と
  <u>送り先ポート番号</u> により区別する。
<li> 長いデータの各部分は、
  <u>シーケンス番号</u> (sequence number) と
  <u>確認応答番号</u> (acknowledge number)
により区別する。
</ul>

<h4>シーケンス番号と確認応答番号</h4>
<p>
TCP では通信はつねに双方向である。
2つのホストは (たとえ送るデータがないときでも)
つねに次の情報を相手に送っている:
</p>

<ul>
<li> シーケンス番号 (<u>seq</u>) … 「ここまで送った」という位置。
<li> 確認応答番号 (<u>ack</u>) … 「ここまで受けとった」という位置。
</ul>

<p>
seq, ack はそれぞれ送った (受けとった) データのバイト数に応じて増加する:
</p>

<table border><tr>
<th>ホストA</th><th>ホストB</th>
</tr><tr>
<td class="bgb">[seq=<u>1</u>, ack=1, (10バイト)] →<br>seq +10</td>
<td>ack +10</td>
</tr><tr>
<td>ack +5</td>
<td class="bgr">← [seq=1, ack=<u>11</u>, (5バイト)]<br>seq +5</td>
</tr><tr>
<td class="bgb">[seq=<u>11</u>, ack=<u>6</u>, (0バイト)] →<br>seq +0</td>
<td>ack +0</td>
</tr><tr>
<td>ack +3</td>
<td class="bgr">← [seq=<u>6</u>, ack=<u>11</u>, (3バイト)]<br>seq +3</td>
</tr><tr>
<td class="bgb">[seq=<u>11</u>, ack=<u>9</u>, (1バイト)] →<br>seq +1</td>
<td>ack +1</td>
</tr><tr>
<td>ack +0</td>
<td class="bgr">← [seq=<u>9</u>, ack=<u>12</u>, (0バイト)]<br>seq +0</td>
</tr></table>

<p>
送り側は、確認応答が来なかったら、以前に送ったパケットを再送信する。
</p>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="350" height="88">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="0" />
      <use xlink:href="#computer" x="300" y="0" />
      <line x1="60" y1="32" x2="290" y2="32" />
      <rect x="100" y="2" width="30" height="20" fill="#88ffff" />
      <rect x="150" y="2" width="30" height="20" fill="#88ffff" />
      <rect x="200" y="2" width="30" height="20" fill="#88ffff" stroke-dasharray="2,2" />
      <rect x="250" y="2" width="30" height="20" fill="#88ffff" />
      <rect x="180" y="42" width="30" height="20" fill="#ffbbff" />
      <rect x="130" y="62" width="30" height="20" fill="#ffbbff" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="90" x2="70" y1="12" y2="12" />
        <line x1="220" x2="240" y1="52" y2="52" />
        <line x1="170" x2="190" y1="72" y2="72" />
      </g>
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="115" y="12" dy="0.5em">1</text>
      <text x="165" y="12" dy="0.5em">8</text>
      <text x="215" y="12" dy="0.5em">13</text>
      <text x="265" y="12" dy="0.5em">29</text>
      <text x="195" y="52" dy="0.5em">1</text>
      <text x="145" y="72" dy="0.5em">8</text>
    </g>
  </svg>
  <div class="caption">失われたパケット (13)</div>
  </div>
</div>

<h4>TCP SYN パケットとハンドシェイク</h4>
<p>
TCP 通信は、開始時に特別な処理をおこなう。
この処理を <a target="_blank" href="https://ja.wikipedia.org/wiki/3%E3%82%A6%E3%82%A7%E3%82%A4%E3%83%BB%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF">3ウェイ・ハンドシェイク</a> と呼び、
<u>TCP SYN</u> という目印のついたパケットが使われる。
</p>
<ol>
<li> 送り側が TCP SYN パケットを送る。
<li> 受け側が TCP SYN+ACK パケットを送る。<br>
<strong>注意:</strong> ここでいう「ACKパケット」は、
確認応答(ack)番号とは別である。
<li> 送り側が TCP ACK パケットを送る。
<li> 送り側、受け側ともに seq=1, ack=1 で通信を始める。
</ol>

<p>
ハンドシェイクが完了すると、2つのホスト間は仮想回線で結ばれた状態となり (<u>接続</u>状態)、
双方向の通信が可能となる。ひとつの仮想回線では、次のものが決まっている:
</p>
<ul>
<li> ホストAのIPアドレス
<li> ホストAのTCPポート
<li> ホストBのIPアドレス
<li> ホストBのTCPポート
</ul>

<h3 id="tcp-client-server">4.2. 「クライアント」と「サーバ」</h3>
<p>
IP層においては、すべてのホストはパケットを送受信するという意味で等価であった。
</p><p>
TCP層の通信では、必ず2種類の役割が存在する:
</p>
<ul>
<li> TCP<u>クライアント</u> (TCP SYN を送り、<strong>通信を開始する側</strong>)
  … 客。いつサーバに電話をかけてもよい。
<li> TCP<u>サーバ</u> (TCP SYN を送られる側)
  … 店。いつクライアントから電話がかかってきてもいいように、
  24時間待機していなければならない。
</ul>

<p>
TCPサーバは、特定のTCPポートに TCP SYN が送られるかどうかを
ずっと監視していなければならない。このような状態を
「<u>Listen</u> (待ち受け) 状態」という。
</p>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="400" height="70">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="white" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use x="20" y="5" xlink:href="#computer" />
      <use x="320" y="5" xlink:href="#computer" />
      <path d="M320,25 l-10,10 l0,-20 l10,10 l10,0" />
      <path d="M70,25 l230,0" stroke-width="4" marker-end="url(#arrow)" />
    </g>
    <g text-anchor="middle" style="font-size:80%;">
      <text x="45" y="60">クライアント</text>
      <text x="345" y="60">サーバ</text>
      <text x="190" y="40">接続する</text>
      <text x="310" y="10">Listen</text>
    </g>
  </svg>
  <div class="caption">クライアントからサーバへの「接続」</div>
  </div>
</div>

<div class=notice>
注意:
ここでいう「クライアント」「サーバ」は、あくまで特定の動きをするソフトウェア (プロセス) のことであり、
<strong>物理的なクライアントやサーバマシンとは関係ない。</strong>
実際、ひとつのPC上にクライアント (プロセス) とサーバ (プロセス) が同時に存在することもある。
</div>

<div class=exercise id="ex-client-server">
<div class=header>演習. クライアントとサーバ</div>
<p>
自分のPC上で動いているTCPクライアント、TCPサーバを表示してみよう。
<p>
Linuxの場合:
<pre>
$ <strong>netstat -n -a -t -p</strong>
</pre>
<p>
macOSの場合:
<pre>
$ <strong>lsof -n -P -iTCP</strong>
</pre>
</div>

<h4>TCPサーバ側の手順:</h4>
<ol>
<li> 特定のTCPポート (たとえば80番) を Listen状態にする。
<li> TCPクライアントが (そのポートに対して) TCP SYN を送ってくるのを待つ。
<li> TCP SYN が送られてきたらハンドシェイクを開始する。
<li> ハンドシェイクが成功すると、TCP接続が <u>Established</u> (確立された) 状態になる。
<li> 以後、そのクライアントと双方向で通信する。
<li> TCP RST パケットが送られてきたら、通信を終了する。
</ol>

<h4>TCPクライアント側の手順</h4>
<ol>
<li> 通信したいサーバの IPアドレス と TCPポート番号 を選ぶ。
<li> そのサーバの特定のポートに向けて TCP SYN を送り、TCPハンドシェイクをおこなう。<br>
 (宛先の IPアドレス や TCPポート番号が間違っていた場合、
  その通信は<u>タイムアウト</u>するか、接続拒否 (<u>Rejected</u>)
  エラーとなる。)
<li> ハンドシェイクが成功すると、TCP接続が Established (確立された) 状態になる。
<li> 以後、サーバと双方向で通信する。
<li> 通信を終了したい場合は TCP RST パケットを送る。
</ol>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="90" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション</text>
      <text x="60" y="60" dy="0.5em">ネットワーク</text>
      <text x="60" y="75" dy="0.5em">スタック</text>
      <text x="60" y="90" dy="0.5em">(OS)</text>
    </g></g>
  </svg>
</div>

<p>
TCP 層の機能は、現代のほとんど OS にデフォルトで搭載されている。
そのためアプリケーション側は「どのポートを listen したいか」
「どのポートに接続したいか」を指定するだけでよい。
</p>

<div class=exercise id="ex-tcp-connection">
<div class=header>演習. TCP 接続を使って通信してみる</div>
<ol>
<li> まず、サーバ側の PC とクライアント側の PC を用意する
(どちらも仮想マシンでよい)。
<li> サーバ側PCで、以下のコマンドを実行する:
<blockquote><pre>
$ <strong>nc -l 10000</strong>
</pre></blockquote>
<li> クライアント側PCで、以下のコマンドを実行する:
<blockquote><pre>
$ <strong>nc <em>サーバIPアドレス</em> 10000</strong>
</pre></blockquote>
<li> サーバ・クライアント側ともに何らかのテキストを入力し、
相手の端末にそれが送信されていることを確認せよ。
</ol>
</div>

<ul>
<li> 1台のサーバは、複数のTCPポートを Listen状態にすることができる。
<li> また、1台のクライアントは、複数のTCPサーバに同時に接続することができる。
</ul>

<p>
<code>netstat</code>コマンドを実行すると、現在その PC上で
Listen/Established状態になっている TCPポート一覧を見ることができる。
</p>

<div class=exercise id="ex-netstat">
<div class=header>演習. TCP 接続の状態を確認する</div>
<p>
<a href="#ex-tcp-connection">上の演習</a> を実行中に、
サーバ・クライアントの両方で別のウィンドウを開き、
以下のコマンドを実行して、現在通信中のポートが表示されていることを確認せよ。
</p>
<p>
Linuxの場合:
<pre>
$ <strong>netstat -n -t</strong>
</pre>
<p>
macOSの場合:
<pre>
$ <strong>lsof -n -P -iTCP</strong>
</pre>
</div>

<div class=exercise id="ex-tcp-wireshark">
<div class=header>演習. Wireshark を使って TCPハンドシェイクを観察する</div>
<p>
Wireshark を起動、パケットキャプチャーを開始し、
フィルタバーに <code>ip.addr == <em>サーバIPアドレス</em></code> と入力せよ。
その後、 <a href="#ex-tcp-connection">上の演習</a> をもう一度くりかえし
TCP の 3ウェイハンドシェイクが行われていることを確認せよ。
</p>
</div>

<h3 id="tcp-udp">4.3. UDP層</h3>
<p>
TCP層は便利だが、いくつか欠点がある:
</p>
<ul>
<li> 最初のハンドエシェイクに時間がかかる。
<li> あるセグメントが届かなかったら、絶対に送り直さねばならない。
</ul>

<p>
これに対して、TCP層のかわりに
<u>UDP</u> (User Datagram Protocol)
層というものを使うこともできる。
これはIP層を使っているが、
TCPとは別の方法で通信をおこなう。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="60" height="30" fill="#ffaaff" />
      <rect x="60" y="30" width="60" height="30" fill="#aaffff" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="30" y="45" dy="0.5em">TCP層</text>
      <text x="90" y="45" dy="0.5em">UDP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<ul>
<li> IPパケットの <strong>プロトコル番号</strong> = 6 なら TCP。
<li> IPパケットの <strong>プロトコル番号</strong> = 17 なら UDP。
</ul>

<h4>UDPの用途</h4>
<ul>
<li> 動画の実況中継など、データの完全性よりもリアルタイム性が重要なもの。
<li> ネットワーク対戦ゲームなど、速い反応が要求されるもの。
</ul>

<h4>UDPの欠点</h4>
<ul>
<li> 信頼性がない。(ロスしたらそれで終わり)
<li> 大きなデータは送れない。
</ul>

<h4>UDPパケットの構造</h4>

<table border>
<tr>
<th></th>
<th style="width:8em;">0</th>
<th style="width:8em;">1</th>
<th style="width:8em;">2</th>
<th style="width:8em;">3</th>
</tr>
<tr>
<th>0</th>
<td align=center colspan="2">送り元ポート</td>
<td align=center colspan="2">送り先ポート</td>
</tr>
<tr>
<th>4</th>
<td align=center colspan="2">データ長</td>
<td align=center colspan="2">チェックサム</td>
</tr>
<tr>
<th>8</th>
<td align=center colspan="4">実際のデータ<br>…</td>
</tr>
</table>


<h2 id="application">5. アプリケーション層</h2>
<p>
TCP/IPのデータリンク層・IP層・TCP層はすべて OS が提供している。
アプリケーション層は、インターネットの機能を実際に活用する部分であり、
ほとんどのアプリ開発者は「アプリケーション層」を作ることになる。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" fill="#88ff88" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <line x1="60" y1="120" x2="60" y2="140" />
      <line x1="-50" y1="140" x2="170" y2="140" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em">データリンク層</text>
      <text x="170" y="128" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<p>
実際のアプリケーション層のデータは、Ethernetフレームの中の、
IPパケットの中の、TCPセグメントのさらに中に記録されている。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="170">
    <g transform="translate(5,5)">
    <g stroke="black" stroke-width="2" fill="white">
      <rect x="0" y="0" width="240" height="160" />
      <rect x="30" y="30" width="200" height="120" />
      <rect x="60" y="60" width="160" height="80" />
      <rect x="90" y="90" width="120" height="40" fill="#88ff88" />
    </g>
    <g style="font-size: 80%;">
      <text x="5" y="10" dy="0.5em">Ethernetフレーム</text>
      <text x="35" y="40" dy="0.5em">IPパケット</text>
      <text x="65" y="70" dy="0.5em">TCPセグメント</text>
      <text x="95" y="100" dy="0.5em">アプリケーション</text>
      <text x="95" y="115" dy="0.5em">データ</text>
    </g></g>
  </svg>
</div>

<h4 id="socket">TCP/IP プログラミング (Socket API)</h4>
<p>
一般的に、もっともよく使われるのは TCP層の機能である。
現在の OS では「ソケット (socket)」という API が整備されており、
たとえば Python なら、すぐに TCP のサーバ-クライアント間で通信ができる:
</p>

<div class=file>
server.py (サーバ側):
<pre>
from socket import *
<em># TCP用ソケットを準備。</em>
sock = socket(AF_INET, SOCK_STREAM)
<em># TCPポート 10000番で listen状態にする。</em>
sock.bind(('0.0.0.0', 10000))
sock.listen(1)
<em># 接続してきたクライアント用のソケットを取得する。</em>
(client, addr) = sock.accept()
<em># データを受信する。</em>
data = client.recv(10)
print(data)
</pre></div>

<div class=file>
client.py (クライアント側):
<pre>
from socket import *
<em># TCP用ソケットを準備。</em>
sock = socket(AF_INET, SOCK_STREAM)
<em># ホスト 127.0.0.1 の TCPポート 10000番に接続する。</em>
sock.connect(('127.0.0.1', 10000))
<em># データを送信する。</em>
sock.send(b'hello')
</pre></div>

<div class=exercise id="ex-tcp-pytho">
<div class=header>演習. Python を使った TCPプログラミング</div>
<p>
上の 2つの Pythonスクリプト
<code>server.py</code>、<code>client.py</code> を
同一のホスト上で同時に動かし、通信ができていることを確認せよ。
</p>
</div>

<h3 id="app-dns">5.1. ドメイン名検索 (DNS)</h3>
<p>
IP アドレスはそのままでは人間にとって覚えにくい。
そこで <u>DNS</u> (Domain Name System) という仕組みが用意されている。
</p>
<ul>
<li> DNS を使うと、各ホストに名前 (<u>ホスト名</u>) をつけて、
  IPアドレスの代わりに使うことができる。
<li> ほとんどのプログラム
(<code>ping</code>, <code>traceroute</code>, <code>nc</code> など) は
  デフォルトで DNS に対応しており、これらのコマンドには
  <strong>IPアドレスの代わりにホスト名を指定してもよい</strong>。
<li> たとえば、以下の2つは同じ意味である:
<blockquote><pre>
$ <strong>ping 166.84.7.55</strong>
$ <strong>ping www.tabesugi.net</strong>
$ <strong>ping vc55.tabesugi.net</strong>
</pre></blockquote>
<li> DNS を使って、(上のように) ホスト名から IPアドレスを得ることを
「ホスト名の<u>解決</u> (resolution)」という。
<li> ひとつの IPアドレスに複数の名前がついていることもある。
<li> DNS は
「ホスト名 → IPアドレス」の解決 (<u>正引き</u>) だけでなく、
「IPアドレス → ホスト名」の解決 (<u>逆引き</u>) もサポートしている:
<blockquote><pre>
$ <strong>host 166.84.7.55</strong>
55.7.84.166.in-addr.arpa domain name pointer vc55.tabesugi.net.
</pre></blockquote>
</ul>

<h4>DNSのしくみ</h4>
<p>
DNS は TCP/IP の機能を使って作られている。
</p>
<ul>
<li> まず、インターネット上のすべてのホストを<u>ドメイン</u> (domain) という区切りに分ける。<br>
  例: <code>www.example.com</code> というホスト名は
  <code>www</code>、<code>.example</code>、<code>.com</code> という 3つの部分に分割される。
<li> 各ドメインについて、そのドメイン内のホスト名について責任を負う
  <u>ネームサーバ</u> (name server) を用意する。
<li> 世界 13箇所に<a target="_blank" href="https://ja.wikipedia.org/wiki/%E3%83%AB%E3%83%BC%E3%83%88%E3%82%B5%E3%83%BC%E3%83%90">ルートネームサーバ</a> (root name server) を用意する。
</ul>
<p>
このようなサーバを用意したあとで、
<code>www.example.com</code> の IPアドレスを求めるには:
</p>
<ol>
<li> ルートサーバ (<code>198.41.0.4</code>) に
  <code>.com</code> ネームサーバのIPアドレスを問い合わせる →
  <code>192.5.6.30</code>
<li> <code>.com</code> ネームサーバに
  <code>.example.com</code> ネームサーバのIPアドレスを問い合わせる →
  <code>199.43.133.54</code>
<li> <code>.example.com</code> ネームサーバに
  <code>www.example.com</code> のIPアドレスを問い合わせる →
  <code>93.184.216.34</code>
<li> 完了。
</ol>

<h4>localhost</h4>
<p>
<code>127.0.0.1</code> は
特別な IPアドレスであり、これはつねに「自分自身のホスト」をあらわす。
これをループバックアドレスという。
なお、ホスト名 <code>localhost</code> は
つねにループバックアドレスに解決される。
</p>

<blockquote><pre>
$ <strong>ping localhost</strong>
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.029 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.085 ms
64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.084 ms
...
</pre></blockquote>

<h4>DNSの欠点</h4>

<p>
DNS はインターネットの基幹をなすサービスであり、
ほとんどの API やアプリ、サービスなどが DNS に依存している。
DNS が使えなければ、相手の IPアドレスがわからないので、
そもそも通信ができないことが多い。
そのため <strong>DNS がうまく動かない場合、
多くのサービスやサイトで大規模な障害が発生する</strong>。
これを防ぐため、ネームサーバは多重化されていることが多い。
</p>

<blockquote><pre>
$ <strong>ping www.tabenasugi.com</strong>
ping: www.tabenasugi.com: Name or service not known
</pre></blockquote>

<div class=exercise id="ex-nslookup">
<div class=header>演習. ホスト名から IP アドレスを求める</div>
<p>
<code>host</code> コマンドを使って、
自分がよく知っているホスト名の IPアドレスを求めよ。
(<code>ping</code> でもよい)
</p>
<blockquote><pre>
$ <strong>host <em>ホスト名</em></strong>
</pre></blockquote>
</div>

<h3 id="app-web">5.2. ウェブ (HTTP)</h3>
<p>
HTTP は、おそらくもっとも有名なアプリケーション層である。
</p>
<ul>
<li> TCP 80番ポート (HTTPS の場合は TCP 443番ポート) を使う。
<li> <u>HTML</u> >Hyper Text Markup Language) 型式で
  書かれたデータ (ようするに、Webページ) をブラウザに転送する。
</ul>
<p>
通常、HTTP を使うクライアントを
<u>ウェブブラウザ</u> (HTTPクライアント) と呼び、
それに答えるサーバを
<u>ウェブサーバ</u> (HTTPサーバ) という。
</p>

<h4>HTTP のしくみ</h4>

<ol>
<li> クライアントがコンテンツを要求する。(要求、<u>リクエスト</u>)
<li> サーバがコンテンツを提供する。(応答、<u>レスポンス</u>)
<li> 読み込むページ・画像ファイルの数だけ 1., 2. を繰り返す。
</ol>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="400" height="70">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="white" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use x="20" y="0" xlink:href="#computer" />
      <use x="320" y="0" xlink:href="#computer" />
      <path d="M70,20 l240,0" marker-end="url(#arrow)" />
      <path d="M310,30 l-240,0" marker-end="url(#arrow)" />
    </g>
    <g text-anchor="middle" style="font-size:80%;">
      <text x="45" y="60">クライアント</text>
      <text x="345" y="60">サーバ</text>
      <text x="110" y="12">リクエスト</text>
      <text x="270" y="48">レスポンス</text>
    </g>
  </svg>
  <div class="caption">HTTPにおけるリクエストとレスポンス</div>
  </div>
</div>

<p>
たとえばブラウザで
<div class=figure>
<code>http://<span class=bgy>www.example.com</span>:<span class=bgr>80</span><span class=bgg>/news/</span></code>
</div>
というURL を開くと、
TCPポート <span class=bgr>80</span>番に対して接続がおこなわれ、
以下のような<u>リクエスト</u>文字列が送信される:
</p>
<blockquote><pre>
GET <span class=bgg>/news/</span> HTTP/1.1
Host: <span class=bgy>www.example.com</span>
User-Agent: Mozilla/5.0 (Windows NT 6.1;) Gecko/20100101
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,&#48;/&#48;;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
<em>(空行)</em>
</pre></blockquote>
<p>
これに対してサーバは以下のような<u>レスポンス</u>文字列を返す:
</p>
<blockquote><pre>
HTTP/1.1 200 OK
Connection: close
Date: Fri, 20 Feb 2023 08:27:28 GMT
Content-Type: text/html
Content-Length: 9022
<em>(空行)</em>
&lt;html&gt;
...
</pre></blockquote>

<h4>HTTPリクエスト</h4>
<p>
HTTP リクエストには GET, POST などいくつかの種類がある。
リクエストはさらに <u>ヘッダ</u> (header) と
<u>ボディ (ペイロード)</u> (body, payload) に分かれている。
これらは<em>空行</em>で分けられている。
</p>

<blockquote>
リクエストヘッダ:<br>
<pre>
GET /news/ HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:35.0) Gecko/20100101 Firefox/35.0
…
<em>(空行)</em>
</pre>
リクエストボディ (ペイロード):<br>
</blockquote>

<p>
ヘッダは <u>項目名</u>: <u>値</u> の形をとる。
</p>
<ul>
<li> <code><u>Host:</u></code> 相手のサーバの名前
<li> <code><u>User-Agent:</u></code> ブラウザの種類
<li> その他 (<A target="_blank" href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 参照)
</ul>
<p>
ボディは、GETリクエストの場合は空である (つまり何も含まれていない)。
</p>

<h4>HTTPレスポンス</h4>
<p>
HTTP レスポンスもまた、
<u>ヘッダ</u> (header) と
<u>ボディ (ペイロード)</u> (body, payload) に分かれている。
これらは<em>空行</em>で分けられている。
</p>

<blockquote>
レスポンスヘッダ:<br>
<pre>
HTTP/1.1 200 OK
Connection: close
Date: Fri, 20 Feb 2015 08:27:28 GMT
Content-Type: text/html
Content-Length: 9022
…
<em>(空行)</em>
</pre>
レスポンスボディ (ペイロード):<Br>
<pre>
&lt;html&gt;&lt;body&gt;
…
</pre></blockquote>

<p>
ヘッダは <u>項目名</u>: <u>値</u> の形をとる。
</p>
<ul>
<li> <code><u>Date:</u></code> サーバの応答時刻。
<li> <code><u>Content-Type:</u></code> そのコンテンツの種類 (HTMLファイルか画像か)。
<li> <code><u>Content-Length:</u></code> そのコンテンツの大きさ (バイト数)。
</ul>
<p>
レスポンス内のペイロードには、通常 HTML ファイル
(または画像ファイルなど) の内容がそのまま含まれている。
ブラウザはこの内容を解析して表示すると、ページが表示されたことになる。
</p>

<h4>いろいろな HTTP レスポンス</h4>
<p>
正常なレスポンスの場合、最初の一行は必ず
<blockquote><pre>
HTTP/1.1 <u>200</u> OK
</pre></blockquote>
となっているが、これ以外のレスポンスが返ってくる場合もある。
</p>
<ul>
<li> 指定されたファイルが存在しない。いわゆる「ページが見つかりません」エラー。
    この場合、サーバはペイロードとして HTML を返すこともある。
  <blockquote><pre>HTTP/1.1 <u>404</u> Not Found</pre></blockquote>
  <p> 例: <a target="_blank" href="https://www.google.com/nonexistent">https://www.google.com/nonexistent</a>
<li> 別の場所を参照せよ。これが返されると、ブラウザのアドレスバーが変化する。
  <blockquote><pre>HTTP/1.1 <u>301</u> Moved</pre></blockquote>
  <p> 例: <a target="_blank" href="https://ja.wikipedia.org/">https://ja.wikipedia.org/</a>
</ul>

<div class=exercise id="ex-human-http-client">
<div class=header>演習. 人間HTTPクライアント</div>
<p>
<code>nc</code> コマンドを使って、
<a target="_blank" href="https://www.example.com/">www.example.com</a> サーバに
「人間HTTPクライアント」としてリクエストを送り、
サーバ側のレスポンスを確認せよ。
</p>
<blockquote><pre>
$ <strong>nc www.example.com 80</strong>
<strong>GET / HTTP/1.0</strong>
<strong>Host: www.example.com</strong>

<em>(サーバからのレスポンス)</em>
HTTP/1.0 200 OK
Content-Type: text/html; charset=UTF-8
Date: Mon, 23 Jan 2023 13:39:22 GMT
…

&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
…
</pre></blockquote>
</div>

<div class=exercise id="ex-human-http-server">
<div class=header>演習. 人間HTTPサーバ</div>
<p>
<code>nc</code> コマンドを使って、
「人間HTTPサーバ」としてブラウザからの
リクエストに返答せよ。
まず <code>nc</code> をサーバとして起動し、
ブラウザから <a href="http://localhost:8080/"><code>http://localhost:8080/</code></a>
という URLに接続してリクエストが送られるのを確認してから、
応答を入力せよ。
</p>
<blockquote><pre>
$ <strong>nc -l 8080</strong>
<em>(クライアントからのリクエスト)</em>
GET / HTTP/1.1
User-Agent: Mozilla/5.0
…

<strong>HTTP/1.0 200 OK</strong>
<strong>Content-Type: text/plain</strong>

<strong>Hello.</strong>

^C
</pre></blockquote>
</div>

<div class=exercise id="ex-http-troubleshooting">
<div class=header>演習. HTTPトラブルシューティング</div>
<p>
あるユーザが「インターネットが動かない」といっている。
聞けばブラウザに <code>http://www.example.com/</code> というアドレスを入力したが、
ページが表示されないのだという。この場合、考えられる原因をすべてあげよ。
<ol type=a>
<li> <nobr><span class=bl>どこかのケーブルが断線している</span></nobr>
<li> <nobr><span class=bl>DNS から IPアドレスが解決できていない</span></nobr>
<li> <nobr><span class=bl>ルータが正しく動いていない</span></nobr>
<li> <nobr><span class=bl>パケットが捨てられている</span></nobr>
<li> <nobr><span class=bl>ブラウザにバグがある</span></nobr>
<li> <nobr><span class=bl>相手のサーバの電源が入っていない</span></nobr>
<li> <nobr><span class=bl>相手のサーバがListen状態になっていない</span></nobr>
<li> <nobr><span class=bl>相手のサーバプログラムにバグがある</span></nobr>
<li> ...
</ol>
</p>
</div>

<h4>Webアプリとは</h4>
<p>
HTTP はあまりにも普及しているため、
こんにち多くのアプリケーションは TCP層を直接使わず、
HTTP「層」を使って構築されるようになっている。
このようなアプリを <u>Webアプリ</u> と呼ぶ。
また、上で紹介した <a href="#socket">socket API</a> に似た機構を HTTP層の上で実現した
<u>WebSocket</u> という仕組みもある。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="180">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" fill="#88ff88" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <rect x="0" y="120" width="120" height="30" />
      <line x1="60" y1="150" x2="60" y2="170" />
      <line x1="-50" y1="170" x2="170" y2="170" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">Webアプリ</text>
      <text x="60" y="45" dy="0.5em">HTTP層</text>
      <text x="60" y="75" dy="0.5em">TCP層</text>
      <text x="60" y="105" dy="0.5em">IP層</text>
      <text x="60" y="135" dy="0.5em">データリンク層</text>
      <text x="170" y="158" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<h3 id="app-email">5.3. 電子メール (SMTP)</h3>
<p>
HTTP 以外のアプリケーション層の例として、<u>SMTP</u>
(Simple Mail Transfer Protocol) がある。
これは特定のサーバ (<u>メールサーバ</u>) の TCP 25番ポートに
データを送ると、電子メールを送ることができる。
</p>
<blockquote><pre>
$ <strong>nc gmail-smtp-in.l.google.com 25</strong>
220 mx.google.com ESMTP
<strong>HELO mail.example.com</strong>
250 mx.google.com at your service
<strong>MAIL FROM:&lt;<u>送り元メールアドレス</u>&gt;</strong>
250 2.1.0 OK
<strong>RCPT TO:&lt;<u>xxx@gmail.com</u>&gt;</strong>
250 2.1.5 OK
<strong>DATA</strong>
354  Go ahead zz-1234 - gsmtp
<strong>From: &lt;<u>送り元メールアドレス</u>&gt;</strong>
<strong>To: &lt;<u>xxx@gmail.com</u>&gt;</strong>
<strong>Message-Id: &lt;zz12345678@mail.example.com&gt;</strong>
<strong>Subject: test</strong>

<strong>Hello, this is test!</strong>
<strong>.</strong>
250 2.0.0 OK
<strong>QUIT</strong>
221 2.0.0 closing connection
</pre></blockquote>


<h2 style="margin-top:4em;" id="encryption">6. 暗号化</h2>

<div class=exercise id="ex-2">
<div class=header>演習. 前回までのおさらい</div>
<ul>
<li> IP層における通信と比較したときの、TCP層の長所・短所を挙げよ。
<li> HTTP は、TCP の <nobr><span class=bl>80</span></nobr> 番ポートを使用する。
<li> <code>ping 93.184.216.34</code> とやると成功するのに、
<code>ping www.example.com</code> ではエラーになる。<br>
この場合、<nobr><span class=bl>DNS</span></nobr> が正常に動作していない可能性がある。
</ul>
</div>

<p>
本来、TCP/IP の公式な範疇はTCP層までで、それより上は
アプリケーションの責任となっている。しかし TCP 層では
真に安全な通信は実現できない:
</p>
<ul>
<li> 短所: 通信内容が中継ホストに<strong>まる見え</strong>であること。
<li> 短所: 通信相手が<strong>本物かどうか確認できない</strong>こと。
  (中継するルータが、最終目的のホストのふりをすることが可能である)
<li> 短所: 通信内容が途中で<strong>改竄される</strong>可能性があること。
</ul>

<p>
最近では、これらの欠点を補うために TCP層の上にさらにもう一段、
(TCP/IPの範疇ではない) 暗号化をおこなう層を追加して使うことが多い。
</p>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="180">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" fill="#ff88ff" />
      <rect x="0" y="60" width="120" height="30" />
      <rect x="0" y="90" width="120" height="30" />
      <rect x="0" y="120" width="120" height="30" />
      <line x1="60" y1="150" x2="60" y2="170" />
      <line x1="-50" y1="170" x2="170" y2="170" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">(暗号化層)</text>
      <text x="60" y="75" dy="0.5em">TCP層</text>
      <text x="60" y="105" dy="0.5em">IP層</text>
      <text x="60" y="135" dy="0.5em">データリンク層</text>
      <text x="170" y="158" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
</div>

<p>
暗号化通信において特に重要なこと:
</p>
<div class=formula>
暗号化は、必ず通信相手の確認と<strong>セットで使わなければ</strong>意味がない。
</div>

<p>
なぜなら悪者も暗号は使えるからだ。
たとえば、中継するホストが正当な相手のフリをして、暗号を使って通信すれば、
結局のところ情報は悪者の手に渡ってしまう (中間者攻撃)。
したがって、暗号はつねに <u>end-to-end</u> で利用する必要がある。
</p>
<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="500" height="110">
    <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g id="user" fill="none" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    <g id="baddie" fill="black" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    </defs>
    <use xlink:href="#user" x="10" y="20" />
    <use xlink:href="#baddie" x="260" y="20" />
    <use xlink:href="#user" x="410" y="20" />
    <g stroke="black" fill="none" stroke-width="4" marker-end="url(#arrow)">
      <line x1="80" x2="240" y1="40" y2="40" />
      <line x1="240" x2="80" y1="60" y2="60" />
    </g>
    <g style="font-size: 75%;" text-anchor="middle">
      <text x="160" y="30">暗号</text>
      <text x="35" y="90">自分</text>
      <text x="285" y="90">悪者</text>
      <text x="285" y="90" dy="1.1em">(中間者)</text>
      <text x="435" y="90">本当に通信したい相手</text>
    </g>
  </svg>
  <div class="caption">悪者が暗号を使ったら…?</div>
  </div>
</div>

<p>
現在普及している暗号化層:
</p>
<ul>
<li> <u>TLS/SSL</u>層 … <u>認証局 (CA)</u> という中央集権的な
認証の枠組みを導入することにより、相手ホストの正当性を判定する。
<li> <u>SSH</u>層 … 個人の信頼にもとづいた、
  ホスト間の簡単な認証システム。
</ul>

<p>
TLS/SSL も SSH も (本来は TCP/IP 層の一部ではなくアプリケーション層なので)、
アプリケーションまたはライブラリの形で提供されている。
どちらもベースになっているのは<u>公開鍵暗号</u>技術である。
</p>

<h4>公開鍵暗号技術とは</h4>
<p>
公開鍵暗号技術については、以下のことだけ覚えておけばよい:
</p>
<ul>
<li> <u>秘密鍵</u>と、それに数学的に対応した<u>公開鍵</u>を使う。
  これらは<strong>必ずペアで生成される</strong>。
  (実際には物理的な鍵ではなく、ただのデータである)
<li> 秘密鍵は他人に<strong>見せてはならない</strong>。(パスワードのようなもの)
<li> 公開鍵は<strong>誰に見せてもよく</strong>、むしろ積極的に配布してよい。(名刺のようなもの)
<li> 公開鍵を秘密鍵に変換することは<strong>できない</strong>。
<li> 秘密鍵の所持者は、<strong>そのデータ自体を見せずに</strong>
  自分がそれを所持している事実を証明できる。(<u>ゼロ知識証明</u>)
</ul>

<div class=exercise id="ex-public-key-auth">
<div class=header>演習. 公開鍵を使った認証</div>
<p>
Aさんは、自分用の秘密鍵と公開鍵のペアを所持している。
Bさんは Aさんに会ったことはないが、
ネット上でたまたま Aさんの公開鍵を入手した。
</p>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="350" height="170">
    <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g id="user" fill="none" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    <g id="baddie" fill="black" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    <g id="key1" fill="none" stroke="white" stroke-width="3">
      <rect x="-5" y="-10" width="35" height="20" stroke="black" fill="black" />
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    <g id="key2" fill="none" stroke="black" stroke-width="3">
      <rect x="-5" y="-10" width="35" height="20" />
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    </defs>
    <use xlink:href="#user" x="50" y="10" />
    <use xlink:href="#user" x="290" y="10" />
    <use xlink:href="#baddie" x="150" y="100" />
    <use xlink:href="#key1" x="10" y="45" />
    <use xlink:href="#key2" x="110" y="45" />
    <use xlink:href="#key2" x="250" y="45" />
    <use xlink:href="#key2" x="210" y="130" />
    <g stroke="black" fill="none" stroke-width="4" marker-end="url(#arrow)">
      <path d="M150,50 l80,0" />
      <path d="M230,110 l30,-40" />
    </g>
    <g style="font-size: 75%;" text-anchor="middle">
      <text x="75" y="70">Aさん</text>
      <text x="315" y="70">Bさん</text>
      <text x="175" y="165">Cさん</text>
      <text x="22" y="30">秘密鍵</text>
      <text x="122" y="30">公開鍵</text>
    </g>
  </svg>
  </div>
</div>
<ol>
  <li> Bさんが Aさんと実際に通信したとき、
    相手が Aさん本人であることをどうやって確認すればよいか?
  <li> いっぽう、Aさんのフリをしたがっている偽物 C さんが Bさんと通信したとする。
    なぜ Bさんは Aさん本人ではないと見抜けるのか?
</ol>
</div>

<h3 id="encryption-tls">6.1. TLS/SSL層</h3>

<ul>
<li> もともと HTTP を暗号化するための方式 (HTTPS) として提案された。
<li> ブラウザ上にいわゆる「鍵マーク」を表示する仕組み。
<li> 接続先のサーバ名が正しいかどうかを、<u>認証局 (CA)</u> と呼ばれる第三者機関を介して、
<u>デジタル証明書</u> を使って確認する。
</ul>

<p>
デジタル証明書にはサーバの公開鍵が記載されている。
デジタル証明書は認証局が正当性を保証するもので、
これもまた公開鍵暗号技術を使っている。
詳細は <a href="../certs202301/index.html">「デジタル証明書とは何か?」</a>を参照。
</p>

<div class=figure>
  <div>
  <img src="addressbar.png" width="389" height="131">

  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="200"
       transform="scale(1,1)">
    <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g id="user" fill="none" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    <g id="ca" fill="none" stroke="black" stroke-width="2">
      <rect x="5" y="0" width="40" height="50" />
      <path d="M10,10 l0,40 M15,10 l0,40 M20,10 l0,40 M25,10 l0,40 M30,10 l0,40 M35,10 l0,40 M40,10 l0,40" />
    </g>
    <g id="site" fill="none" stroke="black" stroke-width="2">
      <rect x="15" y="0" width="20" height="50" />
      <rect x="0" y="20" width="50" height="30" />
    </g>
    <g id="keyg" fill="none" stroke="green" stroke-width="3">
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    </defs>
    <use xlink:href="#user" x="10" y="120" />
    <use xlink:href="#ca" x="160" y="20" />
    <use xlink:href="#site" x="320" y="120" />
    <use xlink:href="#keyg" x="75" y="80" />
    <use xlink:href="#keyg" x="290" y="150" />
    <g stroke="black" fill="none" stroke-width="1">
      <rect x="20" y="50" width="85" height="40" />
      <rect x="18" y="48" width="89" height="44" />
    </g>
    <g stroke="black" fill="none" stroke-width="4" marker-end="url(#arrow)">
      <line x1="280" x2="80" y1="150" y2="150" />
      <line x1="150" y1="60" x2="80" y2="120" />
    </g>
    <g style="font-size: 75%;" text-anchor="middle">
      <text x="185" y="85">認証局 (CA)</text>
      <text x="35" y="185">ブラウザ</text>
      <text x="345" y="185" fill="green">www.google.com</text>
    </g>
    <g style="font-size: 75%;">
      <text x="40" y="65">証明書</text>
      <text x="25" y="85">Google:</text>
      <text x="140" y="170">署名:</text>
      <text x="170" y="170" fill="green" style="font-size: 125%; font-weight: bold; font-style: italic;">Google</text>
    </g>
  </svg>
  <div class="caption">鍵マークが表示されるしくみ</div>
  </div>
</div>

<p>
実際の TLS/SSL による通信は <code>openssl</code> コマンドを使って
おこなう (なお、HTTPS では通常 TCP 443番ポートが使われる):
</p>
<blockquote><pre>
$ <strong>openssl s_client -connect www.example.com:443</strong>
CONNECTED(00000003)
depth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA
verify return:1
depth=1 C = US, O = DigiCert Inc, CN = DigiCert TLS RSA SHA256 2020 CA1
verify return:1
depth=0 C = US, ST = California, L = Los Angeles, O = Internet\C2\A0Corporation\C2\A0for\C2\A0Assigned\C2\A0Names\C2\A0and\C2\A0Numbers, CN = www.example.org
verify return:1
...
</pre></blockquote>

<p>
TLS/SSL層は以下のような手順で動作する:
</p>
<ol>
<li> 相手のサーバに TCP接続する。
<li> 暗号化通信を開始する。
<li> サーバからデジタル証明書 (公開鍵) を受けとり、それが正しい相手であることを確認する (TLS/SSLハンドシェイク)。
</ol>
<p>
以上が完了すると、TLS/SSL層は通常の TCP層と同じようにふるまう。
HTTPS の処理は、TLS/SSL層を使う部分以外は HTTP と同じである。
</p>

<div class=exercise id="ex-openssl-http-client">
<div class=header>演習. openssl コマンドを使って HTTPリクエストを送る</div>
<p>
上で示した openssl コマンドを使って、
<a href="#ex-human-http-client">先の演習</a>にならい
サーバに HTTPリクエストを送り、応答を確認せよ。
</p>
<blockquote><pre>
$ <strong>openssl s_client -connect www.example.com:443</strong>
<em>(サーバ証明書の表示)</em>
...
<strong>GET / HTTP/1.0</strong>
<strong>Host: www.example.com</strong>

<em>(サーバからのレスポンス)</em>
HTTP/1.0 200 OK
Content-Type: text/html; charset=UTF-8
…
</pre></blockquote>
</div>

<h4 id="curl">curlコマンド</h4>
<p>
<code>curl</code> コマンドを使うと、指定した URL に
HTTP/HTTPS リクエストを送り、レスポンスを画面に表示する。
<code>nc</code> コマンドや
<code>openssl</code> コマンドを使って手で直接 HTTP リクエストを入力するよりも、
こちらのほうが便利。
Webサーバの挙動を調べるのにおすすめ。
</p>

<blockquote><pre>
$ <strong>curl https://www.example.com/</strong>
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
...
</pre></blockquote>

<p>
<code>-i</code> オプションをつけると、HTTP のレスポンスヘッダも表示する。
</p>
<blockquote><pre>
$ <strong>curl <mark>-i</mark> https://www.example.com/</strong>
HTTP/2 200
accept-ranges: bytes
age: 49533
cache-control: max-age=604800
...
</pre></blockquote>

<p>
<code>-H</code> オプションを使えば、リクエストヘッダに任意の値を指定できる:
</p>
<blockquote><pre>
$ <strong>curl -i <mark>-H</mark> "<u>If-Modified-Since</u>: <u>Sun, 1 Jan 2023 00:00:00 GMT</u>" https://www.example.com/</strong>
HTTP/2 304
...
</pre></blockquote>

<div class=exercise id="ex-curl-http-client">
<div class=header>演習. curl コマンドを使って HTTPリクエストを送る</div>
<p>
上で示した <code>curl</code> コマンドの使用例を実際に実行せよ。
</div>

<h4>TLS/SSL 層の欠点</h4>
<p>
TLS/SSL 層の大きな欠点は、コストがかかることである。
TLS を使うには、ルート認証局を頂点とする、中央集権化された、
全世界規模の <u>公開鍵基盤</u> (PKI) を構築する必要がある。
これには大きな手間がかかるうえに、認証局が信頼できない場合がある
というリスクも抱えている (参考:
<a href="https://ja.wikipedia.org/wiki/2011%E5%B9%B4%E3%83%87%E3%82%B8%E3%83%8E%E3%82%BF%E3%83%BC%E4%BA%8B%E4%BB%B6">2011年デジノター事件</a>)。
</p>
<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="300"
       transform="scale(1,1)">
    <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g id="ca" fill="none" stroke="black" stroke-width="2">
      <rect x="5" y="0" width="40" height="50" />
      <path d="M10,10 l0,40 M15,10 l0,40 M20,10 l0,40 M25,10 l0,40 M30,10 l0,40 M35,10 l0,40 M40,10 l0,40" />
    </g>
    <g id="site" fill="none" stroke="black" stroke-width="2">
      <rect x="15" y="0" width="20" height="50" />
      <rect x="0" y="20" width="50" height="30" />
    </g>
    <g id="key" fill="none" stroke="black" stroke-width="3">
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    <g id="keyr" fill="none" stroke="red" stroke-width="3">
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    <g id="keyb" fill="none" stroke="blue" stroke-width="3">
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    <g id="keyg" fill="none" stroke="green" stroke-width="3">
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    <g id="cert">
      <rect stroke="black" fill="none" stroke-width="1" x="0" y="0" width="70" height="20" />
      <text stroke="none" fill="black" style="font-size: 75%;" x="2" y="15">証明書</text>
    </g>
    </defs>
    <use xlink:href="#ca" x="300" y="15" />
    <use xlink:href="#ca" x="200" y="85" />
    <use xlink:href="#ca" x="100" y="155" />
    <use xlink:href="#site" x="20" y="225" />
    <use xlink:href="#key" x="360" y="40" />
    <use xlink:href="#keyr" x="260" y="120" />
    <use xlink:href="#keyb" x="160" y="190" />
    <use xlink:href="#keyg" x="80" y="260" />
    <use xlink:href="#cert" x="230" y="40" />
    <use xlink:href="#keyr" x="270" y="50" />
    <use xlink:href="#cert" x="130" y="110" />
    <use xlink:href="#keyb" x="170" y="120" />
    <use xlink:href="#cert" x="30" y="180" />
    <use xlink:href="#keyg" x="70" y="190" />
    <g stroke="black" fill="none" stroke-width="4" marker-end="url(#arrow)">
      <path d="M305,70 l-50,20" />
      <path d="M320,70 l-30,20" />
      <path d="M340,70 l30,20" />
      <path d="M205,140 l-50,20" />
      <path d="M220,140 l-30,20" />
      <path d="M240,140 l30,20" />
      <path d="M105,210 l-40,20" />
      <path d="M120,210 l-20,20" />
      <path d="M140,210 l30,20" />
    </g>
    <g style="font-size: 75%;" text-anchor="middle">
      <text x="320" y="12">ルート認証局A</text>
      <text x="220" y="82" fill="red">中間認証局B</text>
      <text x="120" y="152" fill="blue">中間認証局C</text>
      <text x="60" y="290" fill="green">www.example.com</text>
    </g>
    <text x="320" y="90">...</text>
    <text x="220" y="160">...</text>
    <text x="120" y="240">...</text>
  </svg>
  <div class=caption>公開鍵基盤</div>
  </div>
</div>

<h3 id="encryption-ssh">6.2. SSH層</h3>

<p>
これに対して、SSH はもっと簡単な仕組みを使って暗号化された通信を実現している:
</p>

<ol>
<li> ユーザは、あらかじめ接続しようとするサーバの公開鍵を、なんらかの方法によって知っておく。
<li> 初回接続時に、サーバは自分の公開鍵の指紋を提示し、その秘密鍵の持ち主であることを証明する。
<li> ユーザがそれを認めれば、暗号化された通信が確立する。
</ol>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="350" height="80">
    <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g id="user" fill="none" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    <g id="computer" fill="white" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    <g id="key1" fill="none" stroke="white" stroke-width="3">
      <rect x="-5" y="-10" width="35" height="20" stroke="black" fill="black" />
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    <g id="key2" fill="none" stroke="black" stroke-width="3">
      <rect x="-5" y="-10" width="35" height="20" />
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    </defs>
    <use xlink:href="#user" x="10" y="10" />
    <use xlink:href="#computer" x="245" y="15" />
    <use xlink:href="#key2" x="70" y="45" />
    <use xlink:href="#key2" x="210" y="45" />
    <use xlink:href="#key1" x="310" y="45" />
    <g stroke="black" fill="none" stroke-width="4" marker-end="url(#arrow)">
      <path d="M195,50 l-80,0" />
    </g>
    <g style="font-size: 75%;" text-anchor="middle">
      <text x="35" y="70">ユーザ</text>
      <text x="270" y="70">サーバ</text>
      <text x="222" y="30">公開鍵</text>
      <text x="322" y="30">秘密鍵</text>
    </g>
  </svg>
  <div class="caption">公開鍵によるサーバ認証</div>
  </div>
</div>

<p>
SSH はもともと Unixマシンの遠隔操作のために開発されたため、
暗号化通信に加えて、<strong>ユーザの認証処理</strong>もおこなう。
現在、SSH はサーバ管理などでアプリ開発者がよく利用するツールとなっている。
</p>

<p>
<strong>注意:</strong>
SSH ではユーザの認証にも公開鍵を使っているため、
2種類の「公開鍵」が存在する:
</p>
<ol>
<li> ユーザは、あらかじめ接続しようとするサーバ上の
<code>~/.ssh/authorized_keys</code> ファイルに、自分の<strong>認証用の公開鍵</strong>を登録しておく。
<li> ユーザはログイン時に、自分がその公開鍵の持ち主であることを証明する。
<li> サーバがそれを認めれば、ログインが許可される。
</ol>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="350" height="80">
    <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g id="user" fill="none" stroke="black" stroke-width="2">
      <path d="M0,50 Q0,40,15,35 Q5,30,5,20 Q5,0,25,0 Q45,0,45,20 Q45,30,35,35 Q50,40,50,50" />
    </g>
    <g id="computer" fill="white" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    <g id="key1" fill="none" stroke="white" stroke-width="3">
      <rect x="-5" y="-10" width="35" height="20" stroke="black" fill="black" />
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    <g id="key2" fill="none" stroke="black" stroke-width="3">
      <rect x="-5" y="-10" width="35" height="20" />
      <circle cx="20" cy="0" r="5" />
      <path d="M15,0 l-15,0 l0,7 M7,0 l0,7" />
    </g>
    </defs>
    <use xlink:href="#user" x="50" y="10" />
    <use xlink:href="#computer" x="290" y="15" />
    <use xlink:href="#key1" x="10" y="45" />
    <use xlink:href="#key2" x="110" y="45" />
    <use xlink:href="#key2" x="250" y="45" />
    <g stroke="black" fill="none" stroke-width="4" marker-end="url(#arrow)">
      <path d="M150,50 l80,0" />
    </g>
    <g style="font-size: 75%;" text-anchor="middle">
      <text x="75" y="70">ユーザ</text>
      <text x="315" y="70">サーバ</text>
      <text x="22" y="30">秘密鍵</text>
      <text x="122" y="30">公開鍵</text>
    </g>
  </svg>
  <div class="caption">公開鍵によるユーザ認証</div>
  </div>
</div>

<h4>SSH の使い方</h4>
<p>
ここでは典型的な例 (Unixサーバに SSH を使ってログインする) をあげる:
</p>
<ol>
<li> サーバ側で、SSHサーバを起動する。SSHサーバは初回起動時、自動的にそのサーバの公開鍵を生成する。
<li> クライアントPC上で <code>ssh-keygen</code> コマンドを使って、
  あらかじめ認証用の秘密鍵・公開鍵ペアを生成しておく。
  (これは最初の一度だけ実行すればよい。)<br>
<strong>注意:</strong>
 既存の鍵ファイルがある場合、<code>ssh-keygen</code> は勝手に上書きしてしまうので注意。
<blockquote><pre>
client$ <strong>ssh-keygen -t ed25519</strong>
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/euske/.ssh/id_ed25519):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in <mark>/home/euske/.ssh/id_ed25519</mark>  <em>(秘密鍵ファイル)</em>
Your public key has been saved in <mark>/home/euske/.ssh/id_ed25519.pub</mark>  <em>(公開鍵ファイル)</em>
...
</pre></blockquote>
<li> 秘密鍵ファイルは危険なので、普通は暗号化して記録される。また、そのマシンの外には持ち出さない。<br>
(複数のマシンで SSH を使う場合、マシンごとに異なる秘密鍵を生成する)<br>
<strong>注意:</strong>
 <code>ssh-keygen</code> で入力するパスフレーズは秘密鍵の暗号化に使うものであって、<strong>サーバのログインに使うパスワードとは関連がない</strong>。<br>
<li> いっぽう公開鍵ファイルは誰に見せてもよいので、ログイン先のSSHサーバ上アカウントの
<code>~/.ssh/authorized_keys</code> にコピーしておく。
<li> SSHサーバ公開鍵の指紋 (fingerprint) を覚えておく。<br>
たとえば、<code>server.example.com</code> の公開鍵の指紋は
<code>SHA256:HLfnjG5dDqVPIfWtG6sNGG5JyY5AYtkxaupGsJffyYs</code> であるとしよう。
<li> クライアントPC上で <code>ssh</code> コマンドを使ってサーバに接続する。<br>
SSH では、通常 TCP 22番ポートが使われる。<br>
初回接続時には、サーバ公開鍵の指紋が表示され、確認が要求される。
<blockquote><pre>
client$ <strong>ssh user@server.example.com</strong>
The authenticity of host '[server.example.com]:22 ([192.168.1.10]:22)' can't be established.
ED25519 key fingerprint is <mark>SHA256:HLfnjG5dDqVPIfWtG6sNGG5JyY5AYtkxaupGsJffyYs</mark>.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</pre></blockquote>
<li> ユーザがこれに <code>yes</code> と答えれば接続が続行する。<br>
  この後、暗号化された秘密鍵を使うためのパスフレーズを入力する。
</ol>

<p>
SSH のよくある使い方はサーバ上のシェルを遠隔実行するためのものだが、
SSH 層自体がいくつかのレイヤーから構成されており、
シェル以外の用途にも利用可能である:
</p>

<ul>
<li> ファイル転送機能 (SFTP)
<li> ポート転送機能 (<a href="#security-ssh-tunnel">後述</a>)
</ul>

<h4>SSH の設定ファイル</h4>
<p>
<code>ssh</code> コマンドは、自分のホームディレクトリ下にある
<code>~/.ssh/config</code> という設定ファイルを利用する。
</p>
<p>
たとえば、以下のような内容:
</p>
<div class=file>
~/.ssh/config
<pre>
Host <mark>myhost</mark>
        Port <mark>222</mark>                            <em>(TCPポート番号)</em>
        User <mark>aws-user-1</mark>                     <em>(ログインするユーザ名)</em>
        IdentityFile <mark>~/.ssh/id_ed25519_aws</mark>  <em>(認証に使う秘密鍵)</em>
        Hostname <mark>myhost.something.us-east-1.servers.aws.com</mark>  <em>(実際のホスト名)</em>
</pre>
</div>
<p>
を書いておくと、以下のコマンド
</p>
<blockquote><pre>
client$ <strong>ssh <mark>myhost</mark></strong>
</pre></blockquote>
<p>
を入力しただけで、
自動的に対象のホスト名・ユーザ・秘密鍵ファイルなどが指定される。
</p>
<p>
同様のことをコマンドラインで指定すると以下のようになる:
</p>
<blockquote><pre>
client$ <strong>ssh -p <mark>222</mark> -f <mark>~/.ssh/id_ed25519_aws</mark> <mark>aws-user-1@myhost.something.us-east-1.servers.aws.com</mark></strong>
</pre></blockquote>

<h4>SSH の秘密鍵保持エージェント (ssh-agent)</h4>
<p>
SSHで認証に使う秘密鍵は、通常は暗号化されており、解凍するには毎回パスフレーズの入力が必要である。
秘密鍵保持エージェントを使うと、一度解凍した秘密鍵を一定時間保持しておくことができるため、
毎回パスフレーズを入力する必要がなくなる。
</p>
<p>
現在のほとんどのOSでは、秘密鍵保持エージェントは自動的に起動されている。
ここに秘密鍵を追加・削除するには、<code>ssh-add</code> コマンドを使う。
</p>
<ul>
  <li> <code>ssh-add <em>秘密鍵ファイル</em></code>: 秘密鍵をエージェントに追加する。</li>
  <li> <code>ssh-add -D</code>: エージェント上の秘密鍵をすべて削除する。</li>
  <li> <code>ssh-add -l</code>: エージェント上の秘密鍵を一覧表示する。</li>
</ul>

<h2 id="security">7. セキュリティ</h2>
<p>
一般に、ネットワークにおける「セキュリティ」とは、以下の性質をさす:
</p>
<ol type=a>
  <li> 機密性 (情報が不正に閲覧されない)
  <li> 完全性 (情報が不正に改竄されない)
  <li> 可用性 (情報へのアクセスが妨害されない)
</ol>
<p>
先に述べた暗号化は上の性質 a., b. に対してある程度は有効だが、
完全ではない (そもそも「完全な」セキュリティなど現実にありえない)。
インターネットは本質的に信頼できないため、
暗号化以外にもネットワークからの攻撃を防ぐ仕組みがいくつも存在する。
</p>

<h3 id="security-privateip">7.1. プライベートIPアドレス</h3>
<ul>
<li> インターネットを使う<strong>すべての</strong>機器には
IPアドレスが必要である。
<li> しかも、同じアドレスを 2つの場所で使ってはならない。
<li> しかし、IP アドレスは 32ビットで表現されているため、
たかだか 2<sup>32</sup> ≒ 42億個しか存在しない。
<li> 現在、世界にはこれを超える台数のコンピュータが存在する。
<li> IPアドレスが足りない。
</ul>

<p>
そこで、以下のアドレスは組織内で勝手に使ってよいという
決まりになっている。これを <u>プライベート IPアドレス</u> といい、
プライベート IPアドレスを使ったネットワークを
<u>プライベート ネットワーク</u> (private network) という。
</p>
<ul>
<li> <code>10.0.0.0/8</code>
<li> <code>172.16.0.0/12</code>
<li> <code>192.168.0.0/16</code>
<li> ...
</ul>
<div class=notice>
注意:
プライベートIPアドレスのホストは、
インターネット (その組織の外) からは到達できない。
</div>
<p>
これに対して、世界中から実際に到達可能な「普通の」IPアドレスのことを
<u>グローバル IPアドレス</u>という。
</p>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="410" height="230">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="white" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <ellipse cx="75" cy="160" rx="70" ry="40" />
      <ellipse cx="340" cy="70" rx="58" ry="65" />
      <use xlink:href="#computer" x="0" y="100" />
      <use xlink:href="#computer" x="100" y="120" />
      <use xlink:href="#computer" x="30" y="170" />
      <use xlink:href="#computer" x="150" y="0" />
      <use xlink:href="#computer" x="280" y="30" />
      <use xlink:href="#computer" x="350" y="0" />
      <use xlink:href="#computer" x="300" y="80" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="175" y="50" dy="0.5em">166.84.7.55</text>
      <text x="125" y="170" dy="0.5em">192.168.1.1</text>
      <text x="55" y="220" dy="0.5em">192.168.1.2</text>
      <text x="35" y="150" dy="0.5em">192.168.1.3</text>
      <text x="305" y="80" dy="0.5em">192.168.1.1</text>
      <text x="375" y="50" dy="0.5em">192.168.1.2</text>
      <text x="325" y="130" dy="0.5em">192.168.1.4</text>
      <text x="175" y="70" dy="0.5em">グローバルIP</text>
      <text x="75" y="85" dy="0.5em">プライベート</text>
      <text x="75" y="100" dy="0.5em">ネットワーク</text>
      <text x="340" y="155" dy="0.5em">プライベート</text>
      <text x="340" y="170" dy="0.5em">ネットワーク</text>
    </g>
  </svg>
  <div class="caption">プライベートIPアドレス と プライベートネットワーク</div>
  </div>
</div>

<ul>
<li> 現在の日本のオフィス・家庭では、ルータ以外の
機器はほとんどプライベート IP アドレスを使っている。
<li> プライベートネットワークに接続された機器は外部のインターネットからは隔離されており、
  相互にアクセスできない。
<li> そのため、プライベートネットワークの機器は「信頼された」機器として扱われ、
  パスワード等による認証も省略されることが多い。
<li> 多くの組織でプライベートネットワークは
「安全なネットワーク (イントラネット)」とみなされている。
</ul>

<h4>IPv6</h4>
<p>
アドレスの不足を解決するため、現在の IP 層を変更して
128ビットのアドレスを使えるようにしたものが <u>IPv6</u> である。
(これに対して、従来の IP層は <u>IPv4</u> という。)
IPv6 を使えばすべての機器がグローバル IP アドレスを持つことができる。
しかし IPv6 は従来の IPv4 とは互換性がないため、
世界じゅうのルータを入れ換えなければならない。
このため、まだあまり普及していない。
</p>

<h3 id="security-nat">7.2. NAT</h3>
<ul>
<li> プライベートネットワークのホストは外部と隔離されているため、
そのままではインターネットにアクセスできない。
<li> そこで <u>NAT</u> (Network Address Translation) という仕組みが使われる。
<li> NAT = プライベートネットワーク内のホストがインターネットに
アクセスするための仕組み。
</ul>

<p>
具体的には、ルータが「どのプライベートIPアドレスがどのグローバルIPアドレスと
通信しているか」を覚えておき、それに該当する (双方向の)
IPパケットが来るたびにそのアドレスを書き換えることによって実現する:
</p>
<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="550" height="122" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="20" />
      <use xlink:href="#computer" x="200" y="20" />
      <use xlink:href="#computer" x="400" y="20" />
      <line x1="60" y1="52" x2="190" y2="52" />
      <line x1="260" y1="52" x2="390" y2="52" />
      <rect x="60" y="2" width="120" height="40" />
      <rect x="260" y="2" width="120" height="40" />
      <rect x="280" y="80" width="120" height="40" />
      <rect x="60" y="80" width="120" height="40" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="184" y1="22" x2="200" y2="22" />
        <line x1="384" y1="22" x2="400" y2="22" />
        <line x1="276" y1="105" x2="260" y2="105" />
        <line x1="56" y1="105" x2="40" y2="105" />
      </g>
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="25" y="70" dy="0.5em">192.168.1.2</text>
      <text x="225" y="70" dy="0.5em">192.168.1.1</text>
      <text x="225" y="85" dy="0.5em">11.22.33.44</text>
      <text x="425" y="70" dy="0.5em">166.84.7.55</text>
      <text x="120" y="12" dy="0.5em">Src: 192.168.1.2</text>
      <text x="120" y="27" dy="0.5em">Dst: 166.84.7.55</text>
      <text x="320" y="12" dy="0.5em">Src: 11.22.33.44</text>
      <text x="320" y="27" dy="0.5em">Dst: 166.84.7.55</text>
      <text x="340" y="92" dy="0.5em">Src: 166.84.7.55</text>
      <text x="340" y="107" dy="0.5em">Dst: 11.22.33.44</text>
      <text x="120" y="92" dy="0.5em">Src: 166.84.7.55</text>
      <text x="120" y="107" dy="0.5em">Dst: 192.168.1.2</text>
    </g>
  </svg>
  <div class="caption">NATによるIPアドレスの書き換え</div>
  </div>
</div>

<P>
現在、ほとんどの家庭用ルータ・業務用ルータには NAT 機能が搭載されている。
</p>

<div class=exercise id="ex-nat">
<div class=header>演習. NATの動きを理解する</div>
<p>
プライベートネットワーク内のホスト <code>10.10.1.2</code> が
ゲートウェイ <code>10.10.1.1</code> を経由して、
インターネット上のホスト <code>55.66.77.88</code> と通信するとする。
このとき送信されるIPパケットの送信元・送信先アドレスを書け。
</p>
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="550" height="122" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="20" />
      <use xlink:href="#computer" x="200" y="20" />
      <use xlink:href="#computer" x="400" y="20" />
      <line x1="60" y1="52" x2="190" y2="52" />
      <line x1="260" y1="52" x2="390" y2="52" />
      <rect x="60" y="2" width="120" height="40" />
      <rect x="260" y="2" width="120" height="40" />
      <rect x="280" y="80" width="120" height="40" />
      <rect x="60" y="80" width="120" height="40" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="184" y1="22" x2="200" y2="22" />
        <line x1="384" y1="22" x2="400" y2="22" />
        <line x1="276" y1="105" x2="260" y2="105" />
        <line x1="56" y1="105" x2="40" y2="105" />
      </g>
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="25" y="70" dy="0.5em">10.10.1.2</text>
      <text x="225" y="70" dy="0.5em">10.10.1.1</text>
      <text x="225" y="85" dy="0.5em">11.22.33.44</text>
      <text x="425" y="70" dy="0.5em">55.66.77.88</text>
    </g>
    <g style="font-size: 80%;">
      <text x="70" y="12" dy="0.5em">Src: </text>
      <text x="70" y="27" dy="0.5em">Dst: </text>
      <text x="270" y="12" dy="0.5em">Src: </text>
      <text x="270" y="27" dy="0.5em">Dst: </text>
      <text x="290" y="92" dy="0.5em">Src: </text>
      <text x="290" y="107" dy="0.5em">Dst: </text>
      <text x="70" y="92" dy="0.5em">Src: </text>
      <text x="70" y="107" dy="0.5em">Dst: </text>
    </g>
  </svg>
</div>
</div>

<h3 id="security-firewall">7.3. ファイヤウォール</h3>
<p>
<u>ファイヤウォール</u> (Firewall) とは、ホストにとって
害のありそうなパケットを無視する (フィルタする) 機器またはソフトウェアのことである。
現在の一般的な環境では:
<ol>
<li> ルータの機能の一部として
<li> OSの機能の一部として (Windows ファイヤウォール)
</ol>
提供されている。
</p>

<p>
基本的にファイヤウォールは「外 → 内」のパケットをフィルタするが、
「内 → 外」のパケットをフィルタすることもある。
</p>
<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="550" height="122" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    <g id="cross" fill="none" stroke="black" stroke-width="2">
      <line x1="0" y1="0" x2="20" y2="20" />
      <line x1="20" y1="0" x2="0" y2="20" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="40" />
      <use xlink:href="#computer" x="200" y="40" />
      <use xlink:href="#computer" x="400" y="40" />
      <line x1="60" y1="72" x2="190" y2="72" />
      <line x1="260" y1="72" x2="390" y2="72" />
      <rect x="270" y="10" width="50" height="30" />
      <rect x="130" y="90" width="50" height="30" />
      <use xlink:href="#cross" x="215" y="15" />
      <use xlink:href="#cross" x="215" y="95" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="266" y1="25" x2="250" y2="25" />
        <line x1="184" y1="105" x2="200" y2="105" />
      </g>
    </g>
  </svg>
  <div class="caption">パケットをフィルタする</div>
  </div>
</div>

<p>
ファイヤウォールには、一般的に以下のようなルールが設定できる:
</p>
<ul>
<li> 特定の宛先IPアドレスはダメ
<li> 特定の宛先IPポートはダメ
<li> ...
</ul>

<h4>WAF と IDS/IPS</h4>
<p>
最近のネットワークでは、ファイヤウォールに加えて
以下のような機器も使われることが多い:
</p>

<ul>
<li> WAF (<u>W</u>eb <u>A</u>pplication <u>F</u>irewall、Webアプリケーションファイヤウォール) …
  ウェブサーバ用のファイヤーウォール。
  <ul>
    <li> 一般的に、Webサーバは全世界からアクセス可能にするためファイヤウォールの外側にある。
    <li> そのため通常のファイヤウォールによる保護を受けられない。
    <li> WAF はウェブサーバに対する特定のリクエストを遮断するソフトウェアである。
    <li> 悪用されうるリクエストを検知するパターンをあらかじめ指定しておく。
  </ul>
<li> IDS (<u>I</u>ntrusion <u>D</u>etection <u>S</u>ystem、侵入検知システム) …
  不正と思われるアクセスを検知・報告するソフトウェア。
  <ul>
    <li> 不正アクセスのパターンをあらかじめ指定しておく。
  </ul>
<li> IPS (<u>I</u>ntrusion <u>P</u>rotection <u>S</u>ystem、侵入防御システム) …
  IDS を拡張したもの。
  <ul>
    <li> ファイヤーウォールと連携し、特定のパターンによるアクセスを検出すると、
      自動的にブロックする機構が追加されている。
  </ul>
</ul>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="560" height="220" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="150" />
      <use xlink:href="#computer" x="150" y="150" />
      <use xlink:href="#computer" x="300" y="150" />
      <use xlink:href="#computer" x="350" y="80" />
      <use xlink:href="#computer" x="350" y="10" />
      <path d="M60,180 l80,0 M210,180 l80,0 M360,180 l80,0" />
      <path d="M375,180 l0,-50 M375,80 l0,-20" />
      <ellipse cx="500" cy="180" rx="50" ry="25" />
    </g>
    <g text-anchor="middle" style="font-size:75%;">
      <text x="400" y="30" dy="0.5em" text-anchor="start">ウェブサーバ</text>
      <text x="400" y="100" dy="0.5em" text-anchor="start">WAF</text>
      <text x="175" y="200" dy="0.5em">IDS/IPS</text>
      <text x="325" y="200" dy="0.5em">ファイヤウォール</text>
      <text x="500" y="180" dy="0.5em">インターネット</text>
    </g>
  </svg>
  <div class="caption">WAF・IDS・IPS</div>
  </div>
</div>

<h3 id="security-proxy">7.4. プロキシサーバ</h3>
<p>
<u>プロキシサーバ</u> (proxy server) は、
プライベートネットワーク内にある PC が外部と通信するための方法のひとつである。
NAT とは異なり、IP層 (レイヤー3) ではなく TCP層 (レイヤー4) の接続を制御する。
</p>
<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="550" height="80" transform="translate(10,0)">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <defs>
    <g id="computer" fill="none" stroke="black" stroke-width="2">
      <rect x="10" y="10" width="30" height="20" />
      <polygon points="10,32 0,40 50,40 40,32" />
    </g>
    </defs>
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="0" y="20" />
      <use xlink:href="#computer" x="200" y="20" />
      <use xlink:href="#computer" x="400" y="20" />
      <g marker-end="url(#arrow)" stroke-width="4">
        <line x1="60" y1="52" x2="190" y2="52" />
        <line x1="260" y1="52" x2="390" y2="52" />
      </g>
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="125" y="20" dy="0.5em">192.168.1.1:8080</text>
      <text x="325" y="20" dy="0.5em">166.84.7.55:80</text>

      <text x="25" y="70" dy="0.5em">192.168.1.2</text>
      <text x="225" y="70" dy="0.5em">192.168.1.1</text>
      <text x="425" y="70" dy="0.5em">166.84.7.55</text>
    </g>
  </svg>
  <div class="caption">プロキシサーバ</div>
  </div>
</div>

<ol>
<li> あらかじめ、プライベートネットワーク内のブラウザが
特定のプロキシサーバに接続するよう設定しておく。
<li> ブラウザがインターネット上のホストにじかに接続するかわりに、
プロキシサーバの指定されたTCPポートに接続し、リクエストを送信する。
<div class=file>
例: ブラウザが http://www.example.com/ にアクセスする場合:
<pre>
GET / HTTP/1.1
Host: <mark>www.example.com</mark>
…
</pre>
</div>
<li> プロキシサーバは、リクエスト中の <code>Host:</code> を参照し、
  あらためて宛先のWebサーバに向けてTCP接続して、同じリクエストを送る。
<div class=file>
例: 同じリクエストを <mark>www.example.com</mark> に向けて送る:
<pre>
GET / HTTP/1.1
Host: www.example.com
…
</pre>
</div>
</ol>

<ul>
<li> 長所: NAT を使わなくてもインターネットにアクセスできる。
<li> 長所: より細かい通信制御ができる (例. 特定サイトの閲覧を禁止する)。
<li> 短所: HTTP のような目的にしか使えない (任意の IPパケットを転送できるわけではない)。
</ul>

<h3 id="security-vpn">7.5. VPN</h3>
<p>
プライベートネットワークは、本来は外部からアクセスできない
(ファイヤウォールで守られた) 安全な伝送路のみを使って構築するのが普通である。
しかし暗号化を使うことにより、安全でない伝送路を通って
プライベートネットワークを構築することが可能になる。
これを <u>VPN</u> (Virtual Private Network、仮想プライベートネットワーク) とよぶ。
</p>

<p>
VPN では、別々の場所にある2つのサーバ間を暗号化通信でつなぎ、
仮想インターフェイスを使って
見かけ上2つのホストがあたかも同一ネットワーク上に配線されているかのように
通信する。
</p><p>
以下の図は、2つのサブネットを VPN 接続した例を表したものである。
赤い点線は、VPN による (見かけ上の) パケット通信を示している。
</p>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="600" height="150">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <pattern id="diagonalHatch" width="4" height="4" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="4" style="stroke:black; stroke-width:2" />
      </pattern>
      <g id="computer" fill="none" stroke="black" stroke-width="2">
        <rect x="10" y="10" width="30" height="20" />
        <polygon points="10,32 0,40 50,40 40,32" />
      </g>
    </defs>
    <g transform="translate(20,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="60" y="0" />
      <use xlink:href="#computer" x="10" y="60" />
      <use xlink:href="#computer" x="100" y="60" />
      <use xlink:href="#computer" x="190" y="60" />
      <use xlink:href="#computer" x="260" y="30" />
      <use xlink:href="#computer" x="400" y="30" />
      <use xlink:href="#computer" x="460" y="0" />
      <use xlink:href="#computer" x="500" y="60" />
      <line x1="0" y1="55" x2="260" y2="55" />
      <line x1="35" y1="65" x2="35" y2="55" />
      <line x1="125" y1="65" x2="125" y2="55" />
      <line x1="215" y1="65" x2="215" y2="55" />
      <line x1="85" y1="45" x2="85" y2="55" />
      <line x1="450" y1="55" x2="550" y2="55" />
      <line x1="525" y1="65" x2="525" y2="55" />
      <line x1="485" y1="45" x2="485" y2="55" />
      <rect x="310" y="46" width="90" height="8" fill="url(#diagonalHatch)" />
      <ellipse cx="125" cy="95" rx="140" ry="50" stroke-dasharray="4,4" />
      <ellipse cx="525" cy="95" rx="50" ry="50" stroke-dasharray="4,4" />
    </g>
    <g stroke="red" stroke-width="2" fill="none" stroke-dasharray="2,2">
      <path d="M130,65 l0,-15 l390,0 l0,15" />
    </g>
    <g style="font-size: 80%;">
      <text x="110" y="30">ルータ</text>
      <text x="510" y="30">ルータ</text>
      <g text-anchor="middle">
	<text x="35" y="120">192.168.1.2</text>
	<text x="125" y="120">192.168.1.3</text>
	<text x="215" y="120">192.168.1.4</text>
	<text x="525" y="120">192.168.2.100</text>
	<text x="355" y="70" dy="0.5em">暗号化</text>
	<text x="285" y="80" dy="0.5em">VPN</text>
	<text x="285" y="80" dy="1.5em">サーバ</text>
	<text x="425" y="80" dy="0.5em">VPN</text>
	<text x="425" y="80" dy="1.5em">サーバ</text>
      </g>
    </g>
  </g>
  </svg>
  <div class="caption">VPNにより2つのネットワークを接続した図</div>
  </div>
</div>

<p>
各ホストのルーティング規則は変更されており、
左側のホスト (<code>192.168.1.0/24</code>) と
右側のホスト (<code>192.168.2.0/24</code>) は
それぞれ VPN サーバをルータとして経由し、もう片方のホストにパケットを送信する。
また、双方のホスト名が解決できるように、DNSの設定も変更されることが多い。
</p>

<p>
実際に VPN を実現する手法にはさまざまなものがある:
</p>
<ul>
<li> もっとも単純なのは TCP/IP層、TLS層までをまるごと「データリンク層」として扱い、
  その上にさらに VPN用の IP層、TCP層を構築するというやりかたである (OpenVPNなど)。
<li> しかしこれは効率が悪いので、IP層の拡張である <u>IPSec</u> という規格を使って、
IP層を直接暗号化する方法もある。
</ul>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="240">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <g stroke="#888" fill="#ffff88">
      <rect x="0" y="90" width="120" height="30" />
      <rect x="0" y="120" width="120" height="30" />
      <rect x="0" y="150" width="120" height="30" />
      <rect x="0" y="180" width="120" height="30" />
      </g>
      <rect x="0" y="90" width="120" height="120" />
      <line x1="60" y1="210" x2="60" y2="230" />
      <line x1="-50" y1="230" x2="170" y2="230" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text fill="#888" x="60" y="105" dy="0.5em">TLS層</text>
      <text fill="#888" x="60" y="135" dy="0.5em">TCP層</text>
      <text fill="#888" x="60" y="165" dy="0.5em">IP層</text>
      <text fill="#888" x="60" y="195" dy="0.5em">データリンク層</text>
      <text x="170" y="218" dy="0.5em">ケーブル</text>
    </g>
    <g text-anchor="middle" style="font-weight: bold;">
      <text x="60" y="150" dy="-0.5em">データ</text>
      <text x="60" y="150" dy="+0.5em">リンク層</text>
    </g></g>
  </svg>
  <div class=caption>VPNの実現手法 (OpenVPN)</div>
  </div>

  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="180">
    <g transform="translate(55,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="0" y="0" width="120" height="30" />
      <rect x="0" y="30" width="120" height="30" />
      <rect x="0" y="60" width="120" height="30" />
      <rect fill="#ffff88" x="0" y="90" width="120" height="30" />
      <rect x="0" y="120" width="120" height="30" />
      <line x1="60" y1="150" x2="60" y2="170" />
      <line x1="-50" y1="170" x2="170" y2="170" />
    </g>
    <g text-anchor="middle" style="font-size: 80%;">
      <text x="60" y="15" dy="0.5em">アプリケーション層</text>
      <text x="60" y="45" dy="0.5em">TCP層</text>
      <text x="60" y="75" dy="0.5em">IP層</text>
      <text x="60" y="105" dy="0.5em" style="font-weight:bold;">IPSec層</text>
      <text x="60" y="135" dy="0.5em">データリンク層</text>
      <text x="170" y="158" dy="0.5em">ケーブル</text>
    </g></g>
  </svg>
  <div class=caption>VPNの実現手法 (L2TP)</div>
  </div>
</div>

<h3 id="security-ssh-tunnel">7.6. SSHによるトンネリング</h3>
<p>
一般に VPN を自分で構築・設定するのはかなり手間がかかる。
いっぽう SSH の<u>ポート転送機能</u>を使うと、異なるネットワーク間における
サーバの共有が簡単にできる。
</p>
<ul>
<li> 長所: SSHさえあれば、2つのネットワークにあるサーバに相互にアクセスできる。
<li> 短所: (IPパケットをすべて転送できる VPN とは違って) TCP層でしか動作しない。
</ul>

<h4>ローカル→リモート転送</h4>
<p>
ローカル→リモート転送を使うと、ローカル (クライアント側ネットワーク) から、
リモート (サーバ側ネットワーク) のサーバに TCP接続できる。
</p>
<p>
以下の構成は、リモートにあるサーバの TCP 80番にアクセスする例である。
この場合、クライアントPC上の SSHコマンド自身がプロキシサーバとして動作し、
8080番ポートに接続された TCP の通信をすべて相手サーバの 80番に転送する。
</p>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="450" height="130">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <pattern id="diagonalHatch" width="4" height="4" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="4" style="stroke:black; stroke-width:2" />
      </pattern>
      <g id="computer" fill="none" stroke="black" stroke-width="2">
        <rect x="10" y="10" width="30" height="20" />
        <polygon points="10,32 0,40 50,40 40,32" />
      </g>
    </defs>
    <g transform="translate(20,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="50" y="0" />
      <use xlink:href="#computer" x="10" y="60" />
      <use xlink:href="#computer" x="130" y="30" />
      <use xlink:href="#computer" x="270" y="30" />
      <use xlink:href="#computer" x="330" y="0" />
      <use xlink:href="#computer" x="370" y="60" />
      <path d="M10,55 l100,0" />
      <path d="M35,55 l0,10 M75,55 l0,-10" />
      <path d="M320,55 l100,0" />
      <path d="M355,55 l0,-10 M395,55 l0,10" />
      <rect x="180" y="46" width="90" height="8" fill="url(#diagonalHatch)" />
      <path d="M370,80 l-10,10 l0,-20 l10,10 l10,0" />
      <path d="M130,50 l-10,10 l0,-20 l10,10 l10,0" />
    </g>
    <g stroke="red" stroke-width="2" fill="none" stroke-dasharray="2,2" >
      <path d="M40,65 l0,-15 l310,0 l0,30 l10,0" />
    </g>
    <g style="font-size: 80%;">
      <text x="100" y="30">ルータ</text>
      <text x="380" y="30">ルータ</text>
      <g text-anchor="middle">
	<text x="35" y="120">192.168.1.2</text>
	<text x="395" y="120">10.0.1.2</text>
	<text x="225" y="70" dy="0.5em">暗号化</text>
	<text x="155" y="80" dy="0.5em">SSH</text>
	<text x="155" y="80" dy="1.5em">クライアント</text>
	<text x="295" y="80" dy="0.5em">SSH</text>
	<text x="295" y="80" dy="1.5em">サーバ</text>
	<text x="110" y="70">8080</text>
	<text x="360" y="100">80</text>
      </g>
    </g>
  </g>
  </svg>
  <div class="caption">ローカル→リモート転送 (<code>-L 8080:10.0.1.2:80</code>)</div>
  </div>
</div>

<div class=exercise id="ex-ssh-local-port-forwarding">
<div class=header>演習. ssh コマンドを使ってローカル→リモート転送</div>
<ol>
<li> リモートのサーバ上で、以下のようにして簡単なサーバプロセスを起動する:
<pre>
server$ <strong>nc -l 10000</strong>
</pre>
<li> クライアントPC上で、「ローカル→リモート転送」を有効にしてサーバにログインする。
<pre>
client$ <strong>ssh <mark>-L 10000:localhost:10000</mark> server.example.com</strong>
</pre>
<li> クライアントPC上で、自分自身の TCP 10000番ポートに接続し、
  サーバ上のプロセスに接続できていることを確認する。
<pre>
client$ <strong>nc localhost 10000</strong>
</pre>
</ol>
</div>

<h4>リモート→ローカル転送</h4>
<p>
いっぽうリモート→ローカル転送を使うと、リモート (サーバ側ネットワーク) から
ローカル (クライアント側ネットワーク) のサーバに TCP接続できる。
</p>
<p>
以下の構成は、ローカル内のサーバの TCP 80番にリモートからアクセスさせる例である。
この場合、リモートの SSHサーバがプロキシサーバとしても動作し、
ローカルの SSHクライアントと提携して、
8080番ポートに接続された TCP の通信をすべてローカルの
特定ホストの 80番に転送する。
</p>

<div class=figure>
  <div>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="450" height="130">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <pattern id="diagonalHatch" width="4" height="4" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="4" style="stroke:black; stroke-width:2" />
      </pattern>
      <g id="computer" fill="none" stroke="black" stroke-width="2">
        <rect x="10" y="10" width="30" height="20" />
        <polygon points="10,32 0,40 50,40 40,32" />
      </g>
    </defs>
    <g transform="translate(20,5)">
    <g stroke="black" stroke-width="2" fill="none">
      <use xlink:href="#computer" x="50" y="0" />
      <use xlink:href="#computer" x="10" y="60" />
      <use xlink:href="#computer" x="110" y="30" />
      <use xlink:href="#computer" x="250" y="30" />
      <use xlink:href="#computer" x="330" y="0" />
      <use xlink:href="#computer" x="370" y="60" />
      <path d="M10,55 l100,0" />
      <path d="M35,55 l0,10 M75,55 l0,-10" />
      <path d="M320,55 l100,0" />
      <path d="M355,55 l0,-10 M395,55 l0,10" />
      <rect x="160" y="46" width="90" height="8" fill="url(#diagonalHatch)" />
      <path d="M290,50 l10,0 l10,-10 l0,20 l-10,-10" />
      <path d="M50,80 l10,0 l10,-10 l0,20 l-10,-10" />
    </g>
    <g stroke="red" stroke-width="2" fill="none" stroke-dasharray="2,2" >
      <path d="M40,65 l0,-15 l310,0 l0,30 l10,0" />
    </g>
    <g style="font-size: 80%;">
      <text x="100" y="30">ルータ</text>
      <text x="380" y="30">ルータ</text>
      <g text-anchor="middle">
	<text x="35" y="120">192.168.1.2</text>
	<text x="395" y="120">10.0.1.2</text>
	<text x="205" y="70" dy="0.5em">暗号化</text>
	<text x="135" y="80" dy="0.5em">SSH</text>
	<text x="135" y="80" dy="1.5em">クライアント</text>
	<text x="275" y="80" dy="0.5em">SSH</text>
	<text x="275" y="80" dy="1.5em">サーバ</text>
	<text x="70" y="100">80</text>
	<text x="320" y="70">8080</text>
      </g>
    </g>
  </g>
  </svg>
  <div class="caption">リモート→ローカル転送 (<code>-R 8080:192.168.1.2:80</code>)</div>
  </div>
</div>

<div class=exercise id="ex-ssh-remote-port-forwarding">
<div class=header>演習. ssh コマンドを使ってリモート→ローカル転送</div>
<ol>
<li> クライアントPC上で、以下のようにして簡単なサーバプロセスを起動する:
<pre>
client$ <strong>nc -l 10000</strong>
</pre>
<li> クライアントPC上で、「リモート→ローカル転送」を有効にしてサーバにログインする。
<pre>
client$ <strong>ssh <mark>-R 10000:localhost:10000</mark> server.example.com</strong>
</pre>
<li> サーバ上で、自分自身の TCP 10000番ポートに接続し、
  クライアントPCのプロセスに接続できていることを確認する。
<pre>
server$ <strong>nc localhost 10000</strong>
</pre>
</ol>
</div>

<hr>
<address>Yusuke Shinyama</address>
