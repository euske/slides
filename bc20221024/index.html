<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>(プログラマのための) UNIXの基礎</title>
<style><!--
body { line-height: 1.5; }
h1 { border-bottom: solid 4px #000088; }
h2 { border-bottom: solid 2px #000088; }
h3 { border-bottom: solid 1px #000088; }
table { border-collapse: collapse; }
td { padding: 4px; }
kbd { outline: 1px solid black; padding: 2px; }
pre { outline: 1px solid black; padding: 4px; overflow: auto; }
mark { font-weight: bold; }
pre, code { background: #ddd; font-size: 150%; font-family: courier; }
img { max-width: 80vw; height: auto; }
dt { text-decoration: underline; font-weight: bold; }
u { color: #880000; font-weight: bold; }
.author { text-align: right; }
.figure { outline: 1px solid black; padding: 0.5em; margin: 1em; text-align: center; }
.notice { font-size: 100%; font-weight: bold; background: #ffff88; outline: 2px solid black; padding: 0.5em; margin: 0.5em; }
.formula { background: #88ff88; outline: 2px solid black; padding: 1em; margin: 1em; }
.note { background: #ffff88; outline: 2px solid black; padding: 1em; margin: 1em; }
pre em { color: #008800; }
code em { color: #000088; }
.exercise { outline: 2px solid black; padding: 1em; margin: 1em; }
.exercise .header { font-size: 120%; font-weight: bold; border-bottom: solid 1px red; border-left: 4px solid red; padding-left: 8px; }
.file { outline: 2px solid black; padding: 1em; margin: 1em; }
.file .header { font-weight: bold; color: white; background: #000088; margin-bottom: 4px; padding-left: 1em; }
.file pre { margin: 0; }
--></style>
</head>
<body>
<div class=nav>
<a href="../index.html">&lt; もどる</a>
</div>
<h1>(プログラマのための) UNIXの基礎</h1>
<p>
勉強会資料 2022/10/24

<div class=author>
Yusuke Shinyama<br>
</div>

<ol>
<li> <a href="#unix">UNIXとは</a>
<ul>
  <li> <a href="#unix-os">オペレーティングシステム (OS) とは?</a>
</ul>
<li> <a href="#filesystem">ファイルシステム</a>
<ul>
  <li> <a href="#fs-path">パス名とは</a>
  <li> <a href="#fs-cd">カレント・ディレクトリ (カレント・フォルダ) とは</a>
  <li> <a href="#fs-abspath">絶対パス名と相対パス名</a>
  <li> <a href="#fs-relpath">相対パス名の表し方</a>
</ul>
<li> <a href="#process">プロセス</a>
<li> <a href="#stdio">標準入力・標準出力・標準エラー出力</a>
<li> <a href="#shell">シェル</a>
<ul>
  <li> <a href="#shell-exp">コマンド引数の展開</a>
  <li> <a href="#filename-exp">ファイル名の展開</a>
</ul>
<li> <a href="#env">環境変数</a>
<ul>
  <li> <a href="#env-use">環境変数を使う</a>
  <li> <a href="#env-set">環境変数を設定する</a>
  <li> <a href="#env-path">重要な環境変数: PATHとHOME</a>
</ul>
<li> <a href="#fileops">ファイル操作</a>
<li> <a href="#scripting">シェルスクリプトの基礎</a>
<ul>
  <li> <a href="#script-args">コマンドに与えられた引数を利用する</a>
  <li> <a href="#script-chmod">通常のコマンドとして使う</a>
</ul>
<li> <a href="#controls">繰り返し・条件分岐</a>
<li> <a href="#summary">まとめ</a>
</ol>

<h4>実行環境の準備</h4>
<div class=formula>
<a target="_blank" href="https://bellard.org/jslinux/vm.html?url=alpine-x86.cfg&amp;mem=192">JSLinux: ブラウザ上で動くLinuxエミュレータ</a>
</div>
<div class=formula>
<a target="_blank" href="https://mac.getutm.app/">UTM: M1 Mac上で動く仮想マシン</a>
に
<a target="_blank" href="https://docs.getutm.app/guides/ubuntu/">Ubuntu 22.04 をインストールする方法</a>。
</div>

<h4>おすすめの本</h4>
<ul>
<li> <a href="https://www.amazon.co.jp/dp/429713148X/">［試して理解］Linuxのしくみ　―実験と図解で学ぶOS、仮想マシン、コンテナの基礎知識【増補改訂版】</a>
- 最近評判のよい本。OS の内部まで学習したい人向け。
<li> <a href="https://www.amazon.co.jp/dp/B00KRB9U8K/">詳解UNIXプログラミング 第3版</a>
- 通称「Stevensの本」と呼ばれる歴史的名著。
</ul>


<h2 id="unix">1. UNIXとは</h2>
<p>
1970年ごろに作られた<u>オペレーティングシステム</u> (OS)。
以後の多くの OS が UNIX を継承あるいは模倣している。
以下ではこれらの「UNIX風OS」も含めて UNIX と呼称する。
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="450" height="300">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="1" fill="none">
    <rect x="180" y="10" width="80" height="40" />
    <rect x="30" y="140" width="80" height="40" />
    <rect x="140" y="140" width="80" height="40" />
    <rect x="250" y="140" width="80" height="40" />
    <rect x="360" y="140" width="80" height="40" />
    <rect x="10" y="60" width="80" height="40" />
    <rect x="140" y="240" width="80" height="40" />
    <g stroke-dasharray="4,4" marker-end="url(#arrow)">
      <path d="M100,80 L190,55" />
      <path d="M80,135 L200,60" />
    </g>
    <path d="M180,140 L220,50" />
    <path d="M290,140 L220,50" />
    <path d="M400,140 L220,50" />
    <path d="M180,240 L180,180" />
  </g>
  <g text-anchor="middle">
    <text x="220" y="40">UNIX v7</text>
    <text x="50" y="90">Windows</text>
    <text x="70" y="170">Linux</text>
    <text x="180" y="170">FreeBSD</text>
    <text x="290" y="155">NetBSD</text>
    <text x="290" y="175">OpenBSD</text>
    <text x="290" y="195">…</text>
    <text x="400" y="155">Solaris</text>
    <text x="400" y="175">HP-UX</text>
    <text x="400" y="195">…</text>
    <text x="180" y="270">macOS</text>
    <text x="120" y="65">模倣</text>
    <text x="130" y="100">模倣</text>
  </g>
</svg>
</div>
<p>
従来の (UNIXでない) OS と比べると、UNIX は非常に単純であった:
<ul>
<li> ファイルはただのバイト列
<li> ユーザは基本的に 2種類のみ (<u>スーパーユーザ</u>・<u>一般ユーザ</u>)
<li> すべてのファイルに所有者は1人のみ
</ul>

<h3 id="unix-os">1.1. オペレーティングシステム (OS) とは?</h3>
<p>
コンピュータの基本的な処理 (ディスク操作、
ネットワーク処理、画面表示など) を提供する<u>基本ソフトウェア</u>。
ほとんどの人は、このオペレーティングシステムを使った
アプリケーション (<u>応用ソフトウェア</u>) を書いている。
実際には、アプリはコンピュータで動いているソフトウェア全体のごく一部である。
また、OS は多くの仮想化処理 (ファイルシステム、遠隔操作、同時並列処理)
を実現している。

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="300" height="200">
  <g fill="white" stroke="black" stroke-width="2">
    <rect x="2" y="2" width="296" height="196" fill="#ddd" />
    <rect x="150" y="50" width="60" height="40"/>
    <rect x="50" y="110" width="60" height="40"/>
    <rect x="190" y="140" width="60" height="40"/>
  </g>
  <g text-anchor="middle">
    <text x="150" y="20" dy="0.5em">オペレーティングシステム (OS)</text>
    <text x="180" y="70" dy="0.5em">アプリ</text>
    <text x="80" y="130" dy="0.5em">アプリ</text>
    <text x="220" y="160" dy="0.5em">アプリ</text>
  </g>
</svg>
</div>


<h2 id="filesystem">2. ファイルシステム</h2>
<p>
UNIXは<u>階層型ファイルシステム</u> (hierarchical filesystem) という概念を導入している。
これはすべてのファイル・フォルダはひとつの巨大な<u>木構造</u> (tree) をなしている。
また、UNIXでは「すべてはファイルである」という考え方をおしすすめている。
そのため、メモリや画面 (端末) も <code>mem</code> や <code>tty</code> といった
特殊ファイルとして表現されている。
なお、 UNIXではフォルダのことを <u>ディレクトリ</u> (directory) と呼ぶ。

<h3 id="fs-path">2.1. パス名とは</h3>
<p>
ファイルシステム中のあらゆるファイルの位置は、
<u>パス名</u> (path) で表すことができる:

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g text-anchor="end">
      <text x="300" y="50">ディスク</text>
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
    </g>
    <g style="font-family: monospace;">
      <text x="400" y="50">/</text>
    </g>
  </g>
</svg>
</div>

<div class=exercise id="ex1">
<div class=header>演習 1. パス名の練習</div>
<ol class=spacy>
<li> <mark>ディレクトリ <code>X</code></mark> のパス名を書け。
<li> <mark>ファイル <code>H</code></mark> のパス名を書け。
<li> <mark>ファイル <code>C</code></mark> のパス名を 2つ書け。
</ol>
</div>

<h4>UNIXにおける「お約束」パス名</h4>
<p>
UNIX では、いくつかのパス名は
「お約束」として決められている。
<ul>
  <li> <code>/bin</code>: 実行可能ファイル (プログラム)</li>
  <li> <code>/home</code>: 各ユーザのホームディレクトリ</li>
  <li> <code>/etc</code>: 設定ファイル</li>
  <li> <code>/dev</code>: デバイスファイル</li>
  <li> …</li>
</ul>

<div class=exercise id="ex2">
<div class=header>演習 2. やってみよう</div>
<ul>
<li> <code>ls <em>パス名</em></code> … <em>パス名</em>に含まれているファイル一覧を表示する。
<blockquote><pre>
$ <strong>ls /etc</strong>
ImageMagick-7         logrotate.d           screenrc
X11                   lynx.cfg              securetty
alpine-release        lynx.lss              services
…
</pre></blockquote>
<li> <code>ls -l <em>パス名</em></code> … より詳細なメタデータとともに表示する。
<blockquote><pre>
$ <strong>ls -l /etc</strong>
total 516
drwxr-xr-x    2 root     root           434 Jul  5  2020 ImageMagick-7
drwxr-xr-x    4 root     root           114 Jul  5  2020 X11
-rw-r--r--    1 root     root             7 May 29  2020 alpine-release
drwxr-xr-x    4 root     root           164 Jan  9  2021 apk
…
</pre></blockquote>
<li> <code>cat <em>パス名</em></code> … ファイルの内容を表示する。
<blockquote><pre>
$ <strong>cat /etc/issue</strong>
Welcome to Alpine Linux 3.12
Kernel \r on an \m (\l)
</pre></blockquote>
UNIX ではどんなファイルも同様に扱われるので、
実は <code>cat</code>コマンドを使えば
あらゆるファイルの内容を (バイト列として) 表示できる。
しかし実際には JPEG などの画像ファイルをバイト列として表示しても
意味不明な文字列が表れるだけである。
<li> <code>less <em>パス名</em></code> … ファイルの内容を少しずつ表示する。
<blockquote><pre>
$ <strong>less /etc/services</strong>
</pre></blockquote>
<p>
lessでは以下のキー操作が使える:
<ul>
<li> <kbd>Space</kbd> … 次のページへ進む。
<li> <kbd>b</kbd> … 前のページへ戻る。
<li> <kbd>q</kbd> … 終了する。
<li> <kbd>j</kbd> … 1行下へ (↓)。
<li> <kbd>k</kbd> … 1行上へ (↑)。
<li> <kbd>/</kbd> … 文字列検索。
</ul>
</ul>
</div>

<p>
UNIXでは、各ファイルには以下のようなメタデータが付与されている:
<ul>
<li> ファイル名
<li> 所有者 (ユーザ)
<li> 最終更新日時
<li> サイズ
<li> 読み書き許可フラグ
<li> 実行可能フラグ
<li>
…
</ul>

<h3 id="fs-cd">2.2. カレント・ディレクトリ (カレント・フォルダ) とは</h3>
<ul>
  <li> パス名を使うことの問題: いくらでも長くなりうる!<br>
  例: <code>/Applications/Safari.app/Contents/MacOS/… </code>
  <li> いちいちパス名を入力するのは面倒。簡単にできないか?<br>
    → <strong>いま開いている・注目している</strong> (カレント, current)
    ディレクトリという考えを導入する。
</ul>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g stroke="red" fill="none" stroke-width="4">
      <rect x="120" y="250" width="110" height="100" />
      <line x1="220" y1="350" x2="340" y2="380" />
    </g>
    <g text-anchor="end">
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
      <text x="340" y="400" text-anchor="start" fill="red">カレント・ディレクトリ</text>
    </g>
  </g>
</svg>
</div>
</div>
</ul>

<h3 id="fs-abspath">2.3. 絶対パス名と相対パス名</h3>
<p>
実は「パス名」と呼ばれているものには 2つの種類がある。
上で説明した「パス名」は「<u>絶対パス名</u>」のことであった。
<ul>
<li> <u>絶対パス名</u>: <mark>ディスクの先頭から</mark>たどったパス名。
<li> <u>相対パス名</u>: <mark>カレント・ディレクトリから</mark>たどったパス名。
</ul>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g stroke="red" fill="none" stroke-width="4">
      <rect x="120" y="250" width="110" height="100" />
      <line x1="220" y1="350" x2="340" y2="380" />
      <rect x="210" y="390" width="110" height="100" stroke="blue" />
    </g>
    <g text-anchor="end">
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
      <text x="340" y="400" text-anchor="start" fill="red">カレント・ディレクトリ</text>
      <text x="340" y="490" text-anchor="start" fill="blue">目的のディレクトリ</text>
    </g>
  </g>
</svg>
</div>

<p>
つまり、上のディレクトリ <code>X</code> の位置は、次の2通りで表せる:
<ul>
  <li> 絶対パス名: <code>/A/<span style="color:red;">E</span>/<span style="color:blue;">X</span></code>
  <li> 相対パス名: <code><mark>.</mark>/<span style="color:blue;">X</span></code>
</ul>

<h3 id="fs-relpath">2.4. 相対パス名の表し方</h3>
<ul>
<li> 相対パス名では、カレント・ディレクトリの位置を<br>
  「<code>.</code> (ドット)」で表す:
  <code>./X</code>, <code>./K</code> など
<li> さらに、相対パス名では、ひとつ「上の」ディレクトリを<br>
  「<code>..</code>」で表せる。
<li> 相対パス名の能力は、絶対パス名と等価である。
つまり、絶対パスで表せるどんな位置も相対パス名によって表すことができる。<br>
例: <code>../../../../../../../Application</code> =
<code>/Application</code>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g stroke="red" fill="none" stroke-width="4">
      <rect x="120" y="250" width="110" height="100" />
      <line x1="220" y1="350" x2="340" y2="380" />
      <line x1="220" y1="30" x2="300" y2="50" />
      <line x1="50" y1="110" x2="110" y2="140" />
    </g>
    <g text-anchor="end">
      <text x="40" y="100" style="font-family:monospace;">..</text>
      <text x="220" y="20" style="font-family:monospace;">../..</text>
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
      <text x="340" y="400" text-anchor="start" fill="red">カレント・ディレクトリ</text>
    </g>
  </g>
</svg>
</div>
</ul>

<div class=exercise id="ex3">
<div class=header>演習 3. 相対パスの練習</div>
<p>
カレント・ディレクトリが <code>E</code> のとき…
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g stroke="red" fill="none" stroke-width="4">
      <rect x="120" y="250" width="110" height="100" />
      <line x1="220" y1="350" x2="340" y2="380" />
    </g>
    <g text-anchor="end">
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
      <text x="340" y="400" text-anchor="start" fill="red">カレント・ディレクトリ</text>
    </g>
  </g>
</svg>
</div>
<ol type=a>
  <li> ディレクトリ <code>A</code> への相対パス名は?
  <li> ファイル <code>H</code> への相対パス名は?
  <li> ファイル <code>K</code> への相対パス名は? (2つある)
</ol>
</div>

<div class=exercise id="ex4">
<div class=header>演習 4. やってみよう</div>
<ul>
<li> <code>cd パス名</code> … カレント・ディレクトリを指定されたパス名に変更する。
<li> <code>pwd</code> … カレント・ディレクトリを表示する。
<blockquote><pre>
$ <strong>pwd</strong>
/home/euske
$ <strong>cd /etc</strong>
$ <strong>pwd</strong>
/etc
</pre></blockquote>
<li> <code>ls</code> (パス名を省略) … カレント・ディレクトリに含まれているファイル一覧を表示する。
<li> <code>ls -l</code> (パス名を省略) … より詳細なメタデータとともに表示する。
</ul>
</div>


<h2 id="process">3. プロセス</h2>
<p>
ファイルシステム上で「<u>実行可能</u> (executable)」フラグ (<code>x</code>) がついている
ファイルはプログラムとして実行可能である。実行されたプログラムは、システム上で一定時間
<u>プロセス</u> (process) として走り続ける。UNIXはマルチタスクOSなので、通常は
複数のプロセスが並列に実行される。とはいえ実際の CPU は一度にひとつの
プログラムしか実行できないため、各プロセスは高速に切り替えられ
少しずつ (10ms程度) 実行される (時分割処理)。
これらプロセス切り替え処理は、OS の
<u>カーネル</u> (kernel) という部分がおこなう。

<h4>UNIXプロセスの特徴</h4>

<ul>
<li> あるプロセスから、さらに別のプロセス (<u>子プロセス</u>) を起動することができる。
このとき、もとのプロセスは <u>親プロセス</u> と呼ばれる。
<li> プログラミングにおける関数と同じように、各プロセスは
親プロセスから <u>引数</u> (argument) を受けとることができる。
また、プロセスは終了時に <u>終了状態</u> (exit code) を親プロセスに返す。
<li> プロセスも、ファイルと同じように「所有者」が存在する。
あるプロセスの権限は、それを起動したユーザの権限と同じになる。
<li> 各プロセスには以下のものが付属している:
<ul>
<li> プロセスID (固有の識別番号、<u>PID</u>)
<li> ユーザID (プロセスの所有者)
<li> カレント・ディレクトリ
<li> 標準入力・標準出力・標準エラー出力 (後述)
<li> 環境変数
<li> Control Group
</ul>
</ul>

<p>
UNIX 起動時には、まず最初のプロセスである <code>init</code>
(プロセスID: 1) が実行される。ここから他のすべてのプロセスが起動される。
UNIX の各プロセスは、<code>init</code> から先祖-子孫関係が存在し、
全体として木構造を形成している。
<blockquote><pre>
$ <strong>pstree</strong>
systemd─┬─agetty
        ├─automount───3*[{automount}]
        ├─avahi-daemon───avahi-daemon
        ├─crond
        ├─dbus-daemon
        ├─nmbd
        ├─ntpd───{ntpd}
        ├─smbd─┬─cleanupd
        │      ├─smbd
        │      └─smbd-notifyd
        ├─sshd
       ...
</pre></blockquote>

<div class=exercise id="ex5">
<div class=header>演習 5. やってみよう</div>
<ul>
<li> <code>ps x</code> … 自分が所有するプロセス一覧を表示する。
<blockquote><pre>
$ <strong>ps x</strong>
  PID TTY      STAT   TIME COMMAND
19857 ?        Ss     0:00 /lib/systemd/systemd --user
19858 ?        S      0:00 (sd-pam)
19872 ?        R      0:00 sshd: euske@pts/0
19874 pts/0    Ss     0:00 -bash
19880 pts/0    R+     0:00 ps x
</pre></blockquote>
<li> <code>ps ax</code> … すべてのプロセス一覧を表示する。
<blockquote><pre>
$ <strong>ps ax</strong>
  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     0:43 /sbin/init
    2 ?        S      0:00 [kthreadd]
    3 ?        I&lt;     0:00 [rcu_gp]
    4 ?        I&lt;     0:00 [rcu_par_gp]
…
</pre></blockquote>
<li> <code>ps aux</code> … より詳細な情報 (所有者) を表示する。
<li> <code>ps alx</code> … より詳細な情報 (親プロセスID) を表示する。
<li> <code>pstree</code> … プロセスの木構造を視覚的に表示する。
(注: pstreeコマンドは標準の macOS には存在しないので、
brewを使ってインストールする)
</ul>
</div>

<h4>実行中のプロセスを止めるには</h4>
<p>
UNIX のプロセスには、<u>シグナル</u> (signal) を送ることができる。
シグナルにはいくつかの種類がある:
<ul>
<li> <code>SIGTERM</code> … プロセスを正常終了させる。
<li> <code>SIGKILL</code> … プロセスを強制終了させる。(SIGTERMよりも強力で、最後の手段)
<li> <code>SIGINT</code> … プロセスの所属する端末 (標準入力) で <kbd>Control</kbd>+<kbd>C</kbd> が押されたときに送られる。たいていのプロセスは終了するが、プロセスはこれを無視することもできる。
<li> <code>SIGSEGV</code> … プロセスが異常な動作をしたときに、カーネルによって送られる。
ほとんどのプロセスは終了する。
</ul>

<div class=exercise id="ex6">
<div class=header>演習 6. やってみよう</div>
<ul>
<li> <code>kill <em>プロセスID</em></code> … 指定したプロセスに <code>SIGTERM</code> を送る。
<blockquote><pre>
$ <strong>sleep 60</strong>
または
$ <strong>find / </strong>
…

(別のウィンドウで)
$ <strong>ps x</strong>
$ <strong>kill 12345</strong>
</pre></blockquote>
<li> <code>kill -KILL <em>プロセスID</em></code> … 指定したプロセスに <code>SIGKILL</code> を送る。
</ul>
</div>


<h2 id="stdio">4. 標準入力・標準出力・標準エラー出力</h2>

<p>
UNIX の各プロセスには
「<u>標準入力</u> (stdin)」
「<u>標準出力</u> (stdout)」
「<u>標準エラー出力</u> (stderr)」
という 3つの仮想的な装置が付属している。
これらはプロセスが画面に文字を表示したり、
キーボードから文字を入力するために使用する。

<p>
まず、通常の状態では、プロセスの
標準入力・標準出力・標準エラー出力は、
どれも「<u>端末</u> (画面)」に接続されている。
(昔はこれはタイプライタや電話線だったが、現在ではおもに
ウィンドウ上の<u>仮想端末</u>が使われる。)

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="310" height="140">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="110" />
    <rect x="200" y="20" width="100" height="30" />
    <rect x="200" y="60" width="100" height="30" />
    <rect x="200" y="100" width="100" height="30" />
    <path d="M200,35 l-80,0" marker-end="url(#arrow)" />
    <path d="M110,75 l80,0" marker-end="url(#arrow)" />
    <path d="M110,115 l80,0" marker-end="url(#arrow)" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">プロセス</text>
    <text text-anchor="end" x="105" y="40">標準入力</text>
    <text text-anchor="end" x="105" y="80">標準出力</text>
    <text text-anchor="end" x="105" y="120">標準エラー出力</text>
    <text x="250" y="40">端末</text>
    <text x="250" y="80">端末</text>
    <text x="250" y="120">端末</text>
  </g>
</svg>
</div>

<p>
標準出力は、プロセスからの出力を表示するのに使われる:
<blockquote><pre>
$ <strong>./hello</strong>
hello, world.
</pre></blockquote>

<p>
いっぽう標準入力は、ユーザが文字を入力するのに使われる:
<blockquote><pre>
$ <strong>./greet</strong>
your name?
<strong>euske</strong>
greetings, euske
</pre></blockquote>

<p>
さて UNIX では、後述するシェルの機能を使うと、
標準出力を端末ではなくファイルに切り替える (<u>リダイレクト</u>する)
ことができる:
<blockquote><pre>
$ <strong>./hello &gt; output.txt</strong>
(テキストファイル output.txt が生成される)
</pre></blockquote>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="310" height="140">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="110" />
    <rect x="200" y="20" width="100" height="30" />
    <rect x="200" y="60" width="100" height="30" fill="#ffcccc" />
    <rect x="200" y="100" width="100" height="30" />
    <path d="M200,35 l-80,0" marker-end="url(#arrow)" />
    <path d="M110,75 l80,0" marker-end="url(#arrow)" />
    <path d="M110,115 l80,0" marker-end="url(#arrow)" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">hello</text>
    <text text-anchor="end" x="105" y="40">標準入力</text>
    <text text-anchor="end" x="105" y="80">標準出力</text>
    <text text-anchor="end" x="105" y="120">標準エラー出力</text>
    <text x="250" y="40">端末</text>
    <text style="font-family:monospace;" x="250" y="80">output.txt</text>
    <text x="250" y="120">端末</text>
  </g>
</svg>
</div>

<p>
また、標準<strong>入力</strong>を端末ではなくファイルにリダイレクトすることも
可能である:
<blockquote><pre>
(テキストファイル input.txt を作成する)
$ <strong>./greet &lt; input.txt</strong>
your name?
greetings, test
</pre></blockquote>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="310" height="140">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="110" />
    <rect x="200" y="20" width="100" height="30" fill="#88ff88" />
    <rect x="200" y="60" width="100" height="30" />
    <rect x="200" y="100" width="100" height="30" />
    <path d="M200,35 l-80,0" marker-end="url(#arrow)" />
    <path d="M110,75 l80,0" marker-end="url(#arrow)" />
    <path d="M110,115 l80,0" marker-end="url(#arrow)" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">greet</text>
    <text text-anchor="end" x="105" y="40">標準入力</text>
    <text text-anchor="end" x="105" y="80">標準出力</text>
    <text text-anchor="end" x="105" y="120">標準エラー出力</text>
    <text style="font-family:monospace;" x="250" y="40">input.txt</text>
    <text x="250" y="80">端末</text>
    <text x="250" y="120">端末</text>
  </g>
</svg>
</div>

<p>
さらに、UNIX には「<u>パイプ</u> (pipe)」という機能がある。
これを使うと
「あるプロセスの標準<strong>出力</strong>を、別のプロセスの標準<strong>入力</strong>に」
リダイレクトすることができる:

<blockquote><pre>
$ <strong>./hello | ./greet</strong>
your name?
greetings, hello, world.
</pre></blockquote>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="650" height="180">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="110" />
    <rect x="180" y="20" width="100" height="30" />
    <ellipse cx="230" cy="75" rx="50" ry="15" fill="#ffff88" />
    <rect x="180" y="100" width="100" height="30" />
    <path d="M180,35 l-60,0" marker-end="url(#arrow)" />
    <path d="M110,75 l60,0" marker-end="url(#arrow)" />
    <path d="M110,115 l60,0" marker-end="url(#arrow)" />
    <rect x="350" y="60" width="100" height="110" />
    <rect x="520" y="100" width="100" height="30" />
    <rect x="520" y="140" width="100" height="30" />
    <path d="M280,75 l60,0" marker-end="url(#arrow)" />
    <path d="M450,115 l60,0" marker-end="url(#arrow)" />
    <path d="M450,155 l60,0" marker-end="url(#arrow)" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">hello</text>
    <text text-anchor="end" x="105" y="40">標準入力</text>
    <text text-anchor="end" x="105" y="80">標準出力</text>
    <text text-anchor="end" x="105" y="120">標準エラー出力</text>
    <text x="230" y="40">端末</text>
    <text x="230" y="80">パイプ</text>
    <text x="230" y="120">端末</text>
    <text x="400" y="55">greet</text>
    <text text-anchor="start" x="355" y="80">標準入力</text>
    <text text-anchor="end" x="445" y="120">標準出力</text>
    <text text-anchor="end" x="445" y="160">標準エラー出力</text>
    <text x="570" y="120">端末</text>
    <text x="570" y="160">端末</text>
  </g>
</svg>
</div>

<div class=exercise id="ex7">
<div class=header>演習 7. やってみよう</div>
<ul>
<li> 以下のコマンドを実行し、ls の出力がテキストファイルになっていることを確認せよ。
<blockquote><pre>
$ <strong>ls -l > output.txt</strong>
</pre></blockquote>
<li> <code>grep</code>コマンドを使うと、
標準入力から特定のパターンが含まれる行だけを表示できる:
<blockquote><pre>
$ <strong>ls -l | grep .conf</strong>
-rw-r--r--    1 root     root          5613 Jun 18  2020 ca-certificates.conf
drwxr-xr-x    2 root     root           520 Jul  5  2020 conf.d
-rw-r--r--    1 root     root          1102 Jul  6  2020 dhcpcd.conf
…
</pre></blockquote>
<li> <code>sort</code>コマンドを使うと、
標準入力の各行を昇順あるいは降順に並べ替え (ソート) できる:
<blockquote><pre>
$ <strong>ls -l | sort</strong> (各列の行頭からアルファベット順にソート)
…
$ <strong>ls -l | sort +2</strong> (空白で区切られた 2番目の列を基準にソート)
…
$ <strong>ls -l | sort -n +4</strong> (数値としてソート)
…
$ <strong>ls -l | sort -n -r +4</strong> (reverse, 逆順に表示)
…
</pre></blockquote>
<p>
このように、UNIX のコマンドは "<code>-</code>" や "<code>+</code>" で始まる
文字列を与えることにより異なった動きをするものが多い。
(これは何か規則があるわけではなく、ただの慣例である。)
このような文字列を一般にコマンドの「<u>オプション</u> (option)」と呼ぶ。

</ul>
</div>

<p>
パイプによる複数プロセスの接続は UNIX (シェル) の特徴的な機能のひとつである。
これをうまく使うと、複雑な処理をいくつかのコマンドの組み合わせによって
実現することができる。
<blockquote><pre>
(ls コマンドの出力を検索し、さらにそれをソートして最初の10行を表示する)
$ <strong>ls -l | grep euske | sort | head -n10</strong>
</pre></blockquote>

<div class=note>
<strong>注意:</strong>
<code>&lt;</code> や <code>&gt;</code> による
標準入力・標準出力の切り替えは、
プロセスを<strong>起動する瞬間</strong>にしか指定できない。
いちどプロセスが起動してしまうと、あとから
切り替えることはできないので注意。
</div>

<div class=note>
<strong>注意:</strong>
UNIX は無愛想な OS なので、
<code>&gt;</code> の出力先として
うっかり存在するファイル名を指定してしまうと、
そのファイルは<strong>何の警告もなく</strong>上書きされ、
空のファイルされる。
</div>


<h2 id="shell">5. シェル</h2>
<p>
以上に挙げたような各プロセスの起動、標準入力・標準出力の切り替えなどを
おこなうプログラムが<u>シェル</u> (shell) である。
シェルは UNIX を使ううえで中心的な役割を果たしている。
UNIX 上で「<u>コマンド</u> (command)」と呼ばれるものは、
実はほとんどシェルによって起動されるプロセスである。
しかもたいていのコマンド (プロセス) は数ミリ秒〜数秒しか生存しない。
通常の PC では、アプリ (これもプロセス) は一度起動したら
長時間走らせておくのが普通だが、
UNIX は「湯水のようにプロセスを消費する」OSである。

<p>
シェルの役割には、以下のものがある:
<ul>
<li> プロセスの起動
<li> プロセスの終了 (シグナルの送信)
<li> プロセス起動時の標準入力・標準出力・標準エラー出力の切り替え
<li> プロセス起動時の環境変数 (後述) の設定
<li> カレント・ディレクトリの切り替え
</ul>

<p>
実は UNIX では、シェルも普通のプロセスである。
そのため (<code>sh</code>, <code>csh</code>, <code>bash</code>, <code>zsh</code> など)
いろいろなシェルが開発されている。
ほとんどの場合、シェルは以下の動作を繰り返しているだけである:
<ol>
<li> 端末 (標準入力) からコマンド文字列が入力されるのを待つ。
<li> 文字列を解析し、スペースで区切られた引数のリストを作成する (<u>引数展開</u>)。
<li> 必要に応じて標準入力・標準出力・標準エラー出力を切り替えて、子プロセスを起動する。
<li> 子プロセスが終了するのを待ち、終了状態を受けとる。
<li> 1. に戻る。
</ol>

<h3 id="shell-exp">5.1. コマンド引数の展開</h3>
<p>
先に述べたように、UNIX コマンドのほとんどは実はプロセスであり (例外も存在する)、
シェルの主な機能はコマンド文字列を解析し、プロセスを起動することである。
たとえば
<blockquote><pre>
$ <strong>ls -l /etc</strong>
</pre></blockquote>
という行は、以下の行と同じである:
<blockquote><pre>
$ <strong>/bin/ls -l /etc</strong>
</pre></blockquote>
<p>
この行が入力されたとき、シェルは以下のことをおこなう:
<ol>
<li> <code>/bin/ls</code> というプログラムを子プロセスとして起動する。
<li> このとき、各引数を文字列としてプロセスに渡す:
<ul>
<li> <code>ls</code> … 0番目の引数 (コマンド名あるいはプログラムのパス名)
<li> <code>-l</code> … 1番目の引数
<li> <code>/etc</code> … 2番目の引数
</ul>
<li> 子プロセスが終了するまで待つ。
</ol>
<p>
ここで注意したいのは、引数である
「<code>-l</code>」や「<code>/etc</code>」をどのように利用するかは
<strong>各コマンド次第</strong>ということである。
すべてのコマンドにおいて
「<code>-l</code>」がオプションであると決まっているわけではないし
「<code>/etc</code>」がパス名として解釈されるとも限らない。
この意味で、UNIX の使い方を学ぶことは
API の使い方を学ぶのに似ている。
個々の関数・メソッドの引数がどのような意味をもつのか学習し、
それらを組み合わせて必要な処理を実現する。

<div class=note>
<strong>注意:</strong>
もし実際に
「<code>-l</code>」という名前のディレクトリがあったとすると、
そのままでは <code>ls</code> のパス名として指定できない。
だが <code>ls ./-l</code> というトリックを使えば指定できる。)
</div>

<p>
たとえば <code>echo</code> というコマンドは、シェルから与えらえた引数をただそのまま
表示するだけのコマンドである:
<blockquote><pre>
$ <strong>echo abc 1234</strong>
abc 1234
$ <strong>echo -l /etc</strong>
-l /etc
</pre></blockquote>

<p>
一般にシェルの引数は「<code> </code> 」(スペース) で
区切られるが、<code>"〜"</code> で囲むことにより
スペースが入っている文字列を「ひとつの引数」として認識させることができる:
<blockquote><pre>
$ <strong>ls -l /etc</strong>
…
$ <strong>ls "-l /etc"</strong>
ls: invalid option -- ' '
$ <strong>"ls -l" /etc</strong>
ls -l: command not found
</pre></blockquote>

<div class=exercise id="ex8">
<div class=header>演習 8. シェルの引数展開</div>
<p>
以下のコマンドラインの引数を 0番目からすべて挙げよ:
<ol class=spacy>
<li> <code>ls /etc /bin</code>
<li> <code>ls "/etc /bin"</code>
<li> <code>ls "/etc" "/bin"</code>
<li> <code>ls "" "/bin"</code>
<li> <code>"ls /etc /bin"</code>
</ol>
</div>

<h3 id="filename-exp">5.2. ファイル名の展開</h3>
<p>
シェルでは、ディレクトリ上に複数のファイルがあるとき、
それらのファイル名を複数の引数として展開する機能がある
(<u>ファイル名展開</u>, filename expansion)。
<p>
たとえば、カレント・ディレクトリ内に
<code>a</code>, <code>bb</code>, <code>ccc</code>
というファイルがあるとき…
<blockquote><pre>
$ <strong>ls</strong>
a   bb   ccc
</pre></blockquote>
以下の <code>*</code> (<u>ワイルドカード</u>) を指定すると
<blockquote><pre>
$ <strong>cat *</strong>
</pre></blockquote>
以下の引数を与えたのと同じである:
<blockquote><pre>
$ <strong>cat a bb ccc</strong>
</pre></blockquote>
<p>
ワイルドカードには、パターンを指定することもできる。
たとえば <code>/etc</code> 内に多くの「<code>.conf</code>」で終わるファイルがあるとき…
<blockquote><pre>
$ <strong>ls -l | grep .conf</strong>
-rw-r--r--    1 root     root          5613 Jun 18  2020 ca-certificates.conf
drwxr-xr-x    2 root     root           520 Jul  5  2020 conf.d
-rw-r--r--    1 root     root          1102 Jul  6  2020 dhcpcd.conf
…
</pre></blockquote>
以下のパターンは
<blockquote><pre>
$ <strong>cat /etc/*.conf</strong>
</pre></blockquote>
以下のような引数に展開される:
<blockquote><pre>
$ <strong>cat /etc/ca-certificates<mark>.conf</mark> /etc/dhcpcd<mark>.conf</mark> …</strong>
</pre></blockquote>
<p>
繰り返すが、ここで展開されたパス名をどのように扱うかは
<strong>各コマンド次第</strong>である。
シェルがファイル名展開したからといって、
各コマンドがこれらをファイル名として扱う保証はない。
<p>
ここで、<code>echo</code> コマンドは
シェルが各引数をどのように展開したかを表示するのに使える:
<blockquote><pre>
$ <strong>echo /etc/*.conf</strong>
/etc/ca-certificates.conf /etc/dhcpcd.conf …
</pre></blockquote>

<div class=exercise id="ex9">
<div class=header>演習 9. ファイル名展開</div>
<p>
<code>/etc</code> 以下に次のようなファイルがあるとする:
<ul>
<li> <code>a.conf</code>
<li> <code>b.conf</code>
<li> <code>issue</code>
</ul>
カレント・ディレクトリも <code>/etc</code> であるとして、
以下のコマンドラインの出力を答えよ:
<ol class=spacy>
<li> <code>echo *</code>
<li> <code>echo *.conf</code>
<li> <code>echo *.conf /etc/*</code>
<li> <code>echo /etc/issue*</code>
<li> <code>echo "*"</code>
</ol>
</div>

<h4>Dockerの原理</h4>
<p>
各プロセスに所属する Control Group (cgroup) という機能を使うと、
あるプロセス (およびその子孫プロセスすべて) からアクセスできる
ファイルやネットワークを制限することができる。

つまるところ、docker がやっているのは、ある Control Group 内で
プロセスを起動し、それ以降のすべての子プロセスを
特定の空間に閉じ込める (containする) ことによって
各プロセスが独立したマシン上で動いているかのように
見せかけているだけなのである。


<h2 id="env">6. 環境変数</h2>
<p>
UNIX では、各プロセスに<u>環境変数</u> (environment variable) というものが
付属している。これは各種の設定を保持しておくための文字列型の変数で、
プログラムの変数と同様に、好きな数だけ作成することができる。
<p>
現在の環境変数一覧を見るためには <code>env</code>コマンドを使う:
<blockquote><pre>
$ <strong>env</strong>
SHELL=/bin/bash
WINDOWID=4194316
TMUX=/tmp/tmux-1000/default,366,0
EDITOR=vi
…
</pre></blockquote>
<p>
順序がばらばらで見にくいので <code>sort</code>で並べ変えてみる:
<blockquote><pre>
$ <strong>env | sort</strong>
DISPLAY=:1
EDITOR=vi
HOME=/home/euske
…
</pre></blockquote>
<p>
注意: Windowsの環境変数と違い (実際にはWindowsもそうなのだが)、
<strong>UNIXにおける環境変数は各プロセスごとに独立している</strong>。
あるプロセスの環境変数を別のプロセスの環境変数にすることはできない。
ただし、<strong>親プロセスの環境変数は、子プロセスに引きつがれる</strong>ため、
最初に共通の環境変数を設定しておけば、以後すべての子プロセスで
共通の設定を利用することができる。

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="310" height="180">
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="60" />
    <rect x="170" y="20" width="100" height="60" />
    <rect x="170" y="110" width="100" height="60" />
    <path d="M110,50 l60,0 M110,50 m30,0 l0,90 l30,0" />
    <path d="M270,50 l20,0" />
    <path d="M290,50 l20,0" stroke-dasharray="4,4" />
    <path d="M270,140 l20,0" />
    <path d="M290,140 l20,0" stroke-dasharray="4,4" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">親プロセス</text>
    <text x="220" y="15">子プロセス</text>
    <text x="220" y="105">子プロセス</text>
  </g>
  <g style="font-size:75%; font-family: monospace">
    <text x="20" y="40">USER=yusuke</text>
    <text x="180" y="40">USER=yusuke</text>
    <text x="180" y="60">DATABASE=alpha</text>
    <text x="180" y="130">USER=yusuke</text>
    <text x="180" y="150">DATABASE=beta</text>
  </g>
</svg>
</div>

<h3 id="env-use">6.1. 環境変数を使う</h3>
<p>
各プロセスにおける環境変数は、
プログラム中のどこからでも文字列値として
アクセス可能である:

<h4>Node (JavaScript) の場合</h4>
<blockquote><pre>
<em>// 環境変数USERの値を取得する。</em>
const user = process.env['USER']
</pre></blockquote>

<h4>Java の場合</h4>
<blockquote><pre>
<em>// 環境変数USERの値を取得する。</em>
String user = System.getenv("USER");
</pre></blockquote>

<h4>Kotlin の場合</h4>
<blockquote><pre>
<em>// 環境変数USERの値を取得する。</em>
val user: String? = System.getenv("USER")
</pre></blockquote>

<p>
慣例により、環境変数の名前には大文字が使われることが多い
(実際には、英数字であればなんでもよい)。

<h4>シェルの場合</h4>
<p>
シェルでは、コマンドライン引数に含まれる環境変数の値が展開される。
たとえば環境変数 <code>USER</code> に <code>euske</code> という値が入っている場合、
<blockquote><pre>
$ <strong>ls /home/<mark>${USER}</mark>/foo</strong>
</pre></blockquote>
は、以下のように展開される:
<blockquote><pre>
$ <strong>ls /home/euske/foo</strong>
</pre></blockquote>
<p>
<code>echo</code>コマンドは、環境変数の内容を確認するためによく使われる:
<blockquote><pre>
$ <strong>echo ${USER}</strong>
euske
</pre></blockquote>
<p>
未定義の環境変数を展開してもエラーにはならず、空文字列として扱われる:
<blockquote><pre>
$ <strong>echo /home/${USSR}/foo</strong>
/home//foo
</pre></blockquote>
<p>
なお、<code>${〜}</code>の中カッコは省略可能である:
<blockquote><pre>
$ <strong>echo $USER</strong>
euske
</pre></blockquote>

<h4>高度な機能</h4>
<p>
シェルには変数を展開するさいにさまざまな演算をおこなう機能がある。
たとえば
<blockquote><pre>
$ <strong>echo ${USER/xxx/yyy}</strong>  <em>(USER中の xxx を yyyに置換した文字列に展開される)</em>
$ <strong>echo ${LANG:-ja}</strong>      <em>(LANGが定義されていない場合、デフォルト値としてjaに展開される)</em>
</pre></blockquote>

<div class=exercise id="ex10">
<div class=header>演習 10. 環境変数の展開</div>
<p>
環境変数 <code>USER</code> に <code>jon</code> という文字列が、
環境変数 <code>FILE</code> に <code>athan</code> という文字列が、
入っているとき、以下のコマンドの出力を答えよ:
<ol>
<li> <code>echo /home/${USER}/${FILE}</code>
<li> <code>echo $USER$FILE</code>
<li> <code>echo "$USER"ny</code>
<li> <code>echo $USERny</code>
</ol>
</div>

<h3 id="env-set">6.2. 環境変数を設定する</h3>
<p>
各プロセスの環境変数は、一般にそのプロセスの<strong>起動時にだけ</strong>設定できる。
プロセスの起動時に環境変数を設定するには、実行したいコマンド引数の前に
「<code><strong>変数名</strong>=<strong>値</strong></code>」のような形式を追加する。
たとえば <code>date</code> コマンドは、
環境変数 <code>TZ</code> の値によって異なる時間帯の時刻を返す:
<blockquote><pre>
$ <strong>date</strong>
Mon Oct 31 06:56:48 JST 2022
$ <strong><mark>TZ=UTC</mark> date</strong>
Sun Oct 30 21:56:48 UTC 2022
$ <strong><mark>TZ=America/New_York</mark> date</strong>
Sun Oct 30 17:56:48 EDT 2022
</pre></blockquote>
<p>
また、親プロセスが持っている環境変数はすべて子プロセスに継承される。
そのため親プロセスに環境変数を設定しておけば、すべての子プロセスで共通の値が使える:
<blockquote><pre>
$ <strong>echo $XYZ</strong>       <em>(環境変数XYZは未定義)</em>

$ <strong>XYZ=abc123 zsh</strong>  <em>(環境変数XYZにabc123を設定して zshを起動)</em>
$ <strong>echo $XYZ</strong>       <em>(環境変数XYZに値が入っている)</em>
ABC123
</pre></blockquote>

<p>
例外はシェルで、シェルの中ではいつでも環境変数を作成・変更できる。
実際には、環境変数はより一般的な<u>シェル変数</u> (shell variable) の一部として扱われる。
シェル変数の一覧 (環境変数も含む) を表示するには
<code>set</code>コマンドを使う:
<blockquote><pre>
$ <strong>set</strong>
BASH=/bin/bash
COLUMNS=100
DISPLAY=:1
EDITOR=vi
…
</pre></blockquote>
<p>
シェル変数は、ただ
「<code><strong>変数名</strong>=<strong>値</strong></code>」のように書けば
値を設定できる。
<blockquote><pre>
$ <strong>XYZ=abc123</strong>  <em>(シェル変数XYZにabc123を設定)</em>
$ <strong>echo $XYZ</strong>   <em>(シェル変数XYZの値を表示する)</em>
</pre></blockquote>

<p>
ただし、<strong>すべてのシェル変数が環境変数として扱われるわけではない</strong>ことに注意。
環境変数として扱われるのは、シェル変数のうち
「export属性」をもつものだけである。
Export属性をもったシェル変数は、何も指定しなくても
以後シェルから起動したすべてのプロセスに環境変数として渡される:
<blockquote><pre>
$ <strong>XYZ=abc123</strong>  <em>(シェル変数XYZにabc123を設定)</em>
$ <strong>echo $XYZ</strong>   <em>(シェル変数XYZの値を表示する)</em>
abc123
$ <strong>env</strong>         <em>(XYZは環境変数ではない)</em>
…
$ <strong>export XYZ</strong>  <em>(XYZにexport属性をつける)</em>
$ <strong>env</strong>         <em>(XYZが環境変数として渡されている)</em>
…
XYZ=abc123
…
</pre></blockquote>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="220" height="220">
  <g stroke="black" stroke-width="2" fill="none">
    <circle cx="110" cy="110" r="100" />
    <circle cx="140" cy="150" r="45" />
  </g>
  <g text-anchor="middle">
    <text x="110" y="80">シェル</text>
    <text x="110" y="100">変数</text>
    <text x="140" y="150">環境変数</text>
  </g>
</svg>
</div>

<h3 id="env-path">6.3. 重要な環境変数: PATHとHOME</h3>
<p>
UNIX の環境変数のなかでも <code>PATH</code> と <code>HOME</code> は
とくに重要である。
<h4>環境変数 PATH</h4>
<p>
通常、UNIX シェルでは第0引数としてコマンド (プログラム) のパス名を指定する:
<blockquote><pre>
$ <strong>/bin/ls -l /etc</strong>
</pre></blockquote>
しかし実際には以下のように書いても動く:
<blockquote><pre>
$ <strong>ls -l /etc</strong>
</pre></blockquote>
これを可能にしているのは環境変数 <code>PATH</code> のためである。
環境変数 <code>PATH</code> の中身を見てみると、
コロン (<code>:</code>) で区切られたパス名 (ディレクトリ名) の一覧が含まれているのがわかる:
<blockquote><pre>
$ <strong>echo $PATH</strong>
<mark>/usr/local/bin</mark>:<mark>/usr/bin</mark>:<mark>/bin</mark>
</pre></blockquote>
<p>
これは「あるコマンドが実行されたとき、
<code>/usr/local/bin/<em>コマンド名</em></code>、
<code>/usr/bin/<em>コマンド名</em></code>、
<code>/bin/<em>コマンド名</em></code>
のいずれかのプログラムを実行せよ」ということを表している。
PATH にはこのようなコマンドの「検索順序」が記録されている。
その証拠に、<code>PATH</code> をおかしな値にすると動かない:

<blockquote><pre>
$ <strong>PATH=xxx</strong>
$ <strong>ls</strong>
ls: command not found
$ <strong>/bin/ls</strong>
…
</pre></blockquote>

<p>
なお、<code>PATH</code> はよくシステムのデフォルト値をカスタマイズして
使うことが多い。<code>PATH</code> に独自のディレクトリを追加するには、以下のようにする:
<blockquote><pre>
PATH=$PATH:/home/euske/bin  <em>(/home/euske/bin もコマンド検索順序に追加する)</em>
</pre></blockquote>

<h4>環境変数 HOME</h4>
<p>
UNIX では、各ユーザのホームディレクトリは
<code>/home/<em>ユーザ名</em></code> とされているが、
これはただの慣例であり、実際にはどこであってもかまわない。
環境変数 <code>HOME</code> は、そのユーザの所有する
<u>ホームディレクトリ</u>のパス名を指定する。
これは起動時には通常そのユーザのデフォルト値が設定されているが、
この値を変更することで、どんなディレクトリでもホームディレクトリとして
使用することができる:
<blockquote><pre>
$ <strong>echo $HOME</strong>  <em>(環境変数HOMEの内容を表示する)</em>
/home/euske
$ <strong>cd</strong>          <em>(ホームディレクトリに移動)</em>
$ <strong>pwd</strong>         <em>(カレント・ディレクトリを表示)</em>
/home/euske
$ <strong>HOME=/etc</strong>   <em>(環境変数HOMEを変更する - ホームディレクトリが変更される)</em>
$ <strong>cd</strong>          <em>(ホームディレクトリに移動)</em>
$ <strong>pwd</strong>         <em>(カレント・ディレクトリを表示)</em>
/etc
</pre></blockquote>
<p>
また、シェルのコマンドライン上では <code>~</code> が
自分のホームディレクトリに展開されるが、
この値も実際には環境変数 <code>HOME</code> を展開しているだけである:
<blockquote><pre>
$ <strong>echo $HOME/work</strong>
/home/euske/work
$ <strong>echo ~/work</strong>
/home/euske/work
</pre></blockquote>
<p>
UNIX では、各ユーザのデフォルトのホームディレクトリ (やシェル) は
<code>/etc/passwd</code> というテキストファイル内に記載されている。
UNIX におけるホームディレクトリとは、つまるところ:
<ul>
<li> そのユーザが所有している
<li> 環境変数 <code>HOME</code> が、そのパス名に設定されている
</ul>
だけのものなのである。


<h2 id="fileops">7. ファイル操作</h2>
<p>
シェル上でファイル操作を行うためのおもなコマンドは以下のとおり:
<dl>
<dt> <code>ls</code>
<dd> 指定したディレクトリに含まれるファイル一覧を表示する。
<pre>
$ <strong>ls</strong>
…  <em>(カレント・ディレクトリのファイル一覧を表示)</em>
$ <strong>ls /etc</strong>
…  <em>(ディレクトリ /etc のファイル一覧を表示)</em>
</pre>
<dt> <code>cd</code> (Change Directory)
<dd> カレント・ディレクトリを変更する。
<pre>
$ <strong>cd /etc</strong>
<em>(カレント・ディレクトリを /etc に変更)</em>
$ <strong>cd</strong>
<em>(カレント・ディレクトリを自分のホームディレクトリに変更)</em>
</pre>
<dt> <code>pwd</code> (Print Working Directory)
<dd> カレント・ディレクトリのパス名を表示する。
<pre>
$ <strong>pwd</strong>
<em>(現在のパス名を表示)</em>
</pre>
<dt> <code>cat</code> ・ <code>less</code>
<dd> ファイルの内容を表示する。
もともと <code>cat</code> は
複数のファイルを連結 (conCATenate) するためのコマンドだった。
<pre>
$ <strong>less /etc/services</strong>
<em>(/etc/services の内容を表示)</em>
$ <strong>cat /etc/hosts /etc/services</strong>
<em>(/etc/hosts の内容と /etc/services の内容を連結して表示)</em>
</pre>
<dt> <code>mkdir</code> (MaKe DIRectory)
<dd> 空のディレクトリを新規作成する。
<pre>
$ <strong>mkdir foo</strong>
<em>(カレント・ディレクト下に foo を作成)</em>
</pre>
<dt> <code>cp</code> (CoPy)
<dd> 指定したファイルを宛先パス名に複製する。
<pre>
$ <strong>cp a.txt b.txt</strong>
<em>(a.txt を新しい b.txt という名前で複製する)</em>
$ <strong>cp a.txt dist/</strong>
<em>(a.txt を dist/ ディレクトリ内に同じ名前で複製する)</em>
$ <strong>cp a.txt b.txt c.txt dist/</strong>
<em>(a.txt, b.txt, c.txt の各ファイルを dist/ 内に同じ名前で複製する)</em>
$ <strong>cp *.txt dist/</strong>
<em>(〜.txt で終わるすべてのファイルを dist/ 内に同じ名前で複製する)</em>
</pre>
<p>
<strong>注意:</strong>
UNIX は無愛想な OS なので、
コピー先としてうっかり存在するファイル名を指定してしまうと、
そのファイルは<strong>何の警告もなく</strong>上書きされる。
これを防ぐためには <code>-i</code> オプションを使う:
<pre>
$ <strong>cp -i a.txt b.txt</strong>
<em>(a.txt を新しい b.txt という名前で複製するが、
 すでに同名のファイルがある場合は確認する)</em>
</pre>
<dt> <code>mv</code> (MoVe)
<dd> 指定したファイルを宛先パス名に変更あるいは移動する。
<pre>
$ <strong>mv a.txt b.txt</strong>
<em>(a.txt を新しい b.txt という名前に変更する)</em>
$ <strong>mv a.txt dist/</strong>
<em>(a.txt を dist/ ディレクトリ内に移動する)</em>
$ <strong>mv a.txt b.txt c.txt dist/</strong>
<em>(a.txt, b.txt, c.txt の各ファイルを dist/ 内に移動する)</em>
$ <strong>mv *.txt dist/</strong>
<em>(〜.txt で終わるすべてのファイルを dist/ 内に移動する)</em>
</pre>
<p>
<strong>注意:</strong>
UNIX は無愛想な OS なので、
移動先としてうっかり存在するファイル名を指定してしまうと、
そのファイルは<strong>何の警告もなく</strong>上書きされる。
これを防ぐためには <code>-i</code> オプションを使う:
<pre>
$ <strong>mv -i a.txt b.txt</strong>
<em>(a.txt を新しい b.txt という名前に変更するが、
 すでに同名のファイルがある場合は確認する)</em>
</pre>

<dt> <code>rm</code> (ReMove)
<dd> 指定したファイルを削除する。
<pre>
$ <strong>rm a.txt</strong>
<em>(ファイル a.txt を削除する)</em>
$ <strong>rm *.txt</strong>
<em>(〜.txt で終わるすべてのファイルを削除する)</em>
</pre>
<p>
<code>rm</code> で削除できるのは、通常はファイルのみである。
あるディレクトリ内のファイルを (ディレクトリごと) 削除したい場合には
<code>-r</code> オプションを使う:
<pre>
$ <strong>rm -r dist/</strong>
<em>(dist/ ディレクトリ内とその中のファイルをすべて削除する)</em>
</pre>
<p>
<strong>注意:</strong>
UNIX は無愛想な OS なので、
<code>rm</code> コマンドは削除が成功しても何も表示しない。
削除するファイルをひとつずつ確認するためには
<code>-i</code> オプションを使う:
<pre>
$ <strong>rm -i *.txt</strong>
<em>(〜.txt で終わる各ファイルを yes/no で確認しながら削除する)</em>
</pre>

</dl>

<h4>パス名の指定方法に注意</h4>
<p>
<code>cp</code>, <code>mv</code>, <code>rm</code> などのコマンドでは
「<code>-</code>」で始まる引数はオプションとみなされる。
もし実際に "<code>-i</code>" というファイルを複製したい場合、
<code>cp -i a.txt</code> などとやってもうまくいかない:
<blockquote><pre>
$ <strong>cp -i a.txt</strong>
cp: missing destination file operand after 'a'
<em>(エラーが出て実行できない)</em>
</pre></blockquote>
<p>
このような場合には、2つの方法がある:
<ol type=a>
<li> 引数が「<code>-</code>」で始まらなけれさえすればよいので、
<code>-i</code> がカレント・ディレクトリにあることを利用して、
以下のようにする:
<blockquote><pre>
$ <strong>cp ./-i a.txt</strong>
<em>(カレント・ディレクトリの -i というファイルがコピーされる)</em>
</pre></blockquote>
<li> 多くの UNIX 標準コマンドは、引数に "<code>--</code>" が表れると、
それ以後の引数をオプションとして解釈することをやめ、
ファイル名として解釈するように実装されている。
このことを利用して:
<blockquote><pre>
$ <strong>cp -- -i a.txt</strong>
<em>(-i はオプションでなく実際のファイル名として解釈される)</em>
</pre></blockquote>
</ol>


<h2 id="scripting">8. シェルスクリプトの基礎</h2>
<p>
<u>シェルスクリプト</u>とは、シェルによって実行される簡単なプログラムである。
もっとも基本的なシェルスクリプトは、単に実行するコマンド列を1行にひとつずつ
並べたテキストファイルである:
<div class=file>
<div class=header>hello.sh</div>
<pre>
echo Hello!
date
ls /etc
</pre>
</div>
<p>
シェルスクリプトを実行するには、シェルの引数としてスクリプトの
ファイル名を与えればよい。シェルスクリプトの実行には通常 Bourne shell
(<code>/bin/sh</code>) が使われる:
<blockquote><pre>
$ <strong>sh hello.sh</strong>
Hello!                                                 <em>(echo が実行される)</em>
Sun Nov 13 14:48:02 JST 2022                           <em>(date が実行される)</em>
ImageMagick-7         logrotate.d           screenrc   <em>(ls /etc が実行される)</em>
X11                   lynx.cfg              securetty
alpine-release        lynx.lss              services
…
</pre></blockquote>

<h3 id="script-args">8.1. コマンドに与えられた引数を利用する</h3>

<h3 id="script-chmod">8.2. 通常のコマンドとして使う</h3>


<h2 id="controls">9. 繰り返し・条件分岐</h2>
<p>
シェルでは、コマンドの<u>終了状態</u>に応じた
条件分岐を設定できる。


<h2 id="summary">10. まとめ</h2>
<p>
本日紹介したコマンド・概念は以下のとおり (出てきた順):

<div class=exercise id="ex11">
<div class=header>演習 11. まとめ問題</div>
<ol>
<li> 以下の用語の違いを説明せよ:
<ul>
<li> プログラム
<li> プロセス
<li> コマンド
</ul>
<li> 以下のコマンドがそれぞれ何をするか簡単に説明せよ:
<ul>
<li> <code>ls</code>
<li> <code>cat</code>
<li> <code>less</code>
<li> <code>cd</code>
<li> <code>pwd</code>
<li> <code>ps</code>
<li> <code>kill</code>
<li> <code>grep</code>
<li> <code>sort</code>
<li> <code>echo</code>
<li> <code>env</code>
<li> <code>date</code>
<li> <code>set</code>
<li> <code>export</code>
<li> <code>mkdir</code>
<li> <code>cp</code>
<li> <code>mv</code>
<li> <code>rm</code>
<li> <code>sh</code>
<li> <code>chmod</code>
</ul>
<li> 空のディレクトリで、
以下のコマンド列を実行すると何が表示されるか答えよ:
<blockquote><pre>
$ <strong>echo &gt; hello</strong>
$ <strong>echo &gt; world</strong>
$ <strong>echo *</strong>
</pre></blockquote>
</ol>
</div>


<hr>
<address>Yusuke Shinyama</address>
