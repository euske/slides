<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>「プログラミングの心理学」を読む</title>
<style><!--
body { line-height: 1.5; }
h1 { border-bottom: solid 4px #000088; }
h2 { border-bottom: solid 2px #000088; }
h3 { border-bottom: solid 1px #000088; }
table { border-collapse: collapse; margin: 1em; }
td { padding: 4px; }
kbd { outline: 1px solid black; padding: 2px; }
blockquote { outline: 1px solid black; padding: 4px; }
pre { overflow: auto; margin: 0; }
mark { font-weight: bold; }
pre, code { background: #ddd; font-size: 150%; font-family: courier; }
img { max-width: 80vw; height: auto; }
dt { text-decoration: underline; font-weight: bold; }
u { color: #880000; font-weight: bold; }
.author { text-align: right; }
.figure { outline: 1px solid black; padding: 0.5em; margin: 1em; text-align: center; }
.notice { font-size: 100%; font-weight: bold; background: #ffff88; outline: 2px solid black; padding: 0.5em; margin: 0.5em; }
.formula { background: #88ff88; outline: 2px solid black; padding: 1em; margin: 1em; }
.note { background: #ffff88; outline: 2px solid black; padding: 1em; margin: 1em; }
pre em { color: #008800; }
code em { color: #000088; }
.exercise { outline: 2px solid black; padding: 1em; margin: 1em; }
.exercise > .header { font-size: 120%; font-weight: bold; border-bottom: solid 1px red; border-left: 4px solid red; padding-left: 8px; }
.bl { outline: 1px solid black; padding: 2px; font-size: 120%; color: transparent; }
.uncovered { color: gray; }
--></style>
</head>
<body>
<div class=nav>
<a href="../index.html">&lt; もどる</a>
</div>
<h1>「プログラミングの心理学」を読む</h1>

<div class=author>
Yusuke Shinyama, Mar. 2023
</div>

<p>
<strong>概要:</strong>
「プログラミングの心理学」は、
<a href="https://en.wikipedia.org/wiki/Gerald_Weinberg">ジェラルド M. ワインバーグ (Gerald M. Weinberg)</a> による本である。
オリジナルは 1971年に刊行され、25周年記念版が 1998年に発行された。
<a href="https://www.amazon.co.jp/dp/4839915946">日本語訳</a>もある。
著者のワインバーグは著名なコンサルタント・教師であり、
学術的な研究でも業績をあげている。
1971年当時のプログラマはメインフレームのソフトウェア開発が主な業務で、
おもな使用言語は FORTRAN や COBOL、PL/I などであった。
ちなみに、PC はまだ存在しなかった。
このような時代に書かれたにもかかわらず、
この本が推奨するのは XP 的な手法であり、こんにち
「バランスドチーム」「心理的安全性」と呼ばれているものが
なぜ重要かが実例とともに説明されている。
</p>


<div class=uncovered>
<h2 id="preface">前書き</h2>
<p>
「この本の目的はただひとつ、それはプログラミングを
人間的な活動として研究する試みを始めることである」

<h2 id="programming-as-human-performance">第1部. プログラミングと才能</h2>
<ol start="1">
<li> プログラムを読むという行為
<li> よいプログラムとは何か?
<li> プログラミングをどのように研究するのか?
</ol>
</div>

<h2 id="programming-as-social-activity">第2部. 社会的活動としてのプログラミング</h2>

<h3 id="programming-group">4章. プログラミングをする集団</h3>
<p>
人々が集まってプログラミングをすると、
必然的になんらかの組織が発生する。
</p>

<div class=exercise>
<div class=header>練習問題</div>
<ol>
<li> Zoomなどを使ったリモート作業によって失われたコミュニケーションはあるか?
  あるいは、それによって得られたコミュニケーションはあるか?
<li> あなたは「自分のコード」「誰かのコード」という言い方をしたことがあるか?
<li> 「自分のコード」の間違いを、他人のせい、あるいは
モノのせいにしたことはあるか?
<li> 「自分のコード」の間違いを、運が悪かっただけ、
と思ったことはあるか?<br>
幸運をもたらすための「儀式」をやったことはあるか?
</ol>
</div>

<h4>公式な組織・非公式な組織</h4>
<p>
会社などで定義された「公式な」組織だけではなく、
自然発生的に生まれた「非公式な」組織の場合もある。<br>
非公式な組織の存在を無視したり、それを強制的に解散させようとすると
何らかのツケが回ってくる。<br>
</p>
<ul>
<li> <a href="https://en.wikipedia.org/wiki/Computer_programming_in_the_punched_card_era">かつてコンピュータは専用のセンターに1台だけ存在していた</a>。
<li> 井戸端会議による情報共有「FORTRAN? 何だそりゃ?」
<li> 自販機の回りにたむろす学生の集団
</ul>

<h4>間違いとエゴ</h4>
<p>
多くのプログラマは他人から離れて作業することを好むが、
一方で彼らは自分の成果物に執着しがちである。<br>
コードを「所有する」ことの害悪は、それが自分自身 (エゴ) の
延長であると考えがちなことである。<br>
こうなると、自分のコードの間違いは自分自身の欠陥ととらえることになり、
間違いが見つけにくい (あるいは、間違いを間違いと認めにくい)。
</p>

<h4>「エゴレスプログラミング」</h4>
<p>
プログラマのエゴの問題を直接是正しようとしても難しい。
むしろ有効なのは、プログラマのいる文化および価値観を変えることである。<br>
プログラマの成果が集団に帰属し、個人には帰属しない
というチームでは、コードはつねに全員で改良すべき共有物という
考え方が生まれ、バグの発見が促進される。<br>
このようなチームは仕事に対するメンバーの満足度が高く、
あまり人が離れない。<br>
また、たとえ誰かがいなくなったとしても、
チーム全員が同じ知識を共有しているので、あまり深刻な問題にならない。<br>
</p>

<h4>エゴレス環境を作る・保持するには</h4>
<p>
上のようなチームは存在するが、
残念ならがまだあまり一般的ではない。<br>
伝統的な考え方をもつ組織をこのようなチームにつくり変えることは難しく、
このようなチームをゼロから構築するほうが簡単である。<br>
いったんこのようにしてできあがったチームは、
全体で環境を移動することもありうる。
</p>

<h3 id="programming-team">5章. 開発チーム</h3>
<p>
開発チームは、(個人では達成できない) ある共通した目的を達成するために作られる。
</p>

<div class=exercise>
<div class=header>練習問題</div>
<ol>
<li> あなたがソフトウェア開発にかかわる作業でとくに得意なものはあるか?
  その作業においては、チーム内でもベストな結果を残せているだろうか?
<li> チームの目標を決める際、あなたはどんな役割を果たしているか?
<li> チームには「タスク指向」のメンバーと「メンテナンス指向」のメンバーが
いるだろうか?
<li> メンバーの入れ替わり、あるいはその他の危機がチームに生じたとき、
あなたのチームはどのように対処しただろうか?
またそれによって、チームの雰囲気が前と変わっただろうか?
</ol>
</div>

<h4>プログラムの構造とチームの構造</h4>
<p>
伝統的な (エゴレスでない) 組織では、
プログラムの構造とチームの構造は似かよってくることが多い。
</p>
<blockquote><pre>
def main():
    x = input()
    y = process(x)
    output(y)
</pre></blockquote>
<ul>
<li> main部
<ul>
<li> input部
<li> process部
<li> output部
</ul>
</ul>

<h4>チームの目標設定</h4>
<p>
「見せかけの合意」は危険である:
</p>
<ul>
<li> 入出力ルーチンを自前で実装したプログラマ。
<li> バグを放置してリリースを強要されたプログラマ
(cf. <a href="https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A3%E3%83%AC%E3%83%B3%E3%82%B8%E3%83%A3%E3%83%BC%E5%8F%B7%E7%88%86%E7%99%BA%E4%BA%8B%E6%95%85">チャレンジャー号爆発事故</a>)。
</ul>
<p>
プログラマは「何をするのか」だけでなく「なぜするのか」を知りたがる。<br>
上層部から細かい部分まで指定されると士気が低下する
(自分達はただの「コーダー」)。<br>
目標が明確でないと、メンバーは瑣末な点にこだわるようになる
(<a href="https://ja.wikipedia.org/wiki/%E3%83%91%E3%83%BC%E3%82%AD%E3%83%B3%E3%82%BD%E3%83%B3%E3%81%AE%E5%87%A1%E4%BF%97%E6%B3%95%E5%89%87">パーキンソンの凡俗法則</a>)。
</p>
<ul>
<li> 瑣末な議論は、より根の深い問題「誰がボスなのか」の兆候であることが多い。
</ul>

<h4>管理的なチームと民主的なチーム</h4>
<p>
プログラマの仕事に対する満足度を左右する要素は 4つある:
</p>
<ol>
<li> 物質的・金銭的な見返り。
<li> 仕事のやりがい。
<li> 労働環境。
<li> 上司・監督者の質。
</ol>

<p>
このうち環境によって大きく差があるのは 4. である。
</p>

<ul>
<li> 管理的なチームでは、上から「任命された」人物がリーダーになることが多く、
  プログラマをまとめるのに苦労する。
<li> 民主的なチームでは、状況に応じて異なった人物がチームを導く。
<li> 民主的なチームは、メンバー全員が他のメンバーの仕事を把握しているので、
  メンバーの損失にも対処しやすい。
<li> しかし人嫌いのプログラマは民主的なチームは適応しにくく、
  むしろ管理的なチームを好むかもしれない。
</ul>

<h4>チームの危機</h4>
<p>
チームメンバーの役割は大きく次の 2つに分けられる:
</p>
<ol>
<li> チームの目的を達成する (タスク指向)
<li> チームそのものを持続させる (メンテナンス指向)
</ol>
<p>
どちらも重要な業務である。
古い組織では、「タスク指向」の業務は父親的、
「メンテナンス指向」の業務は「お母さん的」な仕事とされ、
実際に女性がついていることが多かった。
</p>

<h3 id="programming-project">6章. ソフトウェアプロジェクト</h3>
<p>
いくつものチームが集まり大きな組織を構成すると「プロジェクト」になる。
</p>

<div class=exercise>
<div class=header>練習問題</div>
<ol>
<li> あなたは今まで、プロジェクトから「抜けるに抜けられなくなった」経験はあるか?
<li> あなたは「かけがえのないメンバー」か? その状況に対してどう対処したか?
<li> 自分の出した進捗報告や勤怠表が、プロジェクトの最終的な見積りにどう影響したか知っているか?
<li> これまで、上からの圧力に負けて進捗報告を変更したことはあるか?
</ol>
</div>

<h4>変化を通じての安定性</h4>
<p>
ソフトウェアプロジェクトでは、人はつねに入れ替わる。<br>
しかし「プロジェクト」は人の任期を超えて存続する。<br>
他に移りたがっているプログラマを金銭的またはその他の報酬で引き止めようとしても、
たいていは無駄である。<br>
「チームに『かけがえのないプログラマ』がいたら、一刻も早くそいつを追い出せ」
</p>

<h4>進捗見積りの難しさ</h4>
<p>
小さなチームですら進捗の正確な評価は難しいのに、
大きなプロジェクトではなおさら大変になる。<br>
大きなプロジェクトでは「測定」よりも「報告」が優先される。<br>
各階層の管理職は極端な報告を避け、平均に寄せるために
全体として進捗報告はほとんど現実を反映しなくなる。<br>
そして同調圧力がある (<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E5%90%8C%E8%AA%BF%E5%AE%9F%E9%A8%93">アッシュの同調実験</a>)。
</p>
<ul>
<li> 「ちょっと遅れているんです」「どれくらい?」「うーんと、6週間」
</ul>

<h4>プロジェクトの構造</h4>
<p>
いくつかのチームが異なった専門的なタスクを与えられることはよくある。<br>
しかし、チームの役割に「優劣」がつけられていると、各チームがスムーズに協調することは難しい。<br>
(たとえばエンジンのバルブはシリンダーより「偉い」わけではないし、
クランクシャフトもバルブより「偉い」わけではない)<br>
階層的な管理は、各メンバーが交換可能であるような業務でのみうまくいく。
ソフトウェア開発はそうではない。<br>
</p>

<h4>偏見にまつわる問題</h4>
<p>
階層的な組織の問題はほかにもある。<Br>
階層の差が大きいと、上層の管理職は現場のプログラマの仕事をほとんど理解できない。<br>
そのため、仕事の成果そのものではなく、「成果のようなもの」を基準に評価することになる。<br>
プロジェクトは水平に管理するのではなく、垂直に管理したほうが望ましい。<br>
大規模プロジェクトの失敗の原因のほとんどは、管理の失敗である。
</p>


<div class=uncovered>
<h2 id="programming-as-individual-activity">第3部. 個人的活動としてのプログラミング</h2>
<ol start="7">
<li> プログラミングという作業の多様性
<li> 性格による要因
<li> 知能および問題解決能力
<li> 動機、訓練および経験
</ol>

<h2 id="programming-tools">第4部. プログラミングにおける道具</h2>
<ol start="11">
<li> プログラミング言語
<li> 言語設計における原則
<li> その他のツール
</ol>

<h2 id="epilogue">第5部. エピローグ</h2>
<p>
  「たとえ私たちがプログラミングを今より『うまく』できるようになったとして、
  それは本当に価値のあることなのだろうか?
  コンピュータは魅惑的な機械だが、だからこそ私たちはそれが
  本当に自分の幸福につながるのかどうか、つねに考える必要がある」
</p>
</div>


<hr>
<address>Yusuke Shinyama</address>
