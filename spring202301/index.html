<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Spring (Boot) 超入門</title>
<style><!--
body { line-height: 1.5; }
h1 { border-bottom: solid 4px #000088; }
h2 { border-bottom: solid 2px #000088; }
h3 { border-bottom: solid 1px #000088; }
table { border-collapse: collapse; margin-left: auto; margin-right: auto; }
td { padding: 4px; }
kbd { outline: 1px solid black; padding: 2px; }
pre { outline: 1px solid black; padding: 4px; overflow: auto; }
mark { font-weight: bold; }
pre, code { background: #ddd; font-size: 150%; font-family: courier; }
img { max-width: 80vw; height: auto; }
dt { text-decoration: underline; font-weight: bold; }
u { color: #880000; font-weight: bold; }
.author { text-align: right; }
.figure { outline: 1px solid black; padding: 0.5em; margin: 1em; text-align: center; }
.notice { font-size: 100%; font-weight: bold; background: #ffff88; outline: 2px solid black; padding: 0.5em; margin: 0.5em; }
.formula { background: #88ff88; outline: 2px solid black; padding: 1em; margin: 1em; }
.note { background: #ffff88; outline: 2px solid black; padding: 1em; margin: 1em; }
pre em { color: #0000dd; }
code em { color: #000088; }
.exercise { outline: 2px solid black; padding: 1em; margin: 1em; }
.exercise > .header { font-size: 120%; font-weight: bold; border-bottom: solid 1px red; border-left: 4px solid red; padding-left: 8px; }
.file { outline: 2px solid black; padding: 1em; margin: 1em; }
.file > .header { font-weight: bold; color: white; background: #000088; margin-bottom: 4px; padding-left: 1em; }
.file pre { margin: 0; }

.g { background: #eeeeee; }
.bgr, .cert0 { background: #ffbbff; }
.bgg, .cert1 { background: #88ff88; }
.bgy, .cert2 { background: #ffff88; }
.bgb { background: #88ffff; }

.noinj { background: #ff88ff; }
.depinj { background: #88ff88; }
--></style>
</head>
<body>
<div class=nav>
<a href="../index.html">&lt; もどる</a>
</div>

<h1>Spring (Boot) 超入門</h1>

<div class=author>
Yusuke Shinyama, Jan. 2023
</div>

<ol>
</ol>


<h2>1. ソフトウェア開発において重要なこと</h2>

<p>開発者はみな、以下のようなソフトウェアを開発したい:</p>
<ul>
<li>高速で、効率的で</li>
<li>安全で、信頼性があって</li>
<li>保守しやすく、拡張性にも優れている</li>
</ul>

<p>
つまり…
</p>
<div style="display: flex; justify-content: center; align-items: flex-end;">
<div class=figure>
    <img width="243" height="275" src="bad.svg">
    <div class=caption>こんなのは嫌だ</div>
</div>
<div class=figure>
    <img width="266" height="237" src="good.svg">
    <div class=caption>こんなのを作りたい</div>
</div>
</div>

<p>
しかし、これはとてつもなく難しい。
</p>
<ul>
<li> なぜなら、ソフトウェアというものが非常に複雑だから。
<li> この複雑さは、そもそもソフトウェアが扱っている問題（社会）の複雑さに起因するから。
</ul>
<p>
過去数十年、ソフトウェアの先人達はこの複雑なシステムを分解
(<a href="https://ja.wikipedia.org/wiki/%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2">separation of concerns</a>) し、
人間の小さい脳が扱えるようにするために、さまざまな技法をあみだしてきた:
</p>

<ul>
<li> 1970年代: 構造化（モジュール化）</li>
<li> 1980年代: OOP (カプセル化、データ抽象)</li>
<li> 1990年代: AOP (複数箇所をまとめる)</li>
<li> 1980年代: 関数型 (状態の除去)</li>
<li> 1990年代: バージョン管理システム</li>
<li> 2000年代: フレームワーク (IoC, DI, etc.)</li>
<li> 2010年代: コンテナ関連技術</li>
<li> ... </li>
</ul>

<p>
ソフトウェア技術の歴史とは、ほとんど「複雑さを分解する技術の歴史」といってもいい。
</p>

<div class=exercise>
<div class=header>演習. 分解する技術</div>
<p>
自分が思いつく「複雑さを分解する技術」を書き出してみよう。
</p>
</div>


<h2>2. Spring Boot とは</h2>

<p>
Spring Framework (および Spring Boot) は、
その名のとおり「<u>フレームワーク</u>」の一種である。
</p>
<ul>
<li> Java/Kotlin を使ったアプリケーション開発に使われている。
<li> ソフトウェアにおける「フレームワーク」 = 
プログラム (アプリケーション) の設計方法を規定する枠組み。
</ul>

<p>
一般的なフレームワークでは、プログラマはアプリケーション全体の流れを
直接指定せず、フレームワークが制御する。
これを<u>制御の反転</u> (<a href="https://www.martinfowler.com/bliki/InversionOfControl.html">Inversion of Control</a>)
という。別名「ハリウッドの原則 (the Hollywoord Principle)」とも呼ばれる。
</p>

<div class="formula">
<strong>ハリウッドの原則:</strong>
"Don't call us. We call you." (我々を呼ぶな。必要なときは、我々が呼ぶ。)
</div>

<h4>何に使うのか</h4>
<p>
<a href="https://blogs.vmware.com/vmware-japan/2023/03/state-of-spring-2022.html">この調査</a>によれば、
Spring を使う理由で一番多いのは
「データベースを使ったバックエンドが簡単に書けるから」
である。
</p>

<h4>Springの主要な機能</h4>
<p>
Springには多くの機能が搭載されているが、それらの根幹となっているのは以下の2つの機能である:
</p>
<ol type="a">
<li> <u>くれくれ宣言</u> (Autowired) …
    「これこれのオブジェクトが欲しい」と書いておけば、その要件を満たすオブジェクトを自動的にゲットしてくれる。
<li> <u>あるある宣言</u> (Component) …
    「この要件を満たすオブジェクトがここだ」と書いておけば、そのオブジェクトを自動的に他で使ってもらえる。
</ol>

<h4>重要なコンセプト</h4>
<p>
Springを使うにあたって知っておきたい重要なコンセプトは以下のとおりである:
</p>
<dl>
  <dt> Dependency Injection (依存性注入、DI)</dt>
  <dt> Dependency Inversion Principle (依存性逆転の法則、DIP)</dt>
  <dt> Inversion of Control (制御の反転、IoC)</dt>
</dl>

<div class=exercise>
<div class=header>演習. 制御の反転</div>
<p>
自分が知っている「制御の反転」をおこなっているフレームワークを書き出してみよう。
</p>
</div>


<h2>3. 実際に使ってみる</h2>

<h4>準備</h4>
<ol>
<li> <code>java -version</code> でバージョン確認。
<li> <a href="https://start.spring.io/">spring initializr</a> で以下を選択:
<ul>
<li> Project: <strong>Gradle - Kotlin</strong>
<li> Language: <strong>Kotlin</strong>
<li> Spring Boot: (デフォルトのまま)
<li> Project Metadata: (デフォルトのまま)
<li> Dependencies:
<ul>
  <li> <strong>Spring Web</strong>
</ul>
</ul>
<li> <code>demo.zip</code> を展開する。
<li> <code>./gradlew bootrun</code> を実行。
<li> <code>http://localhost:8080/</code> にアクセス。
</ol>

<h4>「あるある宣言」を書いてみる</h4>

<div class=file>
MyComponent.kt:
<pre>
package com.example.demo

import org.springframework.stereotype.Component

<mark>@Component</mark>
class MyComponent {
    init {
        println("this is my component.")
    }
}
</pre>
</div>

<p>
上の例における <code><mark>@Component</mark></code> は「あるある宣言」の一種である。
これを実行すると "<code>this is my component.</code>" と表示される。
これは Spring が <code>MyComponent</code> クラスの「あるある宣言」を検知し、
そのインスタンスを自動的に作成してくれるからである。
</p>

<div class=file>
MyController.kt:
<pre>
package com.example.demo

import org.springframework.stereotype.Controller

<mark>@Controller</mark>
class MyController {

    init {
        println("this is my controller.")
    }
}
</pre>
</div>

<p>
上の例における <code><mark>@Controller</mark></code> も「あるある宣言」の一種である。
これを実行すると "<code>this is my controller.</code>" と表示される。
このように「あるある宣言」には複数の種類が存在する。
</p>

<h4>「くれくれ宣言」を書いてみる</h4>

<div class=file>
MyController.kt:
<pre>
package com.example.demo

import org.springframework.stereotype.Controller
import org.springframework.beans.factory.annotation.Autowired

@Controller
class MyController(<mark>@Autowired val component: MyComponent</mark>) {

    init {
        println("this is my controller: mycomponent=$component")
    }
}
</pre>
</div>

<p>
この例では、<code>MyController</code> インスタンスを作成するにはまず 
<code>MyComponent</code> インスタンスが必要である。
このときコンストラクタの引数に <code><mark>@Autowired </mark></code> と書かれているのが
「くれくれ宣言」である。Spring はこのような宣言を検知すると、
そこで要求されている型のオブジェクト (<code>MyComponent</code> インスタンス) を自動的に探し出し、
必要とあれば作成して、引数として渡してくれる。
</p>

<h2>4. 応用例</h2>
<p>
Spring では以上のような「くれくれ宣言」「あるある宣言」を応用することにより
複雑な機能をもったプログラムを簡単に実装できる。
</p>

<h4>あるある宣言の応用例</h4>

<h4>くれくれ宣言の応用例</h4>

<pre>
dependencies {
        ...
        implementation("org.springframework.boot:spring-boot-starter-jdbc")
}
</pre>


<h2>5. Springのデメリット</h2>

<p>
制御フロー・データフローの一部が「ぶった切られている」。
</p>

<hr>
<address>Yusuke Shinyama</address>
