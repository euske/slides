<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Yusuke Shinyama">
<meta name="keywords" content="UNIX, Linux, ファイル, プロセス, 標準出力, 標準入力, パイプ, シェル, 環境変数, シェルスクリプト">
<meta name="description" content="アプリ開発者の役に立ちそうなUNIX/Linuxに関する知識まとめ。">
<meta name="twitter:card" content="summary" />
<meta property="og:type" content="website" />
<meta property="og:title" content="アプリ開発者のための UNIX/Linux入門" />
<meta property="og:url" content="https://euske.github.io/slides/bc20221024/index.html" />
<meta property="og:description" content="アプリ開発者の役に立ちそうなUNIX/Linuxに関する知識まとめ。" />
<title>アプリ開発者のための UNIX/Linux入門</title>
<style><!--
body { line-height: 1.5; }
h1 { border-bottom: solid 4px #000088; }
h2 { border-bottom: solid 2px #000088; }
h3 { border-bottom: solid 1px #000088; }
table { border-collapse: collapse; margin-left: auto; margin-right: auto; }
td { padding: 4px; }
kbd { outline: 1px solid black; padding: 2px; }
pre { outline: 1px solid black; padding: 4px; overflow: auto; }
mark { font-weight: bold; }
pre, code { background: #ddd; font-size: 150%; font-family: courier; }
img { max-width: 80vw; height: auto; }
dt { text-decoration: underline; font-weight: bold; }
u { color: #880000; font-weight: bold; }
.author { text-align: right; }
.figure { outline: 1px solid black; padding: 0.5em; margin: 1em; display: flex; justify-content: center; align-items: flex-end; text-align: center; gap: 2em; }
.figure .caption { font-size: 80%; font-weight: bold; }
.notice { background: #ffcc00; outline: 2px solid black; padding: 1em; margin: 1em 4em; }
.formula { background: #88ff88; outline: 2px solid black; padding: 1em; margin: 1em; }
.note { background: #ffff88; outline: 2px solid black; padding: 1em; margin: 1em; }
pre em { color: #008800; }
code em { color: #000088; }
.exercise { outline: 2px solid black; padding: 1em; margin: 1em; }
.exercise > .header { font-size: 120%; font-weight: bold; border-bottom: solid 1px red; border-left: 4px solid red; padding-left: 8px; }
.file { outline: 2px solid black; padding: 1em; margin: 1em; }
.file > .header { font-weight: bold; color: white; background: #000088; margin-bottom: 4px; padding-left: 1em; }
.file pre { margin: 0; }
--></style>
</head>
<body>
<div class=nav>
<a href="../index.html">&lt; もどる</a>
</div>

<h1>アプリ開発者のための<br>
UNIX/Linux入門</h1>

<div class=author>
Yusuke Shinyama, Apr. 2024
</div>

<p>
<strong>概要:</strong>
この記事では、アプリ開発者の役に立ちそうな
UNIX/Linux の使い方に関する基本的な知識をまとめた。
</p>

<p>
<strong>目的:</strong>
この記事を理解すると、<a href="#ex15">まとめ問題</a>に答えることができる。
(逆に、現時点でこれができる人には本記事は不要。)
</p>

<h4>目次</h4>
<ol start="0">
<li> <a href="#unix">UNIXとは</a>
<ul>
  <li> <a href="#unix-os">オペレーティングシステム (OS) とは?</a>
  <li> <a href="#linux-distro">Linuxディストリビューションとは?</a>
</ul>
<li> <a href="#filesystem">ファイルシステム</a>
<ul>
  <li> <a href="#fs-path">パス名とは</a>
  <li> <a href="#fs-cd">カレント・ディレクトリ (カレント・フォルダ) とは</a>
  <li> <a href="#fs-abspath">絶対パス名と相対パス名</a>
  <li> <a href="#fs-relpath">相対パス名の表し方</a>
</ul>
<li> <a href="#process">プロセス</a>
<li> <a href="#stdio">標準入力・標準出力・標準エラー出力</a>
<li> <a href="#shell">シェル</a>
<ul>
  <li> <a href="#shell-exp">コマンド引数の展開</a>
  <li> <a href="#filename-exp">ファイル名の展開</a>
  <li> <a href="#command-exp">コマンド出力の展開</a>
</ul>
<li> <a href="#env">環境変数</a>
<ul>
  <li> <a href="#env-use">環境変数を使う</a>
  <li> <a href="#env-set">環境変数を設定する</a>
  <li> <a href="#env-path">重要な環境変数: PATHとHOME</a>
</ul>
<li> <a href="#fileops">ファイル操作コマンド</a>
<ul>
  <li> <a href="#cmd-ls">ls</a>
  <li> <a href="#cmd-cd">cd</a>
  <li> <a href="#cmd-pwd">pwd</a>
  <li> <a href="#cmd-cat">cat・less</a>
  <li> <a href="#cmd-mkdir">mkdir</a>
  <li> <a href="#cmd-cp">cp</a>
  <li> <a href="#cmd-mv">mv</a>
  <li> <a href="#cmd-rm">rm</a>
  <li> <a href="#cmd-du">du</a>
</ul>
<li> <a href="#scripting">シェルスクリプトの基礎</a>
<ul>
  <li> <a href="#script-args">コマンドに与えられた引数を利用する</a>
  <li> <a href="#script-chmod">通常のコマンドとして使う</a>
  <li> <a href="#script-exitcode">終了状態による分岐</a>
  <li> <a href="#script-subst">文字列の置換</a>
</ul>
<li> <a href="#controls">条件分岐・繰り返し</a>
<ul>
  <li> <a href="#control-test">test コマンド</a>
  <li> <a href="#control-if">if … then 〜 fi文</a>
  <li> <a href="#control-while">while … do 〜 done文</a>
  <li> <a href="#control-for">for … do 〜 done文</a>
  <li> <a href="#control-args">$* 引数</a>
</ul>
<li> <a href="#oneliner">ワンライナー (one-liner) を書く時の注意点</a>
<li> <a href="#books">おすすめの書籍</a></li>
</ol>


<h2 id="unix">1. UNIXとは</h2>
<p>
1970年ごろに作られた<u>オペレーティングシステム</u> (OS)。
以後の多くの OS が UNIX を継承あるいは模倣している。
以下ではこれらの「UNIX風OS」も含めて UNIX と呼称する。
</p>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="450" height="300">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="1" fill="none">
    <rect x="180" y="10" width="80" height="40" />
    <rect x="30" y="140" width="80" height="40" />
    <rect x="140" y="140" width="80" height="40" />
    <rect x="250" y="140" width="80" height="40" />
    <rect x="360" y="140" width="80" height="40" />
    <rect x="10" y="60" width="80" height="40" />
    <rect x="140" y="240" width="80" height="40" />
    <g stroke-dasharray="4,4" marker-end="url(#arrow)">
      <path d="M100,80 L190,55" />
      <path d="M80,135 L200,60" />
    </g>
    <path d="M180,140 L220,50" />
    <path d="M290,140 L220,50" />
    <path d="M400,140 L220,50" />
    <path d="M180,240 L180,180" />
  </g>
  <g text-anchor="middle">
    <text x="220" y="40">UNIX v7</text>
    <text x="50" y="90">Windows</text>
    <text x="70" y="170">Linux</text>
    <text x="180" y="170">FreeBSD</text>
    <text x="290" y="155">NetBSD</text>
    <text x="290" y="175">OpenBSD</text>
    <text x="290" y="195">…</text>
    <text x="400" y="155">Solaris</text>
    <text x="400" y="175">HP-UX</text>
    <text x="400" y="195">…</text>
    <text x="180" y="270">macOS</text>
    <text x="120" y="65">模倣</text>
    <text x="130" y="100">模倣</text>
  </g>
</svg>
</div>

<h3 id="unix-os">1.1. オペレーティングシステム (OS) とは?</h3>
<p>
コンピュータの基本的な処理 (ディスク操作、
ネットワーク処理、画面表示など) を提供する<u>基本ソフトウェア</u>。
ほとんどの人は、このオペレーティングシステムを使った
アプリケーション (<u>応用ソフトウェア</u>) を書いている。
実際には、アプリはコンピュータで動いているソフトウェア全体のごく一部である。
</p>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="300" height="200">
  <g fill="white" stroke="black" stroke-width="2">
    <rect x="2" y="2" width="296" height="196" fill="#ddd" />
    <rect x="150" y="50" width="60" height="40"/>
    <rect x="50" y="110" width="60" height="40"/>
    <rect x="190" y="140" width="60" height="40"/>
  </g>
  <g text-anchor="middle">
    <text x="150" y="20" dy="0.5em">オペレーティングシステム (OS)</text>
    <text x="180" y="70" dy="0.5em">アプリ</text>
    <text x="80" y="130" dy="0.5em">アプリ</text>
    <text x="220" y="160" dy="0.5em">アプリ</text>
  </g>
</svg>
</div>

<p>
アプリが入出力装置に直接アクセスすることはほとんどなく、
ほぼすべてオペレーティングシステム (OS) を介している。
また、OS は多くの仮想化処理 (ファイルシステム、遠隔操作、同時並列処理)
を実現している。
</p>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="300" height="200">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  </defs>
  <g fill="white" stroke="black" stroke-width="2">
    <circle cx="150" cy="100" r="80" fill="#ddd" />
    <circle cx="150" cy="100" r="50" />
    <circle cx="150" cy="100" r="30" fill="#fff" />
    <rect x="230" y="10" width="60" height="40"/>
    <rect x="2" y="110" width="60" height="40"/>
    <rect x="220" y="150" width="60" height="40"/>
    <g marker-end="url(#arrow)" stroke-dasharray="4,4">
      <path d="M150,100 m-30,10 l-50,15" />
      <path d="M150,100 m20,-20 l50,-40" />
      <path d="M150,100 m20,20 l45,40" />
    </g>
  </g>
  <g text-anchor="middle">
    <text x="150" y="35" dy="0.5em">OS</text>
    <text x="150" y="100" dy="0.5em">アプリ</text>
    <text x="40" y="160" dy="0.5em">入出力装置</text>
    <text x="260" y="30" dy="0.5em">画面</text>
    <text x="32" y="130" dy="0.5em">カメラ</text>
    <text x="250" y="170" dy="0.5em">音声</text>
  </g>
</svg>
</div>

<h3 id="linux-distro">1.2. Linuxディストリビューションとは?</h3>
<p>
Linuxの世界では、実際には "RedHat", "Ubuntu", "Debian" といった
複数の異なる "Linux" が存在している。<strong>これらは厳密には Linux ではなく、
異なる Linux の <u>ディストリビューション</u> と呼ばれている</strong>。
本来 "Linux" は OSの核となる部分 (カーネル) をさしており「生の Linuxだけを使う」
ということはあり得ない。核となる Linux カーネルにさまざまな部品
 (ファイルシステム、パッケージ管理など) を追加して一般的な OS として
 使えるようにしたものが「ディストリビューション」である。
</p><p>
Linuxの各ディストリビューションのおもな違いはファイルシステムの構造の差異
(/etc以下にある設定ファイルの違いなど) およびシステム管理の方法の差異である。
とくに、パッケージ管理方式は各ディストリビューションによって大きく違っている。
しかしこの記事では UNIXのシステム管理の方法までは扱わないので、
内容の大部分はどのディストリビューションにもあてはまる。
</p>

<h2 id="filesystem">2. ファイルシステム</h2>
<p>
UNIXは<u>階層型ファイルシステム</u> (hierarchical filesystem) という概念を導入している。
これはすべてのファイル・フォルダはひとつの巨大な<u>木構造</u> (tree) をなしている。
また、UNIXでは「すべてはファイルである」という考え方をおしすすめている。
そのため、メモリや画面 (端末) も <code>mem</code> や <code>tty</code> といった
特殊ファイルとして表現されている。
なお、 UNIXではフォルダのことを <u>ディレクトリ</u> (directory) と呼ぶ。
</p>

<h3 id="fs-path">2.1. パス名とは</h3>
<p>
ファイルシステム中のあらゆるファイルの位置は、
<u>パス名</u> (path) で表すことができる:
</p>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g text-anchor="end">
      <text x="300" y="50">ディスク</text>
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
    </g>
    <g style="font-family: monospace;">
      <text x="400" y="50">/</text>
    </g>
  </g>
</svg>
</div>

<div class=exercise id="ex1">
<div class=header>演習 1. パス名の練習</div>
<ol class=spacy>
<li> <mark>ディレクトリ <code>X</code></mark> のパス名を書け。
<li> <mark>ファイル <code>H</code></mark> のパス名を書け。
<li> <mark>ファイル <code>C</code></mark> のパス名を 2つ書け。
</ol>
</div>

<h4>UNIXにおける「お約束」パス名</h4>
<p>
UNIX では、いくつかのパス名は
「お約束」として決められている。
</p>
<ul>
  <li> <code>/bin</code>: 実行可能ファイル (プログラム)</li>
  <li> <code>/home</code>: 各ユーザのホームディレクトリ</li>
  <li> <code>/etc</code>: 設定ファイル</li>
  <li> <code>/dev</code>: デバイスファイル</li>
  <li> …</li>
</ul>

<div class=exercise id="ex2">
<div class=header>演習 2. やってみよう</div>
<ul>
<li> <code>ls <em>パス名</em></code> … <em>パス名</em>に含まれているファイル一覧を表示する。
<blockquote><pre>
$ <strong>ls /etc</strong>
ImageMagick-7         logrotate.d           screenrc
X11                   lynx.cfg              securetty
alpine-release        lynx.lss              services
…
</pre></blockquote>
<li> <code>ls -l <em>パス名</em></code> … より詳細なメタデータとともに表示する。
<blockquote><pre>
$ <strong>ls -l /etc</strong>
total 516
drwxr-xr-x    2 root     root           434 Jul  5  2020 ImageMagick-7
drwxr-xr-x    4 root     root           114 Jul  5  2020 X11
-rw-r--r--    1 root     root             7 May 29  2020 alpine-release
drwxr-xr-x    4 root     root           164 Jan  9  2021 apk
…
</pre></blockquote>
<li> <code>cat <em>パス名</em></code> … ファイルの内容を表示する。
<blockquote><pre>
$ <strong>cat /etc/issue</strong>
Welcome to Alpine Linux 3.12
Kernel \r on an \m (\l)
</pre></blockquote>
UNIX ではどんなファイルも同様に扱われるので、
実は <code>cat</code>コマンドを使えば
あらゆるファイルの内容を (バイト列として) 表示できる。
しかし実際には JPEG などの画像ファイルをバイト列として表示しても
意味不明な文字列が表れるだけである。
<li> <code>less <em>パス名</em></code> … ファイルの内容を少しずつ表示する。
<blockquote><pre>
$ <strong>less /etc/services</strong>
</pre></blockquote>
<p>
lessでは以下のキー操作が使える:
</p>
<ul>
<li> <kbd>Space</kbd> … 次のページへ進む。
<li> <kbd>b</kbd> … 前のページへ戻る。
<li> <kbd>q</kbd> … 終了する。
<li> <kbd>j</kbd> … 1行下へ (↓)。
<li> <kbd>k</kbd> … 1行上へ (↑)。
<li> <kbd>/</kbd> … 文字列検索。
</ul>
</ul>
</div>

<p>
UNIXでは、各ファイルには以下のようなメタデータが付与されている:
</p>
<ul>
<li> ファイル名
<li> 所有者 (ユーザ)
<li> 最終更新日時
<li> サイズ
<li> 読み書き許可フラグ
<li> 実行可能フラグ
<li>
…
</ul>

<h3 id="fs-cd">2.2. カレント・ディレクトリ (カレント・フォルダ) とは</h3>
<ul>
  <li> パス名を使うことの問題: いくらでも長くなりうる!<br>
  例: <code>/Applications/Safari.app/Contents/MacOS/… </code>
  <li> いちいちパス名を入力するのは面倒。簡単にできないか?<br>
    → <strong>いま開いている・注目している</strong> (カレント, current)
    ディレクトリという考えを導入する。
</ul>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g stroke="red" fill="none" stroke-width="4">
      <rect x="120" y="250" width="110" height="100" />
      <line x1="220" y1="350" x2="340" y2="380" />
    </g>
    <g text-anchor="end">
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
      <text x="340" y="400" text-anchor="start" fill="red">カレント・ディレクトリ</text>
    </g>
  </g>
</svg>
</div>

<h3 id="fs-abspath">2.3. 絶対パス名と相対パス名</h3>
<p>
実は「パス名」と呼ばれているものには 2つの種類がある。
上で説明した「パス名」は「<u>絶対パス名</u>」のことであった。
</p>
<ul>
<li> <u>絶対パス名</u>: <mark>ディスクの先頭から</mark>たどったパス名。
<li> <u>相対パス名</u>: <mark>カレント・ディレクトリから</mark>たどったパス名。
</ul>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g stroke="red" fill="none" stroke-width="4">
      <rect x="120" y="250" width="110" height="100" />
      <line x1="220" y1="350" x2="340" y2="380" />
      <rect x="210" y="390" width="110" height="100" stroke="blue" />
    </g>
    <g text-anchor="end">
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
      <text x="340" y="400" text-anchor="start" fill="red">カレント・ディレクトリ</text>
      <text x="340" y="490" text-anchor="start" fill="blue">目的のディレクトリ</text>
    </g>
  </g>
</svg>
</div>

<p>
つまり、上のディレクトリ <code>X</code> の位置は、次の2通りで表せる:
</p>
<ul>
  <li> 絶対パス名: <code>/A/<span style="color:red;">E</span>/<span style="color:blue;">X</span></code>
  <li> 相対パス名: <code><mark>.</mark>/<span style="color:blue;">X</span></code>
</ul>

<h3 id="fs-relpath">2.4. 相対パス名の表し方</h3>
<ul>
<li> 相対パス名では、カレント・ディレクトリの位置を<br>
  「<code>.</code> (ドット)」で表す:
  <code>./X</code>, <code>./K</code> など
<li> さらに、相対パス名では、ひとつ「上の」ディレクトリを<br>
  「<code>..</code>」で表せる。
<li> 相対パス名の能力は、絶対パス名と等価である。
つまり、絶対パスで表せるどんな位置も相対パス名によって表すことができる。<br>
例: <code>../../../../../../../Application</code> =
<code>/Application</code>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g stroke="red" fill="none" stroke-width="4">
      <rect x="120" y="250" width="110" height="100" />
      <line x1="220" y1="350" x2="340" y2="380" />
      <line x1="220" y1="30" x2="300" y2="50" />
      <line x1="50" y1="110" x2="110" y2="140" />
    </g>
    <g text-anchor="end">
      <text x="40" y="100" style="font-family:monospace;">..</text>
      <text x="220" y="20" style="font-family:monospace;">../..</text>
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
      <text x="340" y="400" text-anchor="start" fill="red">カレント・ディレクトリ</text>
    </g>
  </g>
</svg>
</div>
</ul>

<div class=exercise id="ex3">
<div class=header>演習 3. 相対パスの練習</div>
<p>
カレント・ディレクトリが <code>E</code> のとき…
</p>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="500" height="300">
  <defs>
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <symbol id="folder" width="100" height="100">
    <g stroke="black" stroke-width="2" stroke-linejoin="round" fill="#ffee88">
      <polygon points="2,2 65,2 65,80 40,80" />
      <polygon points="2,2 55,10 55,90 2,80" fill="white" />
      <path d="M10,15 L45,25 M10,25 L45,35 M10,35 L45,45 M10,45 L45,55 M10,55 L45,65 M10,65 L45,75" />
      <polygon points="2,2 40,20 40,100 2,80" />
    </g>
  </symbol>
  <symbol id="file" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="20,10 60,10 80,30 80,90 20,90" fill="white" />
      <path d="M30,25 L70,25 M30,35 L70,35 M30,45 L70,45 M30,55 L70,55 M30,65 L70,65 M30,75 L70,75" />
      <polygon points="60,10 60,30 80,30" fill="white" />
    </g>
  </symbol>
  <symbol id="disk" width="100" height="100">
    <g fill="none" stroke="black" stroke-width="2" stroke-linejoin="round">
      <polygon points="10,40 30,30 90,30 90,50 70,60 10,60" fill="white" />
      <path d="M15,42 L68,42 L68,56 M68,42 L86,33 M20,48 L30,48" />
    </g>
  </symbol>
  </defs>
  <g transform="translate(10.5,0.5) scale(0.6,0.6)">
    <use x="300" y="0" xlink:href="#disk" />
    <use x="150" y="120" xlink:href="#folder" />
    <use x="300" y="120" xlink:href="#folder" />
    <use x="410" y="120" xlink:href="#file" />
    <use x="250" y="250" xlink:href="#file" />
    <use x="340" y="250" xlink:href="#file" />
    <use x="40" y="260" xlink:href="#folder" />
    <use x="160" y="260" xlink:href="#folder" />
    <use x="210" y="390" xlink:href="#folder" />
    <use x="100" y="380" xlink:href="#file" />
    <use x="0" y="390" xlink:href="#file" />
    <g stroke="black" fill="none" stroke-width="2">
      <line x1="330" y1="70" x2="200" y2="116" />
      <line x1="340" y1="70" x2="330" y2="116" />
      <line x1="350" y1="70" x2="430" y2="116" />
      <line x1="330" y1="220" x2="300" y2="250" />
      <line x1="350" y1="220" x2="380" y2="250" />
      <line x1="170" y1="220" x2="100" y2="256" />
      <line x1="180" y1="220" x2="200" y2="256" />
      <line x1="190" y1="360" x2="160" y2="380" />
      <line x1="210" y1="360" x2="240" y2="386" />
      <line x1="65" y1="360" x2="50" y2="390" />
    </g>
    <g stroke="red" fill="none" stroke-width="4">
      <rect x="120" y="250" width="110" height="100" />
      <line x1="220" y1="350" x2="340" y2="380" />
    </g>
    <g text-anchor="end">
      <text x="145" y="160">A</text>
      <text x="295" y="160">B</text>
      <text x="500" y="160" text-anchor="start">C</text>
      <text x="30" y="300">B</text>
      <text x="150" y="300">E</text>
      <text x="260" y="300">C</text>
      <text x="440" y="300">K</text>
      <text x="10" y="440">H</text>
      <text x="110" y="440">K</text>
      <text x="290" y="440" text-anchor="start">X</text>
      <text x="340" y="400" text-anchor="start" fill="red">カレント・ディレクトリ</text>
    </g>
  </g>
</svg>
</div>
<ol type=a>
  <li> ディレクトリ <code>A</code> への相対パス名は?
  <li> ファイル <code>H</code> への相対パス名は?
  <li> ファイル <code>K</code> への相対パス名は? (2つある)
</ol>
</div>

<div class=exercise id="ex4">
<div class=header>演習 4. やってみよう</div>
<ul>
<li> <code>cd パス名</code> … カレント・ディレクトリを指定されたパス名に変更する。
<li> <code>pwd</code> … カレント・ディレクトリを表示する。
<blockquote><pre>
$ <strong>pwd</strong>
/home/euske
$ <strong>cd /etc</strong>
$ <strong>pwd</strong>
/etc
</pre></blockquote>
<li> <code>ls</code> (パス名を省略) … カレント・ディレクトリに含まれているファイル一覧を表示する。
<li> <code>ls -l</code> (パス名を省略) … より詳細なメタデータとともに表示する。
</ul>
</div>


<h2 id="process">3. プロセス</h2>
<p>
ファイルシステム上で「<u>実行可能</u> (executable)」フラグ (<code>x</code>) がついている
ファイルはプログラムとして実行可能である。実行されたプログラムは、システム上で一定時間
<u>プロセス</u> (process) として走り続ける。UNIXはマルチタスクOSなので、通常は
複数のプロセスが並列に実行される。とはいえ実際の CPU は一度にひとつの
プログラムしか実行できないため、各プロセスは高速に切り替えられ
少しずつ (10ms程度) 実行される (時分割処理)。
これらプロセス切り替え処理は、OS の
<u>カーネル</u> (kernel) という部分がおこなう。
</p>

<h4>UNIXプロセスの特徴</h4>

<ul>
<li> あるプロセスから、さらに別のプロセス (<u>子プロセス</u>) を起動することができる。
このとき、もとのプロセスは <u>親プロセス</u> と呼ばれる。
<li> プログラミングにおける関数と同じように、各プロセスは
親プロセスから <u>引数</u> (argument) を受けとることができる。
また、プロセスは終了時に <u>終了状態</u> (exit code) を親プロセスに返す。
<li> プロセスも、ファイルと同じように「所有者」が存在する。
あるプロセスの権限は、それを起動したユーザの権限と同じになる。
<li> 各プロセスには以下のものが付属している:
<ul>
<li> プロセスID (固有の識別番号、<u>PID</u>)
<li> ユーザID (プロセスの所有者)
<li> カレント・ディレクトリ
<li> 標準入力・標準出力・標準エラー出力 (後述)
<li> 環境変数
<li> Control Group
</ul>
</ul>

<p>
UNIX 起動時には、まず最初のプロセスである <code>init</code>
(プロセスID: 1) が実行される。ここから他のすべてのプロセスが起動される。
UNIX の各プロセスは、<code>init</code> から先祖-子孫関係が存在し、
全体として木構造を形成している。
</p>
<blockquote><pre>
$ <strong>pstree</strong>
systemd─┬─agetty
        ├─automount───3&ast;[{automount}]
        ├─avahi-daemon───avahi-daemon
        ├─crond
        ├─dbus-daemon
        ├─nmbd
        ├─ntpd───{ntpd}
        ├─smbd─┬─cleanupd
        │      ├─smbd
        │      └─smbd-notifyd
        ├─sshd
       ...
</pre></blockquote>

<div class=exercise id="ex5">
<div class=header>演習 5. やってみよう</div>
<ul>
<li> <code>ps x</code> … 自分が所有するプロセス一覧を表示する。
<blockquote><pre>
$ <strong>ps x</strong>
  PID TTY      STAT   TIME COMMAND
19857 ?        Ss     0:00 /lib/systemd/systemd --user
19858 ?        S      0:00 (sd-pam)
19872 ?        R      0:00 sshd: euske@pts/0
19874 pts/0    Ss     0:00 -bash
19880 pts/0    R+     0:00 ps x
</pre></blockquote>
<li> <code>ps ax</code> … すべてのプロセス一覧を表示する。
<blockquote><pre>
$ <strong>ps ax</strong>
  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     0:43 /sbin/init
    2 ?        S      0:00 [kthreadd]
    3 ?        I&lt;     0:00 [rcu_gp]
    4 ?        I&lt;     0:00 [rcu_par_gp]
…
</pre></blockquote>
<li> <code>ps aux</code> … より詳細な情報 (所有者) を表示する。
<li> <code>ps alx</code> … より詳細な情報 (親プロセスID) を表示する。
<li> <code>pstree</code> … プロセスの木構造を視覚的に表示する。
(注: pstreeコマンドは標準の macOS には存在しないので、
brewを使ってインストールする)
</ul>
</div>

<h4>実行中のプロセスを止めるには</h4>
<p>
UNIX のプロセスには、<u>シグナル</u> (signal) を送ることができる。
シグナルにはいくつかの種類がある:
</p>
<ul>
<li> <code>SIGTERM</code> … プロセスを正常終了させる。
<li> <code>SIGKILL</code> … プロセスを強制終了させる。(SIGTERMよりも強力で、最後の手段)
<li> <code>SIGINT</code> … プロセスの所属する端末 (標準入力) で <kbd>Control</kbd>+<kbd>C</kbd> が押されたときに送られる。たいていのプロセスは終了するが、プロセスはこれを無視することもできる。
<li> <code>SIGSEGV</code> … プロセスが異常な動作をしたときに、カーネルによって送られる。
ほとんどのプロセスは終了する。
</ul>

<div class=exercise id="ex6">
<div class=header>演習 6. やってみよう</div>
<ul>
<li> <code>kill <em>プロセスID</em></code> … 指定したプロセスに <code>SIGTERM</code> を送る。
<blockquote><pre>
$ <strong>sleep 60</strong>
または
$ <strong>find / </strong>
…

(別のウィンドウで)
$ <strong>ps x</strong>
$ <strong>kill 12345</strong>
</pre></blockquote>
<li> <code>kill -KILL <em>プロセスID</em></code> … 指定したプロセスに <code>SIGKILL</code> を送る。
</ul>
</div>


<h2 id="stdio">4. 標準入力・標準出力・標準エラー出力</h2>

<p>
UNIX の各プロセスには
「<u>標準入力</u> (stdin)」
「<u>標準出力</u> (stdout)」
「<u>標準エラー出力</u> (stderr)」
という 3つの仮想的な装置が付属している。
これらはプロセスが画面に文字を表示したり、
キーボードから文字を入力するために使用する。
</p><p>
まず、通常の状態では、プロセスの
標準入力・標準出力・標準エラー出力は、
どれも「<u>端末</u> (画面)」に接続されている。
(昔はこれはタイプライタや電話線だったが、現在ではおもに
ウィンドウ上の<u>仮想端末</u>が使われる。)
</p>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="310" height="140">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="110" />
    <rect x="200" y="20" width="100" height="30" />
    <rect x="200" y="60" width="100" height="30" />
    <rect x="200" y="100" width="100" height="30" />
    <path d="M200,35 l-80,0" marker-end="url(#arrow)" />
    <path d="M110,75 l80,0" marker-end="url(#arrow)" />
    <path d="M110,115 l80,0" marker-end="url(#arrow)" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">プロセス</text>
    <text text-anchor="end" x="105" y="40">標準入力</text>
    <text text-anchor="end" x="105" y="80">標準出力</text>
    <text text-anchor="end" x="105" y="120">標準エラー出力</text>
    <text x="250" y="40">端末</text>
    <text x="250" y="80">端末</text>
    <text x="250" y="120">端末</text>
  </g>
</svg>
</div>

<p>
標準出力は、プロセスからの出力を表示するのに使われる:
</p>
<blockquote><pre>
$ <strong>./hello</strong>
hello, world.
</pre></blockquote>

<p>
いっぽう標準入力は、ユーザが文字を入力するのに使われる:
</p>
<blockquote><pre>
$ <strong>./greet</strong>
your name?
<strong>euske</strong>
greetings, euske
</pre></blockquote>

<p>
さて UNIX では、後述するシェルの機能を使うと、
標準出力を端末ではなくファイルに切り替える (<u>リダイレクト</u>する)
ことができる:
</p>
<blockquote><pre>
$ <strong>./hello &gt; output.txt</strong>
(テキストファイル output.txt が生成される)
</pre></blockquote>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="310" height="140">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="110" />
    <rect x="200" y="20" width="100" height="30" />
    <rect x="200" y="60" width="100" height="30" fill="#ffcccc" />
    <rect x="200" y="100" width="100" height="30" />
    <path d="M200,35 l-80,0" marker-end="url(#arrow)" />
    <path d="M110,75 l80,0" marker-end="url(#arrow)" />
    <path d="M110,115 l80,0" marker-end="url(#arrow)" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">hello</text>
    <text text-anchor="end" x="105" y="40">標準入力</text>
    <text text-anchor="end" x="105" y="80">標準出力</text>
    <text text-anchor="end" x="105" y="120">標準エラー出力</text>
    <text x="250" y="40">端末</text>
    <text style="font-family:monospace;" x="250" y="80">output.txt</text>
    <text x="250" y="120">端末</text>
  </g>
</svg>
</div>

<p>
また、標準<strong>入力</strong>を端末ではなくファイルにリダイレクトすることも
可能である:
</p>
<blockquote><pre>
(テキストファイル input.txt を作成する)
$ <strong>./greet &lt; input.txt</strong>
your name?
greetings, test
</pre></blockquote>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="310" height="140">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="110" />
    <rect x="200" y="20" width="100" height="30" fill="#88ff88" />
    <rect x="200" y="60" width="100" height="30" />
    <rect x="200" y="100" width="100" height="30" />
    <path d="M200,35 l-80,0" marker-end="url(#arrow)" />
    <path d="M110,75 l80,0" marker-end="url(#arrow)" />
    <path d="M110,115 l80,0" marker-end="url(#arrow)" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">greet</text>
    <text text-anchor="end" x="105" y="40">標準入力</text>
    <text text-anchor="end" x="105" y="80">標準出力</text>
    <text text-anchor="end" x="105" y="120">標準エラー出力</text>
    <text style="font-family:monospace;" x="250" y="40">input.txt</text>
    <text x="250" y="80">端末</text>
    <text x="250" y="120">端末</text>
  </g>
</svg>
</div>

<p>
さらに、UNIX には「<u>パイプ</u> (pipe)」という機能がある。
これを使うと
「あるプロセスの標準<strong>出力</strong>を、別のプロセスの標準<strong>入力</strong>に」
リダイレクトすることができる:
</p>
<blockquote><pre>
$ <strong>./hello | ./greet</strong>
your name?
greetings, hello, world.
</pre></blockquote>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="650" height="180">
  <defs>
    <marker id="arrow" viewBox="-5 -5 10 10" markerWidth="8" markerHeight="8" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
  </defs>
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="110" />
    <rect x="180" y="20" width="100" height="30" />
    <ellipse cx="230" cy="75" rx="50" ry="15" fill="#ffff88" />
    <rect x="180" y="100" width="100" height="30" />
    <path d="M180,35 l-60,0" marker-end="url(#arrow)" />
    <path d="M110,75 l60,0" marker-end="url(#arrow)" />
    <path d="M110,115 l60,0" marker-end="url(#arrow)" />
    <rect x="350" y="60" width="100" height="110" />
    <rect x="520" y="100" width="100" height="30" />
    <rect x="520" y="140" width="100" height="30" />
    <path d="M280,75 l60,0" marker-end="url(#arrow)" />
    <path d="M450,115 l60,0" marker-end="url(#arrow)" />
    <path d="M450,155 l60,0" marker-end="url(#arrow)" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">hello</text>
    <text text-anchor="end" x="105" y="40">標準入力</text>
    <text text-anchor="end" x="105" y="80">標準出力</text>
    <text text-anchor="end" x="105" y="120">標準エラー出力</text>
    <text x="230" y="40">端末</text>
    <text x="230" y="80">パイプ</text>
    <text x="230" y="120">端末</text>
    <text x="400" y="55">greet</text>
    <text text-anchor="start" x="355" y="80">標準入力</text>
    <text text-anchor="end" x="445" y="120">標準出力</text>
    <text text-anchor="end" x="445" y="160">標準エラー出力</text>
    <text x="570" y="120">端末</text>
    <text x="570" y="160">端末</text>
  </g>
</svg>
</div>

<div class=exercise id="ex7">
<div class=header>演習 7. やってみよう</div>
<ul>
<li> 以下のコマンドを実行し、ls の出力がテキストファイルになっていることを確認せよ。
<blockquote><pre>
$ <strong>ls -l > output.txt</strong>
</pre></blockquote>
<li> <code>grep</code>コマンドを使うと、
標準入力から特定のパターンが含まれる行だけを表示できる:
<blockquote><pre>
$ <strong>ls -l | grep .conf</strong>
-rw-r--r--    1 root     root          5613 Jun 18  2020 ca-certificates.conf
drwxr-xr-x    2 root     root           520 Jul  5  2020 conf.d
-rw-r--r--    1 root     root          1102 Jul  6  2020 dhcpcd.conf
…
</pre></blockquote>
<li> <code>sort</code>コマンドを使うと、
標準入力の各行を昇順あるいは降順に並べ替え (ソート) できる:
<blockquote><pre>
$ <strong>ls -l | sort</strong> (各列の行頭からアルファベット順にソート)
…
$ <strong>ls -l | sort +2</strong> (空白で区切られた 2番目の列を基準にソート)
…
$ <strong>ls -l | sort -n +4</strong> (数値としてソート)
…
$ <strong>ls -l | sort -n -r +4</strong> (reverse, 逆順に表示)
…
</pre></blockquote>
<p>
このように、UNIX のコマンドは "<code>-</code>" や "<code>+</code>" で始まる
文字列を与えることにより異なった動きをするものが多い。
(これは何か規則があるわけではなく、ただの慣例である。)
このような文字列を一般にコマンドの「<u>オプション</u> (option)」と呼ぶ。
</p>
</ul>
</div>

<p>
パイプによる複数プロセスの接続は UNIX (シェル) の特徴的な機能のひとつである。
これをうまく使うと、複雑な処理をいくつかのコマンドの組み合わせによって
実現することができる。
</p>
<blockquote><pre>
(ls コマンドの出力を検索し、さらにそれをソートして最初の10行を表示する)
$ <strong>ls -l | grep euske | sort | head -n10</strong>
</pre></blockquote>

<div class=note>
<strong>注意:</strong>
<code>&lt;</code> や <code>&gt;</code> による
標準入力・標準出力の切り替えは、
プロセスを<strong>起動する瞬間</strong>にしか指定できない。
いちどプロセスが起動してしまうと、あとから
切り替えることはできないので注意。
</div>

<div class=note>
<strong>注意:</strong>
UNIX は無愛想な OS なので、
<code>&gt;</code> の出力先として
うっかり存在するファイル名を指定してしまうと、
そのファイルは<strong>何の警告もなく</strong>上書きされ、
空のファイルされる。
</div>


<h2 id="shell">5. シェル</h2>
<p>
以上に挙げたような各プロセスの起動、標準入力・標準出力の切り替えなどを
おこなうプログラムが<u>シェル</u> (shell) である。
シェルは UNIX を使ううえで中心的な役割を果たしている。
UNIX 上で「<u>コマンド</u> (command)」と呼ばれるものは、
実はほとんどシェルによって起動されるプロセスである。
しかもたいていのコマンド (プロセス) は数ミリ秒〜数秒しか生存しない。
通常の PC では、アプリ (これもプロセス) は一度起動したら
長時間走らせておくのが普通だが、
UNIX は「湯水のようにプロセスを消費する」OSである。
</p><p>
シェルの役割には、以下のものがある:
</p>
<ul>
<li> プロセスの起動
<li> プロセスの終了 (シグナルの送信)
<li> プロセス起動時の標準入力・標準出力・標準エラー出力の切り替え
<li> プロセス起動時の環境変数 (後述) の設定
<li> カレント・ディレクトリの切り替え
</ul>

<p>
実は UNIX では、シェルも普通のプロセスである。
そのため (<code>sh</code>, <code>csh</code>, <code>bash</code>, <code>zsh</code> など)
いろいろなシェルが開発されている。
ほとんどの場合、シェルは以下の動作を繰り返しているだけである:
</p>
<ol>
<li> 端末 (標準入力) からコマンド文字列が入力されるのを待つ。
<li> 文字列を解析し、スペースで区切られた引数のリストを作成する (<u>引数展開</u>)。
<li> 必要に応じて標準入力・標準出力・標準エラー出力を切り替えて、子プロセスを起動する。
<li> 子プロセスが終了するのを待ち、終了状態を受けとる。
<li> 1. に戻る。
</ol>

<h3 id="shell-exp">5.1. コマンド引数の展開</h3>
<p>
先に述べたように、UNIX コマンドのほとんどは実はプロセスであり (例外も存在する)、
シェルの主な機能はコマンド文字列を解析し、プロセスを起動することである。
たとえば
</p>
<blockquote><pre>
$ <strong>ls -l /etc</strong>
</pre></blockquote>
という行は、以下の行と同じである:
<blockquote><pre>
$ <strong>/bin/ls -l /etc</strong>
</pre></blockquote>
<p>
この行が入力されたとき、シェルは以下のことをおこなう:
</p>
<ol>
<li> <code>/bin/ls</code> というプログラムを子プロセスとして起動する。
<li> このとき、各引数を文字列としてプロセスに渡す:
<ul>
<li> <code>ls</code> … 0番目の引数 (コマンド名あるいはプログラムのパス名)
<li> <code>-l</code> … 1番目の引数
<li> <code>/etc</code> … 2番目の引数
</ul>
<li> 子プロセスが終了するまで待つ。
</ol>
<p>
ここで注意したいのは、引数である
「<code>-l</code>」や「<code>/etc</code>」をどのように利用するかは
<strong>各コマンド次第</strong>ということである。
すべてのコマンドにおいて
「<code>-l</code>」がオプションであると決まっているわけではないし
「<code>/etc</code>」がパス名として解釈されるとも限らない。
この意味で、UNIX の使い方を学ぶことは
API の使い方を学ぶのに似ている。
個々の関数・メソッドの引数がどのような意味をもつのか学習し、
それらを組み合わせて必要な処理を実現する。
</p>

<div class=note>
<strong>注意:</strong>
もし実際に
「<code>-l</code>」という名前のディレクトリがあったとすると、
そのままでは <code>ls</code> のパス名として指定できない。
だが <code>ls ./-l</code> というトリックを使えば指定できる。)
</div>

<p>
たとえば <code>echo</code> というコマンドは、シェルから与えらえた引数をただそのまま
表示するだけのコマンドである:
</p>
<blockquote><pre>
$ <strong>echo abc 1234</strong>
abc 1234
$ <strong>echo -l /etc</strong>
-l /etc
</pre></blockquote>

<p>
一般にシェルの引数は「<code> </code> 」(スペース) で
区切られるが、<code>"〜"</code> で囲むことにより
スペースが入っている文字列を「ひとつの引数」として認識させることができる:
</p>
<blockquote><pre>
$ <strong>ls -l /etc</strong>
…
$ <strong>ls "-l /etc"</strong>
ls: invalid option -- ' '
$ <strong>"ls -l" /etc</strong>
ls -l: command not found
</pre></blockquote>

<div class=exercise id="ex8">
<div class=header>演習 8. シェルの引数展開</div>
<p>
以下のコマンドラインの引数を 0番目からすべて挙げよ:
</p>
<ol class=spacy>
<li> <code>ls /etc /bin</code>
<li> <code>ls "/etc /bin"</code>
<li> <code>ls "/etc" "/bin"</code>
<li> <code>ls "" "/bin"</code>
<li> <code>"ls /etc /bin"</code>
</ol>
</div>

<h3 id="filename-exp">5.2. ファイル名の展開</h3>
<p>
シェルでは、ディレクトリ上に複数のファイルがあるとき、
それらのファイル名を複数の引数として展開する機能がある
(<u>ファイル名展開</u>, filename expansion)。
</p><p>
たとえば、カレント・ディレクトリ内に
<code>a</code>, <code>bb</code>, <code>ccc</code>
というファイルがあるとき…
<blockquote><pre>
$ <strong>ls</strong>
a   bb   ccc
</pre></blockquote>
以下の <code>&ast;</code> (<u>ワイルドカード</u>) を指定すると
<blockquote><pre>
$ <strong>cat &ast;</strong>
</pre></blockquote>
以下の引数を与えたのと同じである:
<blockquote><pre>
$ <strong>cat a bb ccc</strong>
</pre></blockquote>
</p><p>
ワイルドカードには、パターンを指定することもできる。
たとえば <code>/etc</code> 内に多くの「<code>.conf</code>」で終わるファイルがあるとき…
<blockquote><pre>
$ <strong>ls -l | grep .conf</strong>
-rw-r--r--    1 root     root          5613 Jun 18  2020 ca-certificates.conf
drwxr-xr-x    2 root     root           520 Jul  5  2020 conf.d
-rw-r--r--    1 root     root          1102 Jul  6  2020 dhcpcd.conf
…
</pre></blockquote>
以下のパターンは
<blockquote><pre>
$ <strong>cat /etc/&ast;.conf</strong>
</pre></blockquote>
以下のような引数に展開される:
<blockquote><pre>
$ <strong>cat /etc/ca-certificates<mark>.conf</mark> /etc/dhcpcd<mark>.conf</mark> …</strong>
</pre></blockquote>
</p><p>
繰り返すが、ここで展開されたパス名をどのように扱うかは
<strong>各コマンド次第</strong>である。
シェルがファイル名展開したからといって、
各コマンドがこれらをファイル名として扱う保証はない。
</p><p>
ここで、<code>echo</code> コマンドは
シェルが各引数をどのように展開したかを表示するのに使える:
</p>
<blockquote><pre>
$ <strong>echo /etc/&ast;.conf</strong>
/etc/ca-certificates.conf /etc/dhcpcd.conf …
</pre></blockquote>

<div class=exercise id="ex9">
<div class=header>演習 9. ファイル名展開</div>
<p>
<code>/etc</code> 以下に次のようなファイルがあるとする:
</p>
<ul>
<li> <code>a.conf</code>
<li> <code>b.conf</code>
<li> <code>issue</code>
</ul>
カレント・ディレクトリも <code>/etc</code> であるとして、
以下のコマンドラインの出力を答えよ:
<ol class=spacy>
<li> <code>echo &ast;</code>
<li> <code>echo &ast;.conf</code>
<li> <code>echo &ast;.conf /etc/&ast;</code>
<li> <code>echo /etc/issue&ast;</code>
<li> <code>echo "&ast;"</code>
</ol>
</div>

<h4>Dockerの原理</h4>
<p>
各プロセスに所属する Control Group (cgroup) という機能を使うと、
あるプロセス (およびその子孫プロセスすべて) からアクセスできる
ファイルやネットワークを制限することができる。
</p><p>
つまるところ、docker がやっているのは、ある Control Group 内で
プロセスを起動し、それ以降のすべての子プロセスを
特定の空間に閉じ込める (containする) ことによって
各プロセスが独立したマシン上で動いているかのように
見せかけているだけなのである。
</p>

<h3 id="command-exp">5.3. コマンド出力の展開</h3>
<p>
さらにシェルは、あるコマンドが (標準出力に) 出力した文字列を
まるごと引数として展開することができる。
</p><p>
たとえば、<code>ls</code> コマンドが以下のような出力をしたとする:
<blockquote><pre>
$ <strong>ls</strong>
a   bb   ccc
</pre></blockquote>
</p><p>
このコマンドの出力は <code>a</code>, <code>bb</code>, <code>ccc</code> という
3つの引数に展開される:
</p>
<blockquote><pre>
$ <strong>echo $(<mark>ls</mark>)</strong>
a bb ccc
</pre></blockquote>
<p>
ここでコマンドの出力からは、余分な空白が除かれていることに注意。
これは通常のコマンドライン引数で
</p>
<blockquote><pre>
$ <strong>echo <mark>a   bb   ccc</mark></strong>
a bb ccc
</pre></blockquote>
とタイプしたのと同じことである。
標準出力全体をひとつの文字列として扱うには、
コマンド出力の展開部分を <code>"〜"</code> で囲めばよい:
<blockquote><pre>
$ <strong>echo "$(<mark>ls</mark>)"</strong>
a
bb
ccc
</pre></blockquote>


<h2 id="env">6. 環境変数</h2>
<p>
UNIX では、各プロセスに<u>環境変数</u> (environment variable) というものが
付属している。これは各種の設定を保持しておくための文字列型の変数で、
プログラムの変数と同様に、好きな数だけ作成することができる。
</p><p>
現在の環境変数一覧を見るためには <code>env</code>コマンドを使う:
<blockquote><pre>
$ <strong>env</strong>
SHLVL=3
HOME=/root
OLDPWD=/root
PAGER=less
…
</pre></blockquote>
</p><p>
順序がばらばらで見にくいので <code>sort</code>で並べ変えてみる:
</p>
<blockquote><pre>
$ <strong>env | sort</strong>
HOME=/root
OLDPWD=/root
PAGER=less
…
</pre></blockquote>

<div class=note>
<strong>注意:</strong>
Windowsの環境変数と違い (実際にはWindowsもそうなのだが)、
<strong>UNIXにおける環境変数は各プロセスごとに独立している</strong>。
あるプロセスの環境変数を別のプロセスの環境変数にすることはできない。
ただし、<strong>親プロセスの環境変数は、子プロセスに引きつがれる</strong>ため、
最初に共通の環境変数を設定しておけば、以後すべての子プロセスで
共通の設定を利用することができる。

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="310" height="180">
  <g stroke="black" stroke-width="2" fill="none">
    <rect x="10" y="20" width="100" height="60" />
    <rect x="170" y="20" width="100" height="60" />
    <rect x="170" y="110" width="100" height="60" />
    <path d="M110,50 l60,0 M110,50 m30,0 l0,90 l30,0" />
    <path d="M270,50 l20,0" />
    <path d="M290,50 l20,0" stroke-dasharray="4,4" />
    <path d="M270,140 l20,0" />
    <path d="M290,140 l20,0" stroke-dasharray="4,4" />
  </g>
  <g style="font-size:75%;" text-anchor="middle">
    <text x="60" y="15">親プロセス</text>
    <text x="220" y="15">子プロセス</text>
    <text x="220" y="105">子プロセス</text>
  </g>
  <g style="font-size:75%; font-family: monospace">
    <text x="20" y="40">USER=yusuke</text>
    <text x="180" y="40">USER=yusuke</text>
    <text x="180" y="60">DATABASE=alpha</text>
    <text x="180" y="130">USER=yusuke</text>
    <text x="180" y="150">DATABASE=beta</text>
  </g>
</svg>
</div>
</div>

<h3 id="env-use">6.1. 環境変数を使う</h3>
<p>
各プロセスにおける環境変数は、
プログラム中のどこからでも文字列値として
アクセス可能である。
たとえば、環境変数 <code>USER</code> の値を取得したいとき:
</p>

<h4>Node (JavaScript) の場合</h4>
<blockquote><pre>
const user = process.env['<mark>USER</mark>']
</pre></blockquote>

<h4>Java の場合</h4>
<blockquote><pre>
String user = System.getenv("<mark>USER</mark>");
</pre></blockquote>

<h4>Kotlin の場合</h4>
<blockquote><pre>
val user: String? = System.getenv("<mark>USER</mark>")
</pre></blockquote>

<p>
慣例により、環境変数の名前には大文字が使われることが多い
(実際には、英数字であればなんでもよい)。
</p>

<h4>シェルの場合</h4>
<p>
シェルでは、コマンドライン引数に含まれる環境変数の値が展開される。
たとえば環境変数 <code>USER</code> に <code>euske</code> という値が入っている場合、
</p>
<blockquote><pre>
$ <strong>ls /home/<mark>${USER}</mark>/foo</strong>
</pre></blockquote>
は、以下のように展開される:
<blockquote><pre>
$ <strong>ls /home/euske/foo</strong>
</pre></blockquote>
<p>
<code>echo</code>コマンドは、環境変数の内容を確認するためによく使われる:
</p>
<blockquote><pre>
$ <strong>echo ${USER}</strong>
euske
</pre></blockquote>
<p>
未定義の環境変数を展開してもエラーにはならず、空文字列として扱われる:
</p>
<blockquote><pre>
$ <strong>echo /home/${USSR}/foo</strong>
/home//foo
</pre></blockquote>
<p>
なお、<code>${〜}</code>の中カッコは省略可能である:
</p>
<blockquote><pre>
$ <strong>echo $USER</strong>
euske
</pre></blockquote>

<h4>高度な機能</h4>
<p>
シェルには変数を展開するさいにさまざまな演算をおこなう機能がある。
たとえば
</p>
<blockquote><pre>
$ <strong>echo ${USER/xxx/yyy}</strong>  <em>(USER中の xxx を yyyに置換した文字列に展開される)</em>
$ <strong>echo ${LANG:-ja}</strong>      <em>(LANGが定義されていない場合、デフォルト値としてjaに展開される)</em>
</pre></blockquote>

<div class=exercise id="ex10">
<div class=header>演習 10. 環境変数の展開</div>
<p>
環境変数 <code>USER</code> に <code>jon</code> という文字列が、
環境変数 <code>FILE</code> に <code>athan</code> という文字列が、
入っているとき、以下のコマンドの出力を答えよ:
</p>
<ol>
<li> <code>echo /home/${USER}/${FILE}</code>
<li> <code>echo $USER$FILE</code>
<li> <code>echo "$USER"ny</code>
<li> <code>echo $USERny</code>
</ol>
</div>

<h3 id="env-set">6.2. 環境変数を設定する</h3>
<p>
各プロセスの環境変数は、一般にそのプロセスの<strong>起動時にだけ</strong>設定できる。
プロセスの起動時に環境変数を設定するには、実行したいコマンド引数の前に
「<code><strong>変数名</strong>=<strong>値</strong></code>」のような形式を追加する。
たとえば <code>date</code> コマンドは、
環境変数 <code>TZ</code> の値によって異なる時間帯の時刻を返す:
</p>
<blockquote><pre>
$ <strong>date</strong>
Mon Oct 31 06:56:48 JST 2022
$ <strong><mark>TZ=UTC</mark> date</strong>
Sun Oct 30 21:56:48 UTC 2022
$ <strong><mark>TZ=America/New_York</mark> date</strong>
Sun Oct 30 17:56:48 EDT 2022
</pre></blockquote>
<p>
また、親プロセスが持っている環境変数はすべて子プロセスに継承される。
そのため親プロセスに環境変数を設定しておけば、すべての子プロセスで共通の値が使える:
</p>
<blockquote><pre>
$ <strong>echo $XYZ</strong>       <em>(環境変数XYZは未定義)</em>

$ <strong>XYZ=abc123 zsh</strong>  <em>(環境変数XYZにabc123を設定して zshを起動)</em>
$ <strong>echo $XYZ</strong>       <em>(環境変数XYZに値が入っている)</em>
ABC123
</pre></blockquote>

<p>
例外はシェルで、シェルの中ではいつでも環境変数を作成・変更できる。
実際には、環境変数はより一般的な<u>シェル変数</u> (shell variable) の一部として扱われる。
シェル変数の一覧 (環境変数も含む) を表示するには
<code>set</code>コマンドを使う:
</p>
<blockquote><pre>
$ <strong>set</strong>
BASH=/bin/bash
COLUMNS=100
DISPLAY=:1
EDITOR=vi
…
</pre></blockquote>
<p>
シェル変数は、ただ
「<code><strong>変数名</strong>=<strong>値</strong></code>」のように書けば
値を設定できる。
</p>
<blockquote><pre>
$ <strong>XYZ=abc123</strong>  <em>(シェル変数XYZにabc123を設定)</em>
$ <strong>echo $XYZ</strong>   <em>(シェル変数XYZの値を表示する)</em>
</pre></blockquote>

<p>
ただし、<strong>すべてのシェル変数が環境変数として扱われるわけではない</strong>ことに注意。
環境変数として扱われるのは、シェル変数のうち
「export属性」をもつものだけである。
Export属性をもったシェル変数は、何も指定しなくても
以後シェルから起動したすべてのプロセスに環境変数として渡される:
</p>
<blockquote><pre>
$ <strong>XYZ=abc123</strong>  <em>(シェル変数XYZにabc123を設定)</em>
$ <strong>echo $XYZ</strong>   <em>(シェル変数XYZの値を表示する)</em>
abc123
$ <strong>env</strong>         <em>(XYZは環境変数ではない)</em>
…
$ <strong>export XYZ</strong>  <em>(XYZにexport属性をつける)</em>
$ <strong>env</strong>         <em>(XYZが環境変数として渡されている)</em>
…
XYZ=abc123
…
</pre></blockquote>

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="220" height="220">
  <g stroke="black" stroke-width="2" fill="none">
    <circle cx="110" cy="110" r="100" />
    <circle cx="140" cy="150" r="45" />
  </g>
  <g text-anchor="middle">
    <text x="110" y="80">シェル</text>
    <text x="110" y="100">変数</text>
    <text x="140" y="150">環境変数</text>
  </g>
</svg>
</div>

<h3 id="env-path">6.3. 重要な環境変数: PATHとHOME</h3>
<p>
UNIX の環境変数のなかでも <code>PATH</code> と <code>HOME</code> は
とくに重要である。
</p>
<h4>環境変数 PATH</h4>
<p>
通常、UNIX シェルでは第0引数としてコマンド (プログラム) のパス名を指定する:
</p>
<blockquote><pre>
$ <strong>/bin/ls -l /etc</strong>
</pre></blockquote>
しかし実際には以下のように書いても動く:
<blockquote><pre>
$ <strong>ls -l /etc</strong>
</pre></blockquote>
これを可能にしているのは環境変数 <code>PATH</code> のためである。
環境変数 <code>PATH</code> の中身を見てみると、
コロン (<code>:</code>) で区切られたパス名 (ディレクトリ名) の一覧が含まれているのがわかる:
<blockquote><pre>
$ <strong>echo $PATH</strong>
<mark>/usr/local/bin</mark>:<mark>/usr/bin</mark>:<mark>/bin</mark>
</pre></blockquote>
<p>
これは「あるコマンドが実行されたとき、
<code>/usr/local/bin/<em>コマンド名</em></code>、
<code>/usr/bin/<em>コマンド名</em></code>、
<code>/bin/<em>コマンド名</em></code>
のいずれかのプログラムを実行せよ」ということを表している。
PATH にはこのようなコマンドの「検索順序」が記録されている。
その証拠に、<code>PATH</code> をおかしな値にすると動かない:
</p>

<blockquote><pre>
$ <strong>PATH=xxx</strong>
$ <strong>ls</strong>
ls: command not found
$ <strong>/bin/ls</strong>
…
</pre></blockquote>

<p>
なお、<code>PATH</code> はよくシステムのデフォルト値をカスタマイズして
使うことが多い。<code>PATH</code> に独自のディレクトリを追加するには、以下のようにする:
</p>
<blockquote><pre>
PATH=$PATH:/home/euske/bin  <em>(/home/euske/bin もコマンド検索順序に追加する)</em>
</pre></blockquote>

<h4>環境変数 HOME</h4>
<p>
UNIX では、各ユーザのホームディレクトリは
<code>/home/<em>ユーザ名</em></code> とされているが、
これはただの慣例であり、実際にはどこであってもかまわない。
環境変数 <code>HOME</code> は、そのユーザの所有する
<u>ホームディレクトリ</u>のパス名を指定する。
これは起動時には通常そのユーザのデフォルト値が設定されているが、
この値を変更することで、どんなディレクトリでもホームディレクトリとして
使用することができる:
</p>
<blockquote><pre>
$ <strong>echo $HOME</strong>  <em>(環境変数HOMEの内容を表示する)</em>
/home/euske
$ <strong>cd</strong>          <em>(ホームディレクトリに移動)</em>
$ <strong>pwd</strong>         <em>(カレント・ディレクトリを表示)</em>
/home/euske
$ <strong>HOME=/etc</strong>   <em>(環境変数HOMEを変更する - ホームディレクトリが変更される)</em>
$ <strong>cd</strong>          <em>(ホームディレクトリに移動)</em>
$ <strong>pwd</strong>         <em>(カレント・ディレクトリを表示)</em>
/etc
</pre></blockquote>
<p>
また、シェルのコマンドライン上では <code>~</code> が
自分のホームディレクトリに展開されるが、
この値も実際には環境変数 <code>HOME</code> を展開しているだけである:
</p>
<blockquote><pre>
$ <strong>echo $HOME/work</strong>
/home/euske/work
$ <strong>echo ~/work</strong>
/home/euske/work
</pre></blockquote>
<p>
UNIX では、各ユーザのデフォルトのホームディレクトリ (やシェル) は
<code>/etc/passwd</code> というテキストファイル内に記載されている。
UNIX におけるホームディレクトリとは、つまるところ:
</p>
<ul>
<li> そのユーザが所有している
<li> 環境変数 <code>HOME</code> が、そのパス名に設定されている
</ul>
だけのものなのである。


<h2 id="fileops">7. ファイル操作コマンド</h2>
<p>
シェル上でファイル操作を行うためのおもなコマンドは以下のとおり:
</p>
<dl>
<dt id="cmd-ls"> <code>ls</code>
<dd> 指定したディレクトリに含まれるファイル一覧を表示する。
<pre>
$ <strong>ls</strong>
…  <em>(カレント・ディレクトリのファイル一覧を表示)</em>
$ <strong>ls /etc</strong>
…  <em>(ディレクトリ /etc のファイル一覧を表示)</em>
</pre>

<dt id="cmd-cd"> <code>cd</code> (Change Directory)
<dd> カレント・ディレクトリを変更する。
<pre>
$ <strong>cd /etc</strong>
<em>(カレント・ディレクトリを /etc に変更)</em>
$ <strong>cd</strong>
<em>(カレント・ディレクトリを自分のホームディレクトリに変更)</em>
</pre>

<dt id="cmd-pwd"> <code>pwd</code> (Print Working Directory)
<dd> カレント・ディレクトリのパス名を表示する。
<pre>
$ <strong>pwd</strong>
<em>(現在のパス名を表示)</em>
</pre>

<dt id="cmd-cat"> <code>cat</code> ・ <code>less</code>
<dd> ファイルの内容を表示する。
もともと <code>cat</code> は
複数のファイルを連結 (conCATenate) するためのコマンドだった。
<pre>
$ <strong>less /etc/services</strong>
<em>(/etc/services の内容を表示)</em>
$ <strong>cat /etc/hosts /etc/services</strong>
<em>(/etc/hosts の内容と /etc/services の内容を連結して表示)</em>
</pre>

<dt id="cmd-mkdir"> <code>mkdir</code> (MaKe DIRectory)
<dd> 空のディレクトリを新規作成する。
<pre>
$ <strong>mkdir foo</strong>
<em>(カレント・ディレクト下に foo を作成)</em>
</pre>

<dt id="cmd-cp"> <code>cp</code> (CoPy)
<dd> 指定したファイルを宛先パス名に複製する。
<pre>
$ <strong>cp a.txt b.txt</strong>
<em>(a.txt を新しい b.txt という名前で複製する)</em>
$ <strong>cp a.txt dest/</strong>
<em>(a.txt を dest/ ディレクトリ内に同じ名前で複製する)</em>
$ <strong>cp a.txt b.txt c.txt dest/</strong>
<em>(a.txt, b.txt, c.txt の各ファイルを dest/ 内に同じ名前で複製する)</em>
$ <strong>cp &ast;.txt dest/</strong>
<em>(〜.txt で終わるすべてのファイルを dest/ 内に同じ名前で複製する)</em>
</pre>
<p>
<code>cp</code> で複製できるのは、通常はファイルのみである。
あるディレクトリ内のファイルを (ディレクトリごと) 複製したい場合には
<code>-r</code> オプションを使う:
</p>
<pre>
$ <strong>cp -r foo dest/</strong>
<em>(foo ディレクトリ内とその中のファイルをすべて dest/ 内に複製する)</em>
</pre>
<div class=note>
<strong>注意:</strong>
UNIX は無愛想な OS なので、
コピー先としてうっかり存在するファイル名を指定してしまうと、
そのファイルは<strong>何の警告もなく</strong>上書きされる。
これを防ぐためには <code>-i</code> オプションを使う:
<pre>
$ <strong>cp -i a.txt b.txt</strong>
<em>(a.txt を新しい b.txt という名前で複製するが、
 すでに同名のファイルがある場合は確認する)</em>
</pre>
</div>

<dt id="cmd-mv"> <code>mv</code> (MoVe)
<dd> 指定したファイルを宛先パス名に変更あるいは移動する。
<pre>
$ <strong>mv a.txt b.txt</strong>
<em>(a.txt を新しい b.txt という名前に変更する)</em>
$ <strong>mv a.txt dest/</strong>
<em>(a.txt を dest/ ディレクトリ内に移動する)</em>
$ <strong>mv a.txt b.txt c.txt dest/</strong>
<em>(a.txt, b.txt, c.txt の各ファイルを dest/ 内に移動する)</em>
$ <strong>mv &ast;.txt dest/</strong>
<em>(〜.txt で終わるすべてのファイルを dest/ 内に移動する)</em>
</pre>
<div class=note>
<strong>注意:</strong>
UNIX は無愛想な OS なので、
移動先としてうっかり存在するファイル名を指定してしまうと、
そのファイルは<strong>何の警告もなく</strong>上書きされる。
これを防ぐためには <code>-i</code> オプションを使う:
<pre>
$ <strong>mv -i a.txt b.txt</strong>
<em>(a.txt を新しい b.txt という名前に変更するが、
 すでに同名のファイルがある場合は確認する)</em>
</pre>
</div>

<dt id="cmd-rm"> <code>rm</code> (ReMove)
<dd> 指定したファイルを削除する。
<pre>
$ <strong>rm a.txt</strong>
<em>(ファイル a.txt を削除する)</em>
$ <strong>rm &ast;.txt</strong>
<em>(〜.txt で終わるすべてのファイルを削除する)</em>
</pre>
<p>
<code>rm</code> で削除できるのは、通常はファイルのみである。
あるディレクトリ内のファイルを (ディレクトリごと) 削除したい場合には
<code>-r</code> オプションを使う:
</p>
<pre>
$ <strong>rm -r dest/</strong>
<em>(dest/ ディレクトリ内とその中のファイルをすべて削除する)</em>
</pre>
<div class=note>
<strong>注意:</strong>
UNIX は無愛想な OS なので、
<code>rm</code> コマンドは削除が成功しても何も表示しない。
削除するファイルをひとつずつ確認するためには
<code>-i</code> オプションを使う:
<pre>
$ <strong>rm -i &ast;.txt</strong>
<em>(〜.txt で終わる各ファイルを yes/no で確認しながら削除する)</em>
</pre>
</div>

<dt id="cmd-du"> <code>du</code> (DiskUse)
<dd> 指定したディレクトリのファイル使用量を表示する。
<pre>
$ <strong>du ~</strong>
<em>(ホームディレクトリの使用量を各ディレクトリごとに表示する)</em>
$ <strong>du -s .</strong>
<em>(カレントディレクトリの総使用量のみを表示する)</em>
</pre>

</dl>

<h4>パス名の指定方法に注意</h4>
<p>
<code>cp</code>, <code>mv</code>, <code>rm</code> などのコマンドでは
「<code>-</code>」で始まる引数はオプションとみなされる。
もし実際に "<code>-i</code>" というファイルを複製したい場合、
<code>cp -i a.txt</code> などとやってもうまくいかない:
</p>
<blockquote><pre>
$ <strong>cp -i a.txt</strong>
cp: missing destination file operand after 'a'
<em>(エラーが出て実行できない)</em>
</pre></blockquote>
<p>
このような場合には、2つの方法がある:
</p>
<ol type=a>
<li> 引数が「<code>-</code>」で始まらなけれさえすればよいので、
<code>-i</code> がカレント・ディレクトリにあることを利用して、
以下のようにする:
<blockquote><pre>
$ <strong>cp ./-i a.txt</strong>
<em>(カレント・ディレクトリの -i というファイルがコピーされる)</em>
</pre></blockquote>
<li> 多くの UNIX 標準コマンドは、引数に "<code>--</code>" が表れると、
それ以後の引数をオプションとして解釈することをやめ、
ファイル名として解釈するように実装されている。
このことを利用して:
<blockquote><pre>
$ <strong>cp -- -i a.txt</strong>
<em>(-i はオプションでなく実際のファイル名として解釈される)</em>
</pre></blockquote>
</ol>


<h2 id="scripting">8. シェルスクリプトの基礎</h2>
<p>
<u>シェルスクリプト</u>とは、シェルによって実行される簡単なプログラムである。
もっとも基本的なシェルスクリプトは、単に実行するコマンド列を1行にひとつずつ
並べたテキストファイルである。
(<code>#</code> 以降の文字列はコメントとして解釈される。)
</p>
<div class=file>
<div class=header>hello.sh</div>
<pre>
<em># 3つのコマンドを実行する。</em>
echo Hello!
date
ls /etc
</pre>
</div>
<p>
シェルスクリプトを実行するには、シェルの引数としてスクリプトの
ファイル名を与えればよい。シェルスクリプトの実行には通常 Bourne shell
(<code>/bin/sh</code>) が使われる:
</p>
<blockquote><pre>
$ <strong>sh hello.sh</strong>
Hello!                                                 <em>(echo が実行される)</em>
Sun Nov 13 14:48:02 JST 2022                           <em>(date が実行される)</em>
ImageMagick-7         logrotate.d           screenrc   <em>(ls /etc が実行される)</em>
X11                   lynx.cfg              securetty
alpine-release        lynx.lss              services
…
</pre></blockquote>

<h3 id="script-args">8.1. シェルスクリプトに与えられた引数を利用する</h3>
<p>
シェルスクリプトには、通常のコマンドと同様に引数を渡すことができる。
プロセス起動時に与えられた引数は、
第0引数から順に <code>$0</code>、<code>$1</code> …
というシェル変数として利用できる。
</p>
<div class=file>
<div class=header>showargs.sh</div>
<pre>
echo "Arg0: $0"
echo "Arg1: $1"
echo "Arg2: $2"
</pre>
</div>
<p>
上のシェルスクリプトを実行すると、以下のように表示される。
第0引数はスクリプトの名前 (パス名) になっているのがわかる:
</p>
<blockquote><pre>
$ <strong>sh showargs.sh foo bar baz</strong>
Arg0: showargs.sh  <em>(第0引数が表示される)</em>
Arg1: foo          <em>(第1引数が表示される)</em>
Arg2: bar          <em>(第2引数が表示される)</em>
</pre></blockquote>

<div class=exercise id="ex11">
<div class=header>演習 11. シェルスクリプトの説明</div>
<p>
以下のシェルスクリプトが何をするか推測せよ。
</p>
<pre>
# showhome.sh
ls -l "/home/$1"
</pre>
</div>

<h3 id="script-chmod">8.2. 通常のコマンドとして使う</h3>
<p>
UNIX では、通常実行するプログラムはその CPU 用にコンパイルされた
命令列が含まれる<u>バイナリファイル</u>である。
しかし UNIX ではそれ以外のファイル (テキストファイル) でも
実行できるような仕組みが用意されている。あるテキストファイルの
先頭が "<code>#!</code>" という特殊な 2バイトで始まっている場合、
UNIX はその行をもとに別のコマンドを呼び出すことができる。
</p><p>
例をあげて説明しよう。
たとえば、以下のようなテキストファイル <code>foobar</code> を作成する:
</p>
<div class=file>
<div class=header>foobar</div>
<pre>
#!/bin/cat
foo
bar
</pre>
</div>
<p>
UNIX では、実行するプログラム (ファイル) には必ず
<u>実行可能フラグ</u>が有効になっていなければならない。
そのため、まず <code>chmod</code> コマンドを使ってこのファイルの
実行可能フラグを立てる:
</p>
<blockquote><pre>
$ <strong>chmod +x foobar</strong>  <em>(ファイル foobar を実行可能にする)</em>
</pre></blockquote>
<p>
このファイルをシェルから実行すると、以下のように表示される:
</p>
<blockquote><pre>
$ <strong>./foobar</strong>
<mark>#!/bin/cat</mark>
foo
bar
</pre></blockquote>
<p>
一体、何が起こっているのか?
実は <code>foobar</code> をシェルから「実行」すると、
UNIX 内部では以下のコマンドが実行されている:
</p>
<blockquote><pre>
/bin/cat foobar
</pre></blockquote>
<p>
ここで実際に実行されるプログラム (第0引数) は
<code>/bin/cat</code> であり、
またその第1引数としてファイル自体へのパス名 <code>foobar</code> が渡される。
つまり <code>cat</code> に対して自分自身を表示するような
プログラムになっているのである。
</p><p>
この機能を使うと、シェルスクリプトを (わざわざ <code>sh</code> を使って実行しなくても)
通常のコマンドと同じように使うことができる。
たとえば、先ほどの <code>hello.sh</code> を以下のように変更してみよう
(拡張子は <code>.sh</code> でなくてもかまわない):
</p>
<div class=file>
<div class=header>hello</div>
<pre>
<em>#!/bin/sh</em>
echo Hello!
date
ls /etc
</pre>
</div>
<p>
これを通常のコマンドとして実行するには、以下のようにする:
</p>
<blockquote><pre>
$ <strong>chmod +x hello</strong>
$ <strong>./hello</strong>     <em>(/bin/sh hello と同様の結果が得られる)</em>
Hello!
Sun Nov 13 14:48:02 JST 2022
...
</pre></blockquote>
<p>
このファイルを環境変数 <code>PATH</code> で
指定したディレクトリ内に置いておけば、いまやこのシェルスクリプトは
通常のコマンドと同じように使えるわけである。
</p>

<div class=note>
<strong>注意:</strong>
シェルスクリプトは子プロセスとして実行される。UNIX では、
子プロセスは親プロセスの環境変数やカレントディレクトリを
変更することはできないので、シェルスクリプトの中で
環境変数やカレントディレクトリを変更しても親プロセスには影響を与えない。
したがって、それを呼び出したシェル (親プロセス) の
<strong>環境変数やカレントディレクトリを変更するようなシェルスクリプトを
書くことは不可能</strong>である:
<blockquote><pre>
$ <strong>cat gohome</strong>  <em>(シェルスクリプト gohome の内容を表示)</em>
cd "${HOME}"
$ <strong>cd /etc</strong>     <em>(カレントディレクトリを /etc に変更)</em>
$ <strong>./gohome</strong>    <em>(gohome を実行する)</em>
$ <strong>pwd</strong>         <em>(カレントディレクトリは依然として /etc のまま)</em>
/etc
</pre></blockquote>
<p>
(ちなみに、<code>cd</code> コマンドはシェルの内部コマンドで
プロセスを起動しない。そのためシェルのカレントディレクトリの変更が可能なのである。)
</div>

<div class=exercise id="ex12">
<div class=header>演習 12. スクリプトファイル</div>
<p>
以下のスクリプトファイル <code>greet</code> が実行可能であるとする。
<code>./greet</code> を実行すると何が起きるか?
<div class=file>
<div class=header>greet</div>
<pre>
#!/usr/bin/python3
import random
if random.random() &lt; 0.5:
    print("Good morning")
else:
    print("Good evening")
</pre>
</div>
</div>

<h3 id="script-exitcode">8.3. 終了状態による分岐</h3>
<p>
すべてのプロセスは、終了時に<u>終了状態</u>を返す。
これは、関数の返り値のようなものである。
UNIXの慣例では、正常終了した（成功した）プロセスは
終了状態 <code>0</code> を返し、そうでないプロセスは <code>0</code>以外の
終了状態を返すことになっている。
あるコマンドの終了状態を見るには、コマンド実行直後に
シェル変数 <code>$?</code> を表示すればよい:
</p>
<blockquote><pre>
$ <strong>ls /etc</strong>
ImageMagick-7         logrotate.d           screenrc
X11                   lynx.cfg              securetty
alpine-release        lynx.lss              services
…
$ <strong>echo $?</strong>
0          <em>(コマンドは成功したので終了状態は0)</em>
$ <strong>ls /nonexistent</strong>
ls: /nonexistent: No such file or directory
$ <strong>echo $?</strong>
1          <em>(エラーで終了したので終了状態は0)</em>
</pre></blockquote>
<p>
さらに、シェルではコマンドの終了状態に応じて
ふるまいを変更できる:
</p>
<ul>
  <li> <code>a &amp;&amp; b</code> … コマンド <code>a</code> が正常終了した (成功) 時にコマンド <code>b</code> を実行する。
    <pre>cd /etc &amp;&amp; ls &ast;.conf    <em>(/etcディレクトリにcdできたら、その中の .conf ファイル一覧を表示する)</em></pre>
  <li> <code>a || b</code> … コマンド <code>a</code> が正常終了しなかった (失敗) 時にコマンド <code>b</code> を実行する。
    <pre>cd /foo || echo "/foo does not exist"  <em>(/fooディレクトリにcdできなかったら、エラーを表示する)</em></pre>
</ul>
<p>
さらにこれらの条件式は、他のプログラミング言語と同様に <code>(</code> … <code>)</code> を使ってグループ化できる。
グループ化されたコマンド列の終了状態は、最後に実行されたコマンドの終了状態となる。
したがって、次のような例も可能:
</p>
<blockquote><pre>
<em># /fooディレクトリにcdできれば &ast;.conf一覧を表示し、そうでなければエラーを表示する。</em>
( cd /foo && ls &ast;.conf ) || echo "/foo does not exist"
</pre></blockquote>

<h3 id="script-subst">8.4. 文字列の操作</h3>
<p>
シェルでは文字列処理をおこなうための展開がいくつか用意されている。
代表的なものを以下にあげる:
</p>
<dl>
<dt> コマンド展開を使った置換
<dd> <a href="#command-exp">コマンド出力の展開</a> を参照。
<blockquote><pre>
<em># ファイルの個数を取得する。</em>
files=$(<mark>ls | wc -l</mark>)
</pre></blockquote>

<dt> ${変数名/文字列1/文字列2}
<dd> <em>文字列1</em> を <em>文字列2</em> に置換する:
<pre>
name=foo.csv
echo ${name/<mark>.csv</mark>/<mark>.txt</mark>}  <em># foo.txt</em>
</pre>

<dt> ${変数名:-デフォルト値}
<dd> 変数名が定義されていない (あるいは空文字列の) ときに <em>デフォルト値</em> に置換される:
<pre>
<em># 環境変数FILENAMEが定義されていればその値、なければ "default.txt"</em>
path=${FILENAME:-default.txt}
</pre>

</dl>


<h2 id="controls">9. 条件分岐・繰り返し</h2>
<p>
さて、シェルスクリプトの真のうまみは条件分岐や繰り返しを使って
コマンドを実行させることである。シェルでは、条件分岐や繰り返しをするときも
上で述べたコマンドの終了状態を使う。
</p>
<ul>
<li> 終了状態が <code>0</code> … そのコマンドの返り値は「真」として扱われる。
<li> 終了状態が <code>0</code> 以外 … そのコマンドの返り値は「偽」として扱われる。
</ul>
<p>
このため UNIX では、ある条件に応じて終了状態を変化させるため<strong>だけ</strong>のコマンド
<code>test</code> が存在する。
</p>

<h3 id="control-test">9.1. testコマンド</h3>
<p>
<code>test</code> コマンドは与えられた条件に応じて真偽値に対応する終了状態を返す:
</p>
<ul>
  <li> <code>test -f <mark>パス名</mark></code>: 与えられた <mark>パス名</mark> にファイルが存在したら真。
  <li> <code>test -d <mark>パス名</mark></code>: 与えられた <mark>パス名</mark> にディレクトリが存在したら真。
  <li> <code>test <mark>引数A</mark> = <mark>引数B</mark></code>: 与えられた <mark>引数A</mark> と <mark>引数B</mark> が同一であれば真。
  <li> <code>test ! -f <mark>パス名</mark></code>: 与えられた <mark>パス名</mark> にファイルが存在しなかったら真。
  <li> <code>test ! -d <mark>パス名</mark></code>: 与えられた <mark>パス名</mark> にディレクトリが存在しなかったら真。
  <li> <code>test <mark>引数A</mark> != <mark>引数B</mark></code>: 与えられた <mark>引数A</mark> と <mark>引数B</mark> が同一でなければ真。
  <li> ...
</ul>
<p>
なお、見やすさのため、<code>test</code>コマンドと同様の機能をもつ
<code>&lbrack;</code> というコマンドが用意されている。
この場合は、以下のように記述する:
</p>
<ul>
  <li> <code>[ -f <mark>パス名</mark> ]</code>: 与えられた <mark>パス名</mark> にファイルが存在したら真。
  <li> <code>[ -d <mark>パス名</mark> ]</code>: 与えられた <mark>パス名</mark> にディレクトリが存在したら真。
  <li> <code>[ <mark>引数A</mark> = <mark>引数B</mark> ]</code>: 与えられた <mark>引数A</mark> と <mark>引数B</mark> が同一であれば真。
  <li> <code>[ ! -f <mark>パス名</mark> ]</code>: 与えられた <mark>パス名</mark> にファイルが存在しなかったら真。
  <li> <code>[ ! -d <mark>パス名</mark> ]</code>: 与えられた <mark>パス名</mark> にディレクトリが存在しなかったら真。
  <li> <code>[ <mark>引数A</mark> != <mark>引数B</mark> ]</code>: 与えられた <mark>引数A</mark> と <mark>引数B</mark> が同一でなければ真。
  <li> ...
</ul>
<p>
<code>test</code>コマンドはこれ以外にも多くの演算や条件式の組み合わせが可能である。
詳しくは <code>man test</code> を参照のこと。
</p>

<h3 id="control-if">9.2. if … then 〜 fi文</h3>
<p>
if文の使い方は、通常のプログラミング言語とほとんど同じである。
</p>
<dl>
<dt> 書式:
<dd> <pre>
if <mark>条件式</mark>; then
    <mark>処理</mark>
fi
</pre>
ここでいう<code>条件式</code>とは、
実際にはひとつのコマンドのことである。
<div class=note>
<strong>注意:</strong>
条件式の最後の <code>;</code> を忘れないように!
</div>
<dt> 例1:
<dd> <pre>
if <mark>cd /foo</mark>; then
    echo "success"  <em># cd /foo に成功</em>
fi
</pre>
<dt> 例2 (else節を追加):
<dd> <pre>
if <mark>cd /foo</mark>; then
    echo "success"  <em># cd /foo に成功</em>
else
    echo "fail"     <em># cd /foo に失敗</em>
fi
</pre>
</dl>

<div class=exercise id="ex13">
<div class=header>演習 13. dog</div>
<p>
与えられたパス名に対して、
それがファイルであれば <code>cat</code> を実行し、
ディレクトリであれば <code>ls</code> を実行するコマンド
<code>dog</code> を作りたい。以下のシェルスクリプトを完成させよ:
</p>
<div class=file>
<div class=header>dog</div>
<pre>
#!/bin/sh
if <nobr><span class=blank>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></nobr>; then
    cat $1
else
    ls $1
fi
</pre>
</div>
</div>

<h3 id="control-while">9.3. while … do 〜 done文</h3>
<p>
これも通常のプログラミング言語におけるwhile文とほとんど同じである。
</p>
<dl>
<dt> 書式:
<dd> <pre>
while <mark>条件式</mark>; do
    <mark>処理</mark>
done
</pre>
<div class=note>
<strong>注意:</strong>
条件式の最後の <code>;</code> を忘れないように!
</div>
<dt> 例:
<dd> <pre>
while <mark>[ -d /foo/bar ]</mark>; do
    <em># フォルダ /foo/bar が存在している間はメッセージを出力。</em>
    <mark>echo "/foo/bar exists"</mark>
    <mark>sleep 1</mark>
done
</pre>
</dl>

<h3 id="control-for">9.4. for … do 〜 done文</h3>
<p>
シェルスクリプトの for文は、与えられた各引数を指定された変数に代入しながら
繰り返し処理を実行する。
Python における <code>for</code>文、
あるいは JavaScript における <code>for … of</code>構文に似ている。
</p>
<dl>
<dt> 書式:
<dd> <pre>
for <mark>変数名</mark> in <mark>引数1 引数2 …</mark>; do
    <mark>処理</mark>
done
</pre>
<div class=note>
<strong>注意:</strong>
引数の最後の <code>;</code> を忘れないように!
</div>
<dt> 例1:
<dd> <pre>
for <mark>file</mark> in <mark>&ast;.txt</mark>; do
    <em># &ast;.txtで終わる各ファイルを &ast;.txt.orig に名前変更する。</em>
    <mark>echo "Renaming: ${file}"</mark>
    <mark>mv ${file} ${file}.orig</mark>
done
</pre>
<dt> 例2:
<dd> <pre>
for <mark>name</mark> in <mark>$(cat files.txt)</mark>; do
    <em># files.txtの各行をファイル名一覧とみなし、それらのファイルの内容を表示する。</em>
    <mark>echo "--- ${name} ---"</mark>
    <mark>cat ${name}</mark>
done
</pre>
<dt> 例3:
<dd> 変数 <code>$*</code> は、シェルのすべての引数
 (<code>$1</code>, <code>$2</code>, <code>$3</code>, ...) の一覧に展開される。
 (なお、変数 <code>$#</code> は、引数の<strong>個数</strong>に展開される。)
<pre>
for <mark>arg</mark> in <mark>$*</mark>; do
    <em># シェルの各引数をひとつずつ表示する。</em>
    <mark>echo "Arg: ${arg}"</mark>
done
</pre>
</dl>

<div class=exercise id="ex14">
<div class=header>演習 14. for文の演習</div>
<p>
いくつかのディレクトリの中に、
<code>list.txt</code> というファイルが入っているとする。
各ディレクトリ中の <code>list.txt</code> を
<code><em>ディレクトリ名</em>_list.txt</code> という名前に変更したい。
そのため、以下のようなスクリプトを書いた:
</p>
<blockquote><pre>
#!/bin/sh
for name in $*; do
    echo "Renaming: ${name}/list.txt −&gt; ./${name}_list.txt"
    mv ${name}/list.txt ./${name}_list.txt
done
</pre></blockquote>
<ul>
<li> このスクリプトの使い方を説明せよ。何を引数として与えると、どうなるか?
<li> このスクリプトは <code>mv</code> コマンドを使ってファイル名を変更している。
  これにともなうリスクを説明せよ。
</ul>
</div>

<div class=note>
<strong>注意:</strong>
複数のファイルを一括変更するような処理の場合、
<strong>入力ファイルと出力ファイルを同じにしない</strong>こと!
<pre>
for file in &ast;.txt; do
    <em># ❌ ${file} を読む前に ${file} が上書きされてしまう。</em>
    cat <mark>${file}</mark> footer.txt &gt; <mark>${file}</mark>
done
</pre>
<p>
このような場合は、ファイルを一度別の名前に移してから処理をおこなう。
(あるいは一時ファイルを作成し、それを元のファイルに上書きする。)
</p>
<pre>
  for file in &ast;.txt; do
    <em># まず ${file} を ${file}.orig に名前変更する。</em>
    mv <mark>${file}</mark> <u>${file}.orig</u>
    <em># ${file}.orig に加えた変更をもとのファイルとして保存する。</em>
    cat <u>${file}.orig</u> footer.txt &gt; <mark>${file}</mark>
done
</pre>
</div>


<h2 id="oneliner">10. ワンライナー (one-liner) を書く時の注意点</h2>
<p>
UNIXでは、ちょっとした作業をするために１行のシェルスクリプト (ワンライナー) を
即席で書いて実行することがある。よくあるのが各ファイルについて何らかの
処理をおこなうというものである:
</p>
<blockquote><pre>
for file in myfiles/&ast;; do
    <em># ...${file}に対してなんらかの処理をおこなう...</em>
done
</pre></blockquote>
<p>
しかしこのような処理は多くのファイルを一度に変更することが多く、危険である。
このようなとき、おすすめの安全策がある。
</p>
<ol>
  <li> 危険なコマンドを <code>echo</code> で表示するだけにしておく。
<pre>
<em># dir1/の各.txtファイルに footer.txt を追加して dir2/ に保存する。</em>
<em># 注意: &gt; が入っているのでコマンドライン全体を "〜" で囲むこと。</em>
for file in dir1/&ast;.txt; do <mark>echo</mark> "cat ${file} footer.txt &gt; dir2/${file}"; done
</pre>
  <li> 出力が正しいことを確認したら、このシェルスクリプト全体を <code>sh</code> に通す。
<pre>
for file in dir1/&ast;.txt; do echo "cat ${file} footer.txt &gt; dir2/${file}"; done <mark>| sh</mark>
</pre>
</ol>

<div class=exercise id="ex15">
<div class=header>演習 15. まとめ問題</div>
<ol>
<li> 以下の用語の違いを説明せよ:
<ul>
<li> プログラム
<li> プロセス
<li> コマンド
</ul>
<li> 以下のコマンドがそれぞれ何をするか簡単に説明せよ:
<ul>
<li> <code>less</code>
<li> <code>pwd</code>
<li> <code>ps</code>
<li> <code>kill</code>
<li> <code>grep</code>
<li> <code>echo</code>
<li> <code>export</code>
<li> <code>mv</code>
<li> <code>rm</code>
<li> <code>chmod</code>
</ul>
<li> 空のディレクトリで、
以下のコマンド列を実行すると何が表示されるか答えよ:
<blockquote><pre>
$ <strong>echo &gt; hello</strong>
$ <strong>echo &gt; world</strong>
$ <strong>echo &ast;</strong>
</pre></blockquote>
<li> TODO リストを管理するための簡単なスクリプト todo を作りたい。
これは特定のテキストファイルに「やることの一覧」を記録する。<br>
このスクリプトは、以下のように使うものとする:
<ul>
<li> <code>todo</code> だけを実行すると、そのテキストファイルが表示される。
<li> <code>todo edit</code> と実行すると、そのテキストファイルが
何らかのテキストエディタ (なんでもよい) で編集可能になる。
<li> <code>todo <em>やること</em></code> と実行すると、文字列「<code>やること</code>」が
テキストファイルに追加される。
<li> そのテキストファイルの位置は、環境変数 <code>TODOFILE</code> によって
決まるものとする。
</ul>
<p>以下の空欄を埋めよ:</p>
<div class=file>
<div class=header>todo</div>
<pre>
#!/bin/sh
if [ $# = 0 ]; then
    <em># 引数がない場合は、テキストファイルの内容を表示。</em>
    cat <nobr><span class=blank>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></nobr>
elif [ $1 = "edit" ]; then
    <em># 引数が "edit" の場合は、テキストファイルを編集。</em>
    <nobr><span class=blank>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></nobr>
else
    <em># 引数がそれ以外の場合は、テキストファイルに内容を追加。</em>
    <nobr>cat "$*" &gt;&gt; <span class=blank>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></nobr>
fi
</pre>
</div>
</ol>
</div>

<h2 id="books">11. おすすめの書籍</h2>
<ul>
<li> <a href="https://www.amazon.co.jp/dp/429713148X/">［試して理解］Linuxのしくみ　―実験と図解で学ぶOS、仮想マシン、コンテナの基礎知識【増補改訂版】</a>
- 最近評判のよい本。OS の内部まで学習したい人向け。
<li> <a href="https://www.amazon.co.jp/dp/B00KRB9U8K/">詳解UNIXプログラミング 第3版</a>
- 通称「Stevensの本」と呼ばれる歴史的名著。
</ul>


<hr>
<address>Yusuke Shinyama</address>
