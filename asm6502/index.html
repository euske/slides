<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="./common.css">
<title>6502 アセンブラ プログラミング入門
/ 新山 祐介</title>
<style><!--
.author { text-align: right; }
.bin { font-family: Courier New, Courier, monospace; font-style: italic; font-weight: 900; color: blue; }
.hex { font-family: Courier New, Courier, monospace; font-style: italic; font-weight: 900; color: darkgreen; }
.dec { font-family: serif; font-style: italic; font-weight: 900; color: red; }
--></style>
</head>
<body>
<div class=nav>
<a href="../index.html">&lt; もどる</a>
</div>

<h1>6502 アセンブラ プログラミング入門</h1>
<div class=author>
Yusuke Shinyama, Mar. 2023
</div>

<p>
<strong>概要:</strong>
この記事では 8ビット CPU 6502 を
使ったアセンブラプログラミングを紹介する。
「アセンブラプログラミング」とは、プログラミング言語を使わず、
CPU のネイティブ命令列を直接書くプログラミング方法である。
6502 はいまから約50年前に開発され、
ファミコンや Apple II など多くのハードウェアで利用された。
しかし、その原理は今日のコンピュータとほとんど変わっていない。
ここでは 6502 のプログラミングを通して、コンピュータの本質を学習する。
</p>

<ol>
<li> <a href="#6502intro">6502 プログラミング入門</a>
<ul>
  <li> <a href="#computer">コンピュータの原理</a>
  <li> <a href="#6502register">レジスタとは</a>
  <li> <a href="#hexadecimal">16進数とは</a>
</ul>
<li> <a href="#6502emu">6502エミュレータを使った演習</a>
<ul>
  <li> <a href="#6502mem">メモリに値を格納する</a>
  <li> <a href="#6502loop">メモリの値を増加させながらループする</a>
</ul>
<li> <a href="#assembly">アセンブラを使ったプログラミング</a>
<ul>
  <li> <a href="#firstasm">最初のプログラム (改良版)</a>
  <li> <a href="#jumpinst">アセンブラを使ったジャンプ命令</a>
  <li> <a href="#dispaddr">差分アドレッシング</a>
  <li> <a href="#branch">条件分岐</a>
  <li> <a href="#branch2">条件分岐 その2</a>
</ul>
<li> <a href="#16bits">16ビットの値を計算する</a>
<ul>
  <li> <a href="#fillscreen">16ビット値を使った画面書き換え</a>
</ul>
<li> <a href="#famicom">ファミコン (NES) と 6502</a>
<li> <a href="#modern">現代のコンピュータとの違い</a>
<ul>
  <li> <a href="#os">オペレーティングシステム (OS) とは何か?</a>
</ul>
</ol>


<h2 id="6502intro">1. 6502 プログラミング入門</h2>

<h3 id="computer">1.1. コンピュータの原理</h3>
<p>
はじめに、コンピュータの原理を復習しよう。

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="130">
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="10" y="10" width="80" height="40" />
      <rect x="120" y="10" width="80" height="40" />
      <rect x="230" y="10" width="80" height="40" />
      <rect x="120" y="80" width="80" height="40" />
      <line x1="90" y1="30" x2="120" y2="30" />
      <line x1="200" y1="30" x2="230" y2="30" />
      <line x1="160" y1="50" x2="160" y2="80" />
    </g>
    <g text-anchor="middle">
      <text x="50" y="30">入力装置</text>
      <text x="160" y="30">演算装置</text>
      <text x="270" y="30">出力装置</text>
      <text x="160" y="100">記憶装置</text>
    </g>
  </svg>
</div>
<ol>
<li> 入力装置 … マウス、キーボードなど。
<li> 出力装置 … 画面、スピーカなど。
<li> 記憶装置 … メモリ、ハードディスクなど。
<li> 演算装置 … プログラムの実行をおこなう中心部分。
</ol>

<p>
この中でもっとも重要なのが演算装置 (<u>CPU</u>) である。
CPU は「<u>機械語</u> (machine language)」で書かれた命令列を
逐次実行する機能をもっている。機械語は
(Python や JavaScript のような) 現代的なプログラミング言語とは違い、
文字列で書かれていない。機械語のプログラムは、
数値 (命令語) の列によって表現される。

<p>
本日は
「<a target="_blank" href="https://ja.wikipedia.org/wiki/MOS_6502">MOS 6502</a>」という、
1975年に開発された原始的な CPU (のエミュレータ) を使ってみる。
これはファミコンや Apple II などの初期のパソコンに使われていた。
価格は $100 程度で、当時としては破格に安かった。
<p>
MOS 6502 は、以下のような機能をもっている:
<ul>
  <li> 使える変数は 3つ (A, X, Y) だけ。
    変数に入れられるのは 8ビットの値 (0〜255) まで。
  <li> 使えるメモリは最大 65536バイトである。
    各要素には 8ビットの値を入れることができる。
  <li> 足し算、引き算、メモリ上の値のコピー、条件分岐、繰り返し処理が可能。
</ul>

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="180">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g stroke="black" stroke-width="2" fill="none">
      <rect x="10" y="10" width="100" height="160" />
      <rect x="20" y="70" width="80" height="40" />
      <rect x="150" y="20" width="60" height="30" />
      <rect x="250" y="10" width="100" height="160" />
      <rect x="270" y="75" width="60" height="20" />
      <rect x="270" y="105" width="60" height="20" />
      <rect x="270" y="135" width="60" height="20" />
    </g>
    <g stroke="black" stroke-width="8" fill="none" marker-end="url(#arrow)">
      <line x1="100" y1="90" x2="240" y2="90" />
      <line x1="250" y1="35" x2="220" y2="35" />
      <line x1="150" y1="35" x2="120" y2="35" />
    </g>
    <g text-anchor="middle">
      <text x="60" y="40">記憶装置</text>
      <text x="60" y="90" style="font-size:80%;">プログラム</text>
      <text x="180" y="110">命令語</text>
      <text x="180" y="40">PC</text>
      <text x="230" y="20">+1</text>
      <text x="300" y="40">CPU</text>
      <text x="300" y="90">A</text>
      <text x="300" y="120">X</text>
      <text x="300" y="150">Y</text>
    </g>
  </svg>
</div>

<p>
CPU には、もうひとつ特別な変数 <u>PC</u> (プログラム・カウンタ) がある。
これは、次に記憶装置上のどの命令語を読むかの位置を示しており、
CPU は命令を読んでは実行を永久にくりかえす。
CPU の動作を JavaScript 風に書くと、次のようになる:
(実際にはこれはプログラムではなく電子回路そのものによって実現されている)

<blockquote><pre>
<span class=comment>// メモリの内容 (65536要素の配列)</span>
M = [0, 0, 0, 0, 0, ... ]
<span class=comment>// PCは現在実行する命令の位置。</span>
PC = 0

<span class=comment>// 以下を永久にくり返す。</span>
while (true) {
    <span class=comment>// 現在の命令を調べる。</span>
    command = M[PC]
    if (command == 1) {
        A = A + 1  <span class=comment>// 変数 A に1を足す。</span>
    } else if (command == 2) {
        A = A - 1  <span class=comment>// 変数 A から1を引く。</span>
    } else if
        ...
    }
    <span class=comment>// 次の命令を実行。</span>
    PC = PC + 1
}
</pre></blockquote>

<h3 id="6502register">1.2. レジスタとは</h3>
<p>
CPU の中では、変数のことを<u>レジスタ</u> (register) とよぶ。
MOS 6502 には以下のようなレジスタが装備されている。

<div class=figure>
<table border>
<tr><th>名前</th><th>大きさ</th><th>機能</th></tr>
<tr><td>PC</td><td>16ビット</td><td>これから実行する命令のメモリ上の位置。</td></tr>
<tr><td>Aレジスタ</td><td>8ビット</td><td>計算のために使う。</td></tr>
<tr><td>Xレジスタ</td><td>8ビット</td><td>メモリ上の位置を指すために使う。(後述)</td></tr>
<tr><td>Yレジスタ</td><td>8ビット</td><td>(今回は使わない)</td></tr>
<tr><td>Zフラグ</td><td>1ビット</td><td>計算結果がゼロになったときに 1 になる。(後述)</td></tr>
<tr><td>Cフラグ</td><td>1ビット</td><td>計算結果が桁あふれしたときに 1 になる。(後述)</td></tr>
</table>
</div>

<h3 id="hexadecimal">1.3. 16進数とは</h3>
<p>
現代のコンピュータは、すべての情報は 2進数のビットで表現される。
ただし 2進数はそのまま表記すると長いので、2進数を短く表記するのに
<u>16進数</u>  (Hexadecimal, 通称Hex) が使われることが多い。
16進数では、1ケタの文字で 4ビット (=16種類) の数を表わせる。

<div class=figure>
<table border>
<tr><th>10進数</th><th>2進数</th><th>16進数</th></tr>
<tr><td><span class=dec>0</span></td><td><span class=bin>0000</span></td><td><span class=hex>0</span></td></tr>
<tr><td><span class=dec>1</span></td><td><span class=bin>0001</span></td><td><span class=hex>1</span></td></tr>
<tr><td><span class=dec>2</span></td><td><span class=bin>0010</span></td><td><span class=hex>2</span></td></tr>
<tr><td><span class=dec>3</span></td><td><span class=bin>0011</span></td><td><span class=hex>3</span></td></tr>
<tr><td><span class=dec>4</span></td><td><span class=bin>0100</span></td><td><span class=hex>4</span></td></tr>
<tr><td><span class=dec>5</span></td><td><span class=bin>0101</span></td><td><span class=hex>5</span></td></tr>
<tr><td><span class=dec>6</span></td><td><span class=bin>0110</span></td><td><span class=hex>6</span></td></tr>
<tr><td><span class=dec>7</span></td><td><span class=bin>0111</span></td><td><span class=hex>7</span></td></tr>
<tr><td><span class=dec>8</span></td><td><span class=bin>1000</span></td><td><span class=hex>8</span></td></tr>
<tr><td><span class=dec>9</span></td><td><span class=bin>1001</span></td><td><span class=hex>9</span></td></tr>
<tr><td><span class=dec>10</span></td><td><span class=bin>1010</span></td><td><span class=hex>a / A</span></td></tr>
<tr><td><span class=dec>11</span></td><td><span class=bin>1011</span></td><td><span class=hex>b / B</span></td></tr>
<tr><td><span class=dec>12</span></td><td><span class=bin>1100</span></td><td><span class=hex>c / C</span></td></tr>
<tr><td><span class=dec>13</span></td><td><span class=bin>1101</span></td><td><span class=hex>d / D</span></td></tr>
<tr><td><span class=dec>14</span></td><td><span class=bin>1110</span></td><td><span class=hex>e / E</span></td></tr>
<tr><td><span class=dec>15</span></td><td><span class=bin>1111</span></td><td><span class=hex>f / F</span></td></tr>
</table>
</div>


<h2 id="6502emu">2. 6502エミュレータを使った演習</h2>
<p>
ブラウザで <a target="_blank" href="http://visual6502.org/JSSim/expert.html">http://visual6502.org/</a>
を開き、"Visual Sim / 6502" の "Advanced" リンクをクリックする。
これは本物の 6502 の電子回路の動きをブラウザ上で仮想的に再現するエミュレータである。

<ul>
<li> 赤色の部分 (<span style="background:#ff4d4d; padding-left:2em;">&nbsp;</span>) は、
  +5V の電圧がかかっていることを示す。
<li> 緑色の部分 (<span style="background:#4dff4d; padding-left:2em;">&nbsp;</span>) は、
  0V の電圧がかかっている (接地) ことを示す。
<li> 黄色の部分 (<span style="background:#ffff00; padding-left:2em;">&nbsp;</span>) は、
  中間的な電圧がかかっていることを示す。
</ul>

<h3 id="6502mem">2.1. メモリに値を格納する</h3>
<p>
では最初のプログラムとして、メモリ上のある位置
(演算装置の世界では、番地または <u>アドレス</u> (address) と呼ばれる) に
ある8ビットの数値を格納する処理をやってみる。
これは、以下のような16進数の数値の羅列で表現される。

<div class=file>
プログラム1
<pre>
0000: A9 01     <span class=comment>; LDA #$01 - Aレジスタに $01 を格納。</span>
0002: 95 10     <span class=comment>; STA $10  - Aレジスタの値をメモリの $10 番地に格納。</span>
0004: 00        <span class=comment>; BRK      - CPUの停止。</span>
</pre></div>

<p>
右側の「<code>LDA #$01</code>」などは<u>アセンブリ表記</u>と呼ばれ、
命令語を人間がわかりやすいように書いたものである
(アセンブリ「言語」という呼び方もあるが、通常のプログラミング言語よりも
ずっと原始的である)。
<code>$<span class=hex>XX</span></code> というのは
16進数の数値であることを表す。
これは JavaScript でいえば、以下のような処理に等しい:
<blockquote><pre>
A = 1        <span class=comment>// LDA #$01</span>
M[0x10] = A  <span class=comment>// STA $10</span>
</pre></blockquote>

<p>
プログラムは、メモリ上の 16進数が書かれている部分を
ダブルクリックして直接入力する。
ここでは <code>LDA</code>命令、<code>STA</code>命令、<code>BRK</code>命令を使っている。
<div class=figure>
<table border>
<tr><th>命令語 (16進)</th><th>バイト数</th><th>表記</th><th>機能</th></tr>
<tr><td><code><span class=hex>A9</span> <mark><span class=hex>XX</span></mark></code></td>
  <td>2 (命令 1 + 値 1)</td>
  <td><code>LDA #$<mark><span class=hex>XX</span></mark></code></td>
  <td>Aレジスタに値 16進数 <mark><span class=hex>XX</span></mark> を記録する。</td>
</tr>
<tr><td><code><span class=hex>95</span> <mark><span class=hex>XX</span></mark></code></td>
  <td>2 (命令 1 + アドレス 1)</td>
  <td><code>STA $<mark><span class=hex>XX</span></mark></code></td>
  <td>Aレジスタの値をメモリの <mark><span class=hex>XX</span></mark> 番地に記録する。</td>
</tr>
<tr><td><code><span class=hex>00</span></code></td>
  <td>1</td>
  <td><code>BRK</code></td>
  <td>制御装置を停止する。</td>
</tr>
</table>
</div>

<div class=exercise id="ex-mnemonic">
<div class=header>演習. 命令語の解釈</div>
<p>
次の命令語は何を意味するか?
<blockquote><pre>
A5 03
</pre></blockquote>
</div>

<p>
(もっと詳しい命令語と数値の対応表は以下を参照のこと)
<ul>
<li> <a target="_blank" href="http://www.6502.org/tutorials/6502opcodes.html">6502 命令表</a>
<li> <a target="_blank" href="https://wiki.nesdev.com/w/index.php/CPU_unofficial_opcodes">命令表 その2</a>
</ul>

<h3 id="6502loop">2.2. メモリの値を増加させながらループする</h3>
<p>
次に足し算とおこなう <code>ADC</code>命令 とジャンプ命令 <code>JMP</code> を使ってみる。
「ジャンプ命令」とは繰り返し処理をおこなうための命令で、
これがくると CPU は指定されたアドレスから実行をおこなう。
つまり、以前実行した命令にまた戻ることができる。
なお、ジャンプ命令がやっていることは、
実際には PC レジスタの値を書き換えることだけである。

<div class=file>
プログラム2
<pre>
0000: A9 01
0002: 95 10
0004: 69 02     <span class=comment>; ADC #$02 - Aレジスタに $02 を足す。</span>
0006: 4C 02 00  <span class=comment>; JMP $0002 - $0002番地の命令にジャンプする。</span>
</pre></div>

<p>
これは、JavaScript でいえば、以下のような処理に(ほぼ)等しい:
<blockquote><pre>
A = 1            <span class=comment>// LDA #$01</span>
while (true) {
    M[0x10] = A  <span class=comment>// STA $10</span>
    A = A + 2    <span class=comment>// ADC #$02</span>
}
</pre></blockquote>

<div class=figure>
<table border>
<tr><th>命令語 (16進)</th><th>バイト数</th><th>表記</th><th>機能</th></tr>
<tr><td><code><span class=hex>69</span> <mark><span class=hex>XX</span></mark></code></td>
  <td>2 (命令 1 + 値 1)</td>
  <td><code>ADC #$<mark><span class=hex>XX</span></mark></td>
  <td>Aレジスタの値に 16進数で <mark><span class=hex>XX</span></mark> を加える。</td>
</tr>
<tr><td><code>4C <mark>PP QQ</mark></code></td>
  <td>3 (命令 1 + アドレス 2)</td>
  <td><code>JMP $<mark><span class=hex>QQPP</span></mark></code></td>
  <td>16進数で <mark><span class=hex>QQPP</span></mark> 番地から実行を開始する。
    <p><strong>アドレスの上2桁、下2桁が逆になっている</strong>ことに注意。
      (リトルエンディアン)
  </td>
</tr>
</table>
</div>

<div class=exercise id="ex-use-emulator">
<div class=header>演習. エミュレータを使った実行</div>
<p>
上のプログラム1 および 2をエミュレータ上で実際に実行せよ。
プログラム2で Aレジスタの値が <span class=hex>FF</span> を超えると何が起こるか?
</div>


<h2 id="assembly">3. アセンブラを使ったプログラム</h2>

<p>
いちいち命令語を数値で表すのは面倒くさいので、
これからは <u>アセンブラ</u> (assembler) というものを使う。
これは、CPU の各命令語をアセンブリ表記で入力すると、
自動的に機械語の数値列に変換するものである。
ここでは別のサイト <a target="_blank" href="http://6502asm.com/">http://6502asm.com</a> を使う。

<h3 id="firstasm">3.1. 最初のプログラム (改良版)</h3>
<div class=file>
プログラム3
<pre>
LDA <mark>#</mark>$01
STA $0200
</pre></div>

<p>
アセンブラではさらに、以下のような表記の決まりがある:
<ul>
<li> <code><mark>#</mark>$01</code> … <code>$01</code> という値そのもの。
<li> <code>$0200</code> … <code>$0200</code> という「メモリ上のアドレスに入っている」値。
</ul>

<p>
6502asm.com のエミュレータでは、
メモリ上の <code>$0200</code> 〜 <code>$05ff</code> の範囲が
画面の各ピクセルに対応している。
ここに値を格納すると、それが実際に画面に表示される。
つまり、ここではメモリへの書き込みが出力装置も兼ねているのである。

<p>
コンピュータにとって、画面やハードディスク (記憶装置) は、
どれもただの巨大な配列でしかない。
コンピュータにとっての「入力」とか「表示」とかいった処理は、
実際には、入力装置・出力装置から
0 と 1 をコピーしているだけである。
</p>

<h3 id="jumpinst">3.2. アセンブラを使ったジャンプ命令</h3>
<p>
アセンブラを使うと、プログラム中の場所にラベルをつけることができ、
実際のアドレスを書くかわりに使うことができる。
<div class=file>
プログラム4
<pre>
    LDA #$01
<mark>loop:</mark>           <span class=comment>; ラベル "loop" をここに設定。</span>
    STA $0200
    ADC #$02
    JMP <mark>loop</mark>    <span class=comment>; "loop" のアドレスにジャンプする。</span>
</pre></div>

<p>
<strong>注意:</strong>
ラベル自体はただプログラム中の位置を表すもので、実際の命令ではない。

<h3 id="dispaddr">3.3. 差分アドレッシング</h3>
<p>
差分アドレッシングという機能を使うと、
メモリ上の可変の位置のデータを読み書きできる。
これは、画面上のある連続した領域を埋めるのに使える。
<div class=file>
プログラム5
<pre>
    LDA #$01
    LDX #$00     <span class=comment>; Xレジスタに $00 を格納。</span>
loop:
    STA $0200,X  <span class=comment>; Aレジスタの値を ($0200+X) の位置に格納。</span>
    ADC #$02
    INX          <span class=comment>; Xレジスタの値を 1だけ増やす。</span>
    JMP loop
</pre></div>
<p>
以下、JavaScript 相当の処理:
<blockquote><pre>
A = 1             <span class=comment>// LDA #$01</span>
X = 0             <span class=comment>// LDX #$00</span>
while (true) {
    M[0x0200+X] = A  <span class=comment>// STA $0200,X</span>
    A = A + 2     <span class=comment>// ADC #$02</span>
    X = X + 1     <span class=comment>// INX</span>
}
</pre></blockquote>

<div class=figure>
<table border>
<tr><th>命令語</th><th>バイト数</th><th>機能</th></tr>
<tr><td><code>LDX #$<mark><span class=hex>XX</span></mark></code></td>
  <td>2 (命令 1 + 値 1)</td>
  <td>Xレジスタに値 $<mark><span class=hex>XX</span></mark> を記録する。</td>
</tr>
<tr><td><code>STA $<mark><span class=hex>ZZZZ</span></mark>,X</code></td>
  <td>3 (命令 1 + アドレス 2)</td>
  <td>Aレジスタの値を ($<mark><span class=hex>ZZZZ</span></mark>+X) の位置に格納する。
    (差分アドレッシング)</td>
</tr>
<tr><td><code>INX</code></td>
  <td>1</td>
  <td>Xレジスタの値を 1だけ増やす。</td>
  </tr>
</table>
</div>

<div class=exercise id="ex-draw-pixel">
<div class=header>演習. 画面にピクセルを描画する</div>
<p>
上のプログラムをエミュレータ上で実際に実行せよ。
なぜ画面の一部しか更新されないのか?
</div>

<h3 id="#branch">3.4. 条件分岐</h3>
<p>
条件分岐とは、「場合によって、違ったことをする」
処理のことである。画面をつねに同じ色で塗るのではなくて、
「特定の場所に到達したときのみ、色を変える」にはどうするか?

<div class=file>
プログラム5
<pre>
    LDX #$00
loop:
    CPX #$10     <span class=comment>; Xレジスタの値を $10 と比較。</span>
    BEQ on       <span class=comment>; 等しければ、on に分岐する。</span>
    JMP off      <span class=comment>; 等しくなければ、off に分岐する。</span>
on:
    LDA #$01
    JMP put
off:
    LDA #$02
put:
    STA $0200,X
    INX
    JMP loop
</pre></div>
<p>
JavaScript 相当の処理:
<blockquote><pre>
X = 0              <span class=comment>// LDX #$00</span>
while (true) {
    if (X == 0x10) { <span class=comment>// CPX #$10, BEQ on</span>
        A = 1      <span class=comment>// LDA #$01</span>
    } else {
        A = 2      <span class=comment>// LDA #$01</span>
    }
    M[0x0200+X] = A   <span class=comment>// STA $0200,X</span>
    X = X + 1      <span class=comment>// INX</span>
}
</pre></blockquote>

<div class=figure>
<table border>
<tr><th>命令語</th><th>バイト数</th><th>機能</th></tr>
<tr><td><code>CPX #$<mark><span class=hex>XX</span></mark></code></td>
  <td>2 (命令 1 + 値 1)</td>
  <td>Xレジスタの値を $<mark><span class=hex>XX</span></mark> と比較する。
    <p>等しければ Zフラグを 1 にする。</td>
</tr>
<tr><td><code>BEQ <mark>ラベル</mark></code></td>
  <td>2 (命令 1 + アドレス 1)</td>
  <td>Zフラグが 1 ならば (直前の値が等しければ)、
  指定された<mark>ラベル</mark>に分岐する。</td>
</tr>
</table>
</div>

<P>
6502 では、比較・演算命令
(<code>ADC</code>, <code>CPX</code>, <code>INX</code> など) の結果によって
内部の<u>フラグ</u> (flag) が変化する。フラグとは 1ビットの特殊な変数で、
ふつう直前の計算によって生じた変化を記憶している。
<ul>
<li> Z (ゼロ) フラグ …
  計算結果がゼロになった場合に 1 になる。
  そうでない場合は 0 になる。
<li> C (キャリー) フラグ …
  計算結果、桁あふれまたは借り入れが発生した場合に 1 になる
  (たとえば 255 + 1、 0 - 2 など)。そうでない場合は 0 になる。
</ul>
<p>
上の<code>BEQ</code>命令は実際には何も計算してないように見えるが、
内部的には 2つの数の引き算をおこなっている。これによって、
2つの数が等しいときに結果が 0 になり、結果として Zフラグが 1 になる。

<h3 id="branch2">3.5. 条件分岐 その2</h3>
<p>
上の条件分岐は、以下のようにも書ける:
<div class=file>
プログラム5 (改良版)
<pre>
    LDX #$00
loop:
    LDA #$02
    CPX #$10
    BNE put      <span class=comment>; 等しくなければ、put に分岐する。</span>
    LDA #$01
put:
    STA $0200,X
    INX
    JMP loop
</pre></div>

<div class=figure>
<table border>
<tr><th>命令語</th><th>バイト数</th><th>機能</th></tr>
<tr><td><code>BNE <mark>ラベル</mark></code></td>
  <td>2 (命令 1 + アドレス 1)</td>
  <td>Zフラグが 0 ならば (直前の値が等しく<strong>なければ</strong>)、
  指定された<mark>ラベル</mark>に分岐する。</td>
</tr>
</table>
</div>


<h2 id="16bits">4. 16ビットの値を計算する</h2>
<p>
MOS 6502 ではほとんどの計算は 8ビットでしかできないが、
工夫することで 16ビットの計算が可能である。じつは "<code>ADC</code>" 命令は
与えられた数に加えて <strong>C フラグの値も加える</strong> ようにできており、
これを使って 8ビットの数を 2回に分けて計算する。

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="400" height="192">
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <g transform="translate(0.5,0.5)">
    <g fill="none" stroke="black" stroke-width="1">
      <line x1="0" y1="0" x2="280" y2="0" />
      <line x1="0" y1="20" x2="280" y2="20" />
      <line x1="40" y1="0" x2="40" y2="20" />
      <line x1="125" y1="0" x2="125" y2="20" />
      <line x1="210" y1="0" x2="210" y2="20" />
      <rect x="40" y="40" width="80" height="30" />
      <rect x="130" y="40" width="80" height="30" />
      <rect x="40" y="80" width="80" height="30" />
      <rect x="130" y="80" width="80" height="30" />
      <rect x="80" y="120" width="40" height="20" />
      <line x1="20" y1="115" x2="220" y2="115" />
      <line x1="0" y1="170" x2="280" y2="170" />
      <line x1="0" y1="190" x2="280" y2="190" />
      <line x1="40" y1="170" x2="40" y2="190" />
      <line x1="125" y1="170" x2="125" y2="190" />
      <line x1="210" y1="170" x2="210" y2="190" />
      <g marker-end="url(#arrow)" stroke-width="2">
	<line x1="100" y1="20" x2="100" y2="38" />
	<line x1="185" y1="20" x2="185" y2="38" />
	<line x1="100" y1="150" x2="100" y2="168" />
	<line x1="185" y1="150" x2="185" y2="168" />
      </g>
    </g>
    <g text-anchor="middle" style="font-family: monospace;">
      <text x="100" y="18">$30</text>
      <text x="185" y="18">$31</text>
      <text x="80" y="60">01</text>
      <text x="170" y="60">FF</text>
      <text x="80" y="100">00</text>
      <text x="170" y="100">01</text>
      <text x="30" y="110">+</text>
      <text x="100" y="135">C</text>
      <text x="100" y="188">$30</text>
      <text x="185" y="188">$31</text>
    </g>
  </g>
</svg>
</div>

<blockquote><pre>
CLC        <span class=comment>; Cフラグをクリアする。</span>
LDA $30    <span class=comment>; メモリ$30番地の値を Aレジスタに読み込む。</span>
ADC #$01   <span class=comment>; A = A + 1 <mark>+ 0</mark></span>
STA $30    <span class=comment>; Aレジスタの値をメモリ $30番地に書き込む。</span>
LDA $31    <span class=comment>; メモリ$31番地の値を Aレジスタに読み込む。</span>
ADC #$00   <span class=comment>; A = A + 0 <mark>+ C</mark></span>
STA $31    <span class=comment>; Aレジスタの値をメモリ $31番地に書き込む。</span>
</pre></blockquote>

<div class=figure>
<table border>
<tr><th>命令語</th><th>バイト数</th><th>機能</th></tr>
<td><code>CLC</code></td>
<td>1</td>
<td>Cフラグの値を 0 にする。</td>
</tr>
</table>
</div>

<h3>4.1. 16ビット値を使った画面書き換え</h3>
<p>
以上のテクニックと以下の「間接差分アドレッシング」を組み合わせると、
256バイト (=8ビット) 以上のメモリ領域にアクセスできる。
つまり、画面のより広い領域に描画できるようになる。

<div class=figure>
<table border>
<tr><th>命令語</th><th>バイト数</th><th>機能</th></tr>
<tr>
  <td><code>STA ($<mark><span class=hex>ZZ</span></mark>,X)</code></td>
  <td>2 (命令 1 + アドレス 1)</td>
  <td>間接差分アドレッシング。
  <ol>
    <li> メモリ上の ($<mark><span class=hex>ZZ</span></mark>+X)
      番地に書かれている値を2バイト分 (16ビット分) 読み込む。<br>
      ($<mark><span class=hex>ZZ</span></mark>+X) 番地の内容 … PP<br>
      ($<mark><span class=hex>ZZ</span></mark>+X+1) 番地の内容 … QQ<br>
<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="400" height="80">
  <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
    <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
  </marker>
  <g transform="translate(0.5,0.5)">
    <g fill="none" stroke="black" stroke-width="1">
      <line x1="0" y1="50" x2="340" y2="50" />
      <line x1="0" y1="70" x2="340" y2="70" />
      <line x1="20" y1="50" x2="20" y2="70" />
      <line x1="60" y1="50" x2="60" y2="70" />
      <line x1="100" y1="50" x2="100" y2="70" />
      <rect x="240" y="50" width="40" height="20" fill="gray" />
      <g stroke-width="2">
	<polyline points="60,40 60,20 260,20 260,48" marker-end="url(#arrow)" />
	<polyline points="20,48 20,40 100,40 100,48" />
      </g>
    </g>
    <g text-anchor="middle" style="font-family: monospace;">
      <text x="40" y="65">$ZZ</text>
      <text x="80" y="65">$ZZ+1</text>
    </g>
    <g text-anchor="middle">
      <text x="160" y="14">この2バイトで表されるアドレス</text>
    </g>
  </g>
</svg>
</div>
    <li> その値がさすアドレス ($<mark><span class=hex>QQPP</span></mark>) に A レジスタの値を書き込む。<br>
      アドレスの上2桁、下2桁が<strong>逆になっている</strong>ことに注意。
      (リトルエンディアン)
  </ol>
</td></tr>
</table>
</div>

<div class=file>
プログラム6
<pre>
    LDA #$00
    STA $30
    LDA #$02
    STA $31
loop:
    LDX #$00
    LDA #$01
    STA ($30,X)  <span class=comment>; A をメモリ ($30+X) 番地に書かれている番地に書き込む。</span>
<div class=qqq>    ???          ; 16ビットの加算をおこなう
    ...
</div>    JMP loop
</pre></div>

<div class=exercise id="ex-16bit-addition">
<div class=header>演習. 16ビットの演算</div>
<p>
上のプログラム 6. を完成させ、
画面全体を塗りつぶすようにせよ。
</div>


<h2 id="famicom">5. ファミコン (NES) と 6502</h2>
<p>
<a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%83%9F%E3%83%AA%E3%83%BC%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF">ファミリーコンピュータ</a>
(Nintendo Entertainment System、ファミコン) は
1983年に任天堂から発売されたゲーム機で、
リコー製の改造版 6502 を使っていた。また 2KB のメモリと、
画面処理のための PPU (Picture Processing Unit) を搭載していた。

<p>
ファミコンのハードウェアはかなり複雑で、
画面表示のためには CPU が PPU と通信する必要がある。
また、初期のゲームは最大 32KB までに制限されていた。
アドレス構造は以下のようになっている:

<div class=figure>
<table border>
<tr><th>アドレス範囲</th><th>機能</th></tr>
<tr>
<td>$<span class=hex>0000</span> 〜 $<span class=hex>07FF</span></td>
<td>メインメモリ</td>
</tr><tr>
<td>$<span class=hex>0800</span> 〜 $<span class=hex>1FFF</span></td>
<td>未使用領域</td>
</tr><tr>
<td>$<span class=hex>2000</span> 〜 $<span class=hex>2007</span></td>
<td>PPU 制御レジスタ</td>
</tr><tr>
<td>$<span class=hex>2008</span> 〜 $<span class=hex>3FFF</span></td>
<td>未使用領域</td>
</tr><tr>
<td>$<span class=hex>4000</span> 〜 $<span class=hex>401F</span></td>
<td>APU レジスタ等</td>
</tr><tr>
<td>$<span class=hex>4020</span> 〜 $<span class=hex>5FFF</span></td>
<td>カートリッジ拡張ROM</td>
</tr><tr>
<td>$<span class=hex>6000</span> 〜 $<span class=hex>7FFF</span></td>
<td>SRAM</td>
</tr><tr>
<td>$<span class=hex>8000</span> 〜 $<span class=hex>FFFF</span></td>
<td>プログラム用ROM</td>
</tr>
</table>
</div>

<p>
ファミコンでもっとも有名なゲーム
「スーパーマリオブラザーズ」も (プログラム・グラフィックス等込みで)
32KB の領域で作られていた。
<ul>
<li> <a href="https://gist.github.com/1wErt3r/4048722">「スーパーマリオブラザーズ」の機械語を解析 (逆アセンブル) したソースコード</a>
</ul>

<h2 id="modern">6. 現代のコンピュータとの違い</h2>
<p>
現代の <a target="_blank" href="https://en.wikipedia.org/wiki/X86">最新鋭の演算装置</a>でも、
基本的にやっていることは変わらない。ただ量が増えているだけである。
<div class=figure>
<table border>
<tr><th></th><th>1975年</th><th>2021年</th></tr>
<tr><td>レジスタの数</td><td align=right>4</td><td align=right>40</td></tr>
<tr><td>計算できるビット数</td><td align=right>8</td><td align=right>64</td></tr>
<tr><td>メモリの容量</td><td align=right>65,536</td><td align=right>34,359,738,368</td></tr>
<tr><td>1秒間の命令実行数</td><td align=right>1,000,000</td><td align=right>1,000,000,000</td></tr>
<tr><td>プログラムの大きさ</td><td align=right>10,000</td><td align=right>10,000,000,000</td></tr>
</table>
</div>

<h3 id="os">6.1. オペレーティングシステム (OS) とは何か?</h3>
<p>
現在のコンピュータでは、一般人が上で示したような
プログラムを書く必要はない。文字表示やファイル処理など非常に基本的な部分は、
「<u>オペレーティングシステム</u> (OS, 基本ソフトウェア)」として
最初からPCと一緒に提供されているためである。
ほとんどの人は、このオペレーティングシステムを使った
アプリケーション (応用ソフトウェア) を書く。
しかし実際にはこれはコンピュータで動いているソフトウェア全体の
ごく一部にすぎない。

<div class=figure>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" width="300" height="200">
  <g fill="white" stroke="black" stroke-width="2">
    <rect x="2" y="2" width="296" height="196" fill="#ddd" />
    <rect x="150" y="50" width="60" height="40"/>
    <rect x="50" y="110" width="60" height="40"/>
    <rect x="190" y="140" width="60" height="40"/>
  </g>
  <g text-anchor="middle">
    <text x="150" y="20" dy="0.5em">オペレーティングシステム (OS)</text>
    <text x="180" y="70" dy="0.5em">アプリ</text>
    <text x="80" y="130" dy="0.5em">アプリ</text>
    <text x="220" y="160" dy="0.5em">アプリ</text>
  </g>
</svg>
</div>

<p>
また、OS は多くの仮想化処理を実現している。
画面や記憶装置は、コンピュータにとっては (長さの決まった)
0 と 1 のリストであるので、実際には以下のものは OS が
あるかのように見せかけている「幻影」である。
このような OS の仮想化機能により、
現在のパソコンは実際の仕組みを知らなくても
「なんとなく」使えるものになっている。
しかし実際の中身は非常に複雑なのである。

<h4>OS によって作り出されている見せかけの例</h4>
<ul>
<li> アニメーション …
  一定時間おきに画像を何度も書き直す (コピーしなおす) 処理。

<li> ファイルとフォルダ …
  ディスクは実際にはでっかいリストなので、
  「ファイル」「フォルダ」などというものは本来存在しない。
  ここでは、ディスク上のどの要素からどの要素までが
  どのファイルを表すのかを示す印をどこかに書いておくだけである。

<li> ディスクの「空き容量」 …
  ディスクは実際には物理的な媒体であり、その容量は増えも減りもしない。
  一般にディスクの「空き容量」といっているのは、
  単にディスク上の「ファイルがあるとされている範囲」を
  除いた残りの部分の大きさを示しているだけである。

<li> メールを「送る」 …
  物理的に送ったものはなくなるが、メールは送っても自分の手元に残っている。
  実際には、メールや画像を「送る」というのは、相手のコンピュータに
  同じデータをコピーしているだけである。

<li> 複数アプリの同時並列処理 …
  実際には、コンピュータが実行できるのは一度にひとつのプログラムだけである
  (注: 最近のマルチコアのCPUを除く)。複数のアプリが同時に動いているように
  見えるのは、OS が各アプリをちょっとずつ (1/100秒程度) 動かしては
  高速で切り替えているだけである。ようするに「見せかけ」なのだ。

</ul>
<P>
結局のところ、コンピュータはみな非常に単純な原理で動いている。
これを組み合わせて複雑な処理をしているように見せかけているのが、
現代のコンピュータシステムなのである。


<hr>
<address>
Yusuke Shinyama
</address>
